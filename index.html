<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>muteki-shims: M*LIB: Generic type-safe Container Library for C language</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<!--Doxygen Awesome Plugins-->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript">
DoxygenAwesomeDarkModeToggle.init()
DoxygenAwesomeTabs.init()
</script>
<!--/Doxygen Awesome Plugins-->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">muteki-shims
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">M*LIB: Generic type-safe Container Library for C language </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_include_2mutekix_2mlib_2README"></a></p>
<ol type="1">
<li>Overview</li>
<li>Components</li>
<li>Build &amp; Installation</li>
<li>How to use</li>
<li>Performance</li>
<li>OPLIST</li>
<li>Memory Allocation</li>
<li>Emplace construction</li>
<li>Errors &amp; compilers</li>
<li>External Reference</li>
<li>API Documentation<ol type="a">
<li>Generic methods</li>
<li>List</li>
<li>Array</li>
<li>Deque</li>
<li>Dictionary</li>
<li>Tuple</li>
<li>Variant</li>
<li>Red/Black Tree</li>
<li>B+ Tree</li>
<li>Generic Tree</li>
<li>Priority queue</li>
<li>Fixed buffer queue</li>
<li>Atomic Shared Register</li>
<li>Shared pointers</li>
<li>Intrusive Shared Pointers</li>
<li>Intrusive list</li>
<li>Concurrent adapter</li>
<li>Bitset</li>
<li>String</li>
<li>Core preprocessing</li>
<li>Thread</li>
<li>Worker threads</li>
<li>Atomic</li>
<li>Generic algorithms</li>
<li>Function objects</li>
<li>Exception handling</li>
<li>Memory pool</li>
<li>JSON Serialization</li>
<li>Binary Serialization</li>
<li>Generic interface</li>
</ol>
</li>
<li>Global User Customization</li>
<li>License</li>
</ol>
<h1><a class="anchor" id="autotoc_md8"></a>
Overview</h1>
<p>M*LIB (M star lib) is a C library enabling to define and to use <b>generic and type safe container</b> in C, aka handling generic <a href="https://en.wikipedia.org/wiki/Container_%28abstract_data_type%29">containers</a> in pure C language. The encapsulated objects can have their own constructor, destructor, operators or can be basic C type like the C type 'int': both are fully supported. This makes it possible to construct fully recursive container objects (<code>container-of[...]-container-of-type-T</code>) while keeping compile time type checking.</p>
<p>This is an equivalent of the <a href="https://en.wikipedia.org/wiki/C%2B%2B">C++</a> <a href="https://en.wikipedia.org/wiki/C%2B%2B_Standard_Library">Standard Library</a>, providing vector, deque, forward_list, set, map, multiset, multimap, unordered_set, unordered_map, stack, queue, shared_ptr, string, variant, option to standard ISO C99 / C11. There is not a strict mapping as both the STL and M*LIB have their exclusive containers:</p>
<p>See <a href="https://github.com/P-p-H-d/mlib/wiki/STL-to-M*LIB-mapping">here</a> for details. M*LIB provides also additional concurrent containers to design properly multi-threaded programs: shared register, communication queue, ...</p>
<p>M*LIB is portable to any systems that support <a href="https://en.wikipedia.org/wiki/C99">ISO C99</a>. Some optional features need at least <a href="https://en.wikipedia.org/wiki/C11_(C_standard_revision)">ISO C11</a>.</p>
<p>M*LIB is <b>only</b> composed of a set of headers. There is no C file, and as such, the installation is quite simple: you just have to put the header in the search path of your compiler, and it will work. There is no dependency (except some other headers of M*LIB and the LIBC).</p>
<p>One of M*LIB design key is to ensure safety. This is done by multiple means:</p>
<ul>
<li>in debug mode, defensive programming is extensively used: the contracts of the function are checked, ensuring that the data are not corrupted. For example, strict <a href="https://en.wikipedia.org/wiki/Buffer_overflow">Buffer overflow</a> are checked in this mode through <a href="https://en.wikipedia.org/wiki/Bounds_checking">bound checking</a> or the intrinsic properties of a Red-Black tree (for example) are verified. Buffer overflow checks can still be kept in release mode if needed.</li>
<li>as few cast as possible are used within the library (casts are the evil of safety). Still the library can be used with the greatest level of warnings by a C compiler without any aliasing warning.</li>
<li>the genericity is not done directly by macro (which usually prevent type safety), but indirectly by making them define inline functions with the proper prototypes: this enables the user calls to have proper error and warning checks.</li>
<li>extensive testing: the library is tested on the main targets using Continuous Integration with a coverage of the test suite of more than 99%. The test suite itself is run through the multiple sanitizers defined by GCC/CLANG (Address, undefined, leak, thread). The test suite also includes a comparison of equivalent behaviors of M*LIB with the C++ STL using random testing or fuzzer testing.</li>
<li>static analysis: multiple static analyzer (like scan-build or GCC fanalyzer or CodeQL) are run on the generated code, and the results analyzed.</li>
</ul>
<p>Other key designs are:</p>
<ul>
<li>do not rewrite the C library and just wrap around it (for example don't rewrite sort but stable sort),</li>
<li>do not make users pay the cost of what they don't need.</li>
</ul>
<p>Due to the unfortunate <a href="https://en.wikipedia.org/wiki/Strong_and_weak_typing#Pointers">weak</a> nature of the C language for pointers, <a href="https://en.wikipedia.org/wiki/Type_safety">type safe</a> means that at least a warning is generated by the compiler in case of wrong type passed as container arguments to the functions.</p>
<p>M*LIB is still quite-efficient: there is no overhead in using this library rather than using direct C low-level access as the compiler is able to <b>fully</b> optimize the library usage and the library is carefully designed. In <a href="https://github.com/P-p-H-d/mlib/wiki/performance">fact</a>, M*LIB is one of the fastest generic C/C++ library you can find.</p>
<p>M*LIB uses internally the <code>malloc</code>, <code>realloc</code> and <code>free</code> functions to handle the memory pool. This behavior can be overridden at different level. Its default policy is to abort the program if there is a memory error. However, this behavior can also be customized globally. M*LIB supports also the exception error model by providing its own implementation of the try / catch mechanism. This mechanism is compatible with <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII programming</a>: when an exception is thrown, the destructors of the constructed objects are called (See m-try for more details).</p>
<p>M*LIB may use a lot of assertions in its implementation to ensure safety: it is highly recommended to properly define <code>NDEBUG</code> for released programs.</p>
<p>M*LIB provides automatically several <a href="https://en.wikipedia.org/wiki/Serialization">serialization</a> methods for each containers. You can read or write your full and complex data structure into <a href="https://en.wikipedia.org/wiki/JSON">JSON</a> format in a few lines.</p>
<p>M*LIB is distributed under BSD-2 simplified license.</p>
<p>It is strongly advised not to read the source to know how to use the library as the code is quite complex and uses a lot of tricks but rather read the examples.</p>
<p>In this documentation,</p><ul>
<li><em>shall</em> will be used to indicate a user constraint that is mandatory to follow under penalty of undefined behavior.</li>
<li><em>should</em> will be used to indicate a recommendation to the user.</li>
</ul>
<p>All pointers expected by the functions of the library shall expect non-null argument except if indicated.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Components</h1>
<p>The following headers define containers that don't require the user structure to be modified:</p>
<ul>
<li>m-array.h: header for creating dynamic array of generic type,</li>
<li>m-list.h: header for creating singly-linked list of generic type,</li>
<li>m-deque.h: header for creating dynamic double-ended queue of generic type,</li>
<li>m-dict.h: header for creating unordered associative array (through hashmap) or unordered set of generic type,</li>
<li>m-rbtree.h: header for creating ordered set (through Red/Black binary sorted tree) of generic type,</li>
<li>m-bptree.h: header for creating ordered map/set/multimap/multiset (through sorted B+TREE) of generic type,</li>
<li>m-tree.h: header for creating arbitrary tree of generic type,</li>
<li>m-tuple.h: header for creating arbitrary tuple of generic types,</li>
<li>m-variant.h: header for creating arbitrary variant of generic type,</li>
<li>m-prioqueue.h: header for creating dynamic priority queue of generic type.</li>
</ul>
<p>The available containers of M*LIB for thread synchronization are in the following headers:</p>
<ul>
<li>m-buffer.h: header for creating fixed-size queue (or stack) of generic type (multiple producer / multiple consumer),</li>
<li>m-snapshot: header for creating 'atomic buffer' (through triple buffer) for sharing synchronously big data (thread safe),</li>
<li>m-shared.h: header for creating shared pointer of generic type,</li>
<li>m-concurrent.h: header for transforming a container into a concurrent container (thread safe),</li>
<li><a class="el" href="m-c-mempool_8h_source.html">m-c-mempool.h</a>: WIP header for creating fast concurrent memory allocation.</li>
</ul>
<p>The following containers are intrusive (You need to modify your structure to add fields needed by the container) and are defined in:</p>
<ul>
<li>m-i-list.h: header for creating doubly-linked intrusive list of generic type,</li>
<li>m-i-shared.h: header for creating intrusive shared pointer of generic type (Thread Safe).</li>
</ul>
<p>Other headers offering other functionality are:</p>
<ul>
<li>m-string.h: header for creating dynamic string of characters (UTF-8 support),</li>
<li>m-bitset.h: header for creating dynamic bitset (or "packed array of bool"),</li>
<li>m-algo.h: header for providing various generic algorithms to the previous containers,</li>
<li>m-funcobj.h: header for creating function object (used by algorithm generation),</li>
<li>m-try.h: header for handling errors by throwing exceptions,</li>
<li>m-mempool.h: header for creating specialized &amp; fast memory allocator,</li>
<li>m-worker.h: header for providing an easy pool of workers on separated threads to handle work orders (used for parallel tasks),</li>
<li>m-serial-json.h: header for importing / exporting the containers in <a href="https://en.wikipedia.org/wiki/JSON">JSON format</a>,</li>
<li>m-serial-bin.h: header for importing / exporting the containers in an adhoc fast binary format,</li>
<li>m-generic.h: header for using a common interface for all registered types,</li>
<li><a href="m-genint.h">m-genint.h</a>: internal header for generating unique integers in a concurrent context,</li>
<li>m-core.h: header for meta-programming with the C preprocessor (used by all other headers).</li>
</ul>
<p>Finally, headers for compatibility with non C11 compilers:</p>
<ul>
<li>m-atomic.h: header for ensuring compatibility between C's <code>stdatomic.h</code> and C++'s atomic header (provide also its own implementation if nothing is available),</li>
<li>m-thread.h: header for providing a very thin layer across multiple implementation of mutex/threads (C11/PTHREAD/WIN32).</li>
</ul>
<p>Each containers define their iterators (if it is meaningful).</p>
<p>All containers try to expose the same common interface: if the method name is the same, then it does the same thing and is used in the same way. In some rare case, the method is adapted to the container needs.</p>
<p>Each header can be used separately from others: dependency between headers have been kept to the minimum.</p>
<p><img src="https://raw.githubusercontent.com/P-p-H-d/mlib/master/doc/depend.png" alt="Dependence between headers" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md10"></a>
Build &amp; Installation</h1>
<p>M*LIB is <b>only</b> composed of a set of headers, as such there is no build for the library. The library doesn't depend on any other library than the LIBC.</p>
<p>To run the test suite, run:</p>
<div class="fragment"><div class="line">make check</div>
</div><!-- fragment --><p>You can also override the compiler CC or its flags CFLAGS if needed:</p>
<div class="fragment"><div class="line">make check CC=&quot;gcc&quot; CFLAGS=&quot;-O3&quot;</div>
</div><!-- fragment --><p>To generate the documentation, run:</p>
<div class="fragment"><div class="line">make doc</div>
</div><!-- fragment --><p>To install the headers, run:</p>
<div class="fragment"><div class="line">make install PREFIX=/my/directory/where/to/install [DESTDIR=...]</div>
</div><!-- fragment --><p>Other targets exist. Mainly for development purpose.</p>
<h1><a class="anchor" id="autotoc_md11"></a>
How to use</h1>
<p>To use these data structures, you first include the desired header, instantiate the definition of the structure and its associated methods by using a macro <code>_DEF</code> for the needed container. Then you use the defined types and functions. Let's see a first simple example that creates a list of unsigned int:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;m-list.h&quot;</span></div>
<div class="line"> </div>
<div class="line">LIST_DEF(list_uint, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) <span class="comment">/* Define struct list_uint_t and its methods */</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">   list_uint_t list ;             <span class="comment">/* list_uint_t has been define above */</span></div>
<div class="line">   list_uint_init(list);          <span class="comment">/* All type needs to be initialized */</span></div>
<div class="line">   list_uint_push_back(list, 42); <span class="comment">/* Push 42 in the list */</span></div>
<div class="line">   list_uint_push_back(list, 17); <span class="comment">/* Push 17 in the list */</span></div>
<div class="line">   list_uint_it_t it;             <span class="comment">/* Define an iterator to scan each one */</span></div>
<div class="line">   <span class="keywordflow">for</span>(list_uint_it(it, list)     <span class="comment">/* Start iterator on first element */</span></div>
<div class="line">       ; !list_uint_end_p(it)     <span class="comment">/* Until the end is not reached */</span></div>
<div class="line">       ; list_uint_next(it)) {    <span class="comment">/* Set the iterator to the next element*/</span></div>
<div class="line">          printf(<span class="stringliteral">&quot;%d\n&quot;</span>,          <span class="comment">/* Get a reference to the underlying */</span></div>
<div class="line">            *list_uint_cref(it)); <span class="comment">/* data and print it */</span></div>
<div class="line">   }</div>
<div class="line">   list_uint_clear(list);         <span class="comment">/* Clear all the list (destroying the object list)*/</span></div>
<div class="line">}</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>&zwj;[!NOTE] Do not forget to add <code>-std=c99</code> (or c11) to your compile command to request a C99 compatible build</p>
<p></p>
</blockquote>
<p>This looks like a typical C program except the line with <code>LIST_DEF</code> that doesn't have any semi-colon at the end. And in fact, except this line, everything is typical C program and even macro free! The only macro is in fact <code>LIST_DEF</code>: this macro expands to the good type for the list of the defined type and to all the necessary functions needed to handle such type. It is heavily context dependent and can generate different code depending on it. You can use it as many times as needed to defined as many lists as you want. The first argument of the macro is the name to use, e.g. the prefix that is added to all generated functions and types. The second argument of the macro is the type to embed within the container. It can be any C type. The third argument of the macro is optional and is the oplist to use. See below for more information.</p>
<p>You could replace <code>LIST_DEF</code> by <code>ARRAY_DEF</code> to change the kind of container (an array instead of a linked list) without changing the code below: the generated interface of a list or of an array is very similar. Yet the performance remains the same as hand-written code for both the list variant and the array variant.</p>
<p>This is equivalent to this C++ program using the STL:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> std::list&lt;unsigned int&gt; list_uint_t;</div>
<div class="line"><span class="keyword">typedef</span> std::list&lt;unsigned int&gt;::iterator list_uint_it_t;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">   list_uint_t list ;             <span class="comment">/* list_uint_t has been define above */</span></div>
<div class="line">   list.push_back(42);            <span class="comment">/* Push 42 in the list */</span></div>
<div class="line">   list.push_back(17);            <span class="comment">/* Push 17 in the list */</span></div>
<div class="line">   <span class="keywordflow">for</span>(list_uint_it_t it = list.begin()  <span class="comment">/* Iterator is first element*/</span></div>
<div class="line">       ; it != list.end()         <span class="comment">/* Until the end is not reached */</span></div>
<div class="line">       ; ++it) {                  <span class="comment">/* Set the iterator to the next element*/</span></div>
<div class="line">       std::cout &lt;&lt; *it &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;  <span class="comment">/* Print the underlying data */</span></div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><p>As you can see, this is rather equivalent with the following remarks:</p>
<ul>
<li>M*LIB requires an explicit definition of the instance of the list,</li>
<li>M*LIB code is more verbose in the method name,</li>
<li>M*LIB needs explicit construction and destruction (as plain old C requests),</li>
<li>M*LIB doesn't return a value to the underlying data but a pointer to this value:<ul>
<li>this was done for performance (it avoids copying all the data within the stack)</li>
<li>and for generality reasons (some structure may not allow copying data).</li>
</ul>
</li>
</ul>
<p>Note: M*LIB defines its own container as an array of a structure of size 1. This has the following advantages:</p>
<ul>
<li>you effectively reserve the data whenever you declare a variable,</li>
<li>you pass automatically the variable per reference for a function call,</li>
<li>you can not copy the variable by an affectation (you have to use the API instead).</li>
</ul>
<p>M*LIB offers also the possibility to condense further your code, so that it is more high level: by using the <code>M_EACH</code> &amp; <code>M_LET</code> macros (if you are not afraid of using syntactic macros):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;m-list.h&quot;</span></div>
<div class="line"> </div>
<div class="line">LIST_DEF(list_uint, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)   <span class="comment">/* Define struct list_uint_t and its methods */</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">   M_LET(list, LIST_OPLIST(uint)) { <span class="comment">/* Define &amp; init list as list_uint_t */</span></div>
<div class="line">     list_uint_push_back(list, 42); <span class="comment">/* Push 42 in the list */</span></div>
<div class="line">     list_uint_push_back(list, 17); <span class="comment">/* Push 17 in the list */</span></div>
<div class="line">     <span class="keywordflow">for</span> M_EACH(item, list, LIST_OPLIST(uint)) {</div>
<div class="line">       printf(<span class="stringliteral">&quot;%d\n&quot;</span>, *item);       <span class="comment">/* Print the item */</span></div>
<div class="line">     }</div>
<div class="line">   }                                <span class="comment">/* Clear of list will be done now */</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Here is another example with a complete type (with proper initialization &amp; clear function) by using the <a href="https://gmplib.org/">GMP</a> library:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gmp.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;m-array.h&quot;</span></div>
<div class="line">ARRAY_DEF(array_mpz, mpz_t, (INIT(mpz_init), INIT_SET(mpz_init_set), SET(mpz_set), CLEAR(mpz_clear)) )</div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">   array_mpz_t array ;             <span class="comment">/* array_mpz_t has been define above */</span></div>
<div class="line">   array_mpz_init(array);          <span class="comment">/* All type needs to be initialized */</span></div>
<div class="line">   mpz_t z;                        <span class="comment">/* Define a mpz_t type */</span></div>
<div class="line">   mpz_init(z);                    <span class="comment">/* Initialize the z variable */</span></div>
<div class="line">   mpz_set_ui (z, 42);</div>
<div class="line">   array_mpz_push_back(array, z);  <span class="comment">/* Push 42 in the array */</span></div>
<div class="line">   mpz_set_ui (z, 17);</div>
<div class="line">   array_mpz_push_back(array, z); <span class="comment">/* Push 17 in the array */</span></div>
<div class="line">   array_it_mpz_t it;              <span class="comment">/* Define an iterator to scan each one */</span></div>
<div class="line">   <span class="keywordflow">for</span>(array_mpz_it(it, array)     <span class="comment">/* Start iterator on first element */</span></div>
<div class="line">       ; !array_mpz_end_p(it)      <span class="comment">/* Until the end is not reached */</span></div>
<div class="line">       ; array_mpz_next(it)) {     <span class="comment">/* Set the iterator to the next element*/</span></div>
<div class="line">          gmp_printf(<span class="stringliteral">&quot;%Zd\n&quot;</span>,      <span class="comment">/* Get a reference to the underlying */</span></div>
<div class="line">            *array_mpz_cref(it));  <span class="comment">/* data and print it */</span></div>
<div class="line">   }</div>
<div class="line">   mpz_clear(z);                   <span class="comment">/* Clear the z variable */</span></div>
<div class="line">   array_mpz_clear(array);         <span class="comment">/* Clear all the array */</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>As the <code>mpz_t</code> type needs proper initialization, copy and destroy functions we need to tell to the container how to handle such a type. This is done by giving it the oplist associated to the type. An oplist is an associative array where the operators are associated to methods.</p>
<p>In the example, we tell to the container to use the <code>mpz_init</code> function for the <code>INIT</code> operator of the type (aka constructor), the <code>mpz_clear</code> function for the <code>CLEAR</code> operator of the type (aka destructor), the <code>mpz_set</code> function for the <code>SET</code> operator of the type (aka copy), the <code>mpz_init_set</code> function for the <code>INIT_SET</code> operator of the type (aka copy constructor). See OPLIST chapter for more detailed information.</p>
<p>We can also write the same example shorter:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gmp.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;m-array.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Register the oplist of a mpz_t.</span></div>
<div class="line"><span class="preprocessor">#define M_OPL_mpz_t() (INIT(mpz_init), INIT_SET(mpz_init_set), \</span></div>
<div class="line"><span class="preprocessor">        SET(mpz_set), CLEAR(mpz_clear))</span></div>
<div class="line"><span class="comment">// Define an instance of an array of mpz_t (both type and function)</span></div>
<div class="line">ARRAY_DEF(array_mpz, mpz_t)</div>
<div class="line"><span class="comment">// Register the oplist of the created instance of array of mpz_t</span></div>
<div class="line"><span class="preprocessor">#define M_OPL_array_mpz_t() ARRAY_OPLIST(array_mpz, M_OPL_mpz_t())</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">  <span class="comment">// Let&#39;s define `array` as an &#39;array_mpz_t&#39; &amp; initialize it.</span></div>
<div class="line">  M_LET(array, array_mpz_t)</div>
<div class="line">    <span class="comment">// Let&#39;s define &#39;z1&#39; and &#39;z2&#39; to be &#39;mpz_t&#39; &amp; initialize it</span></div>
<div class="line">    M_LET (z1, z2, mpz_t) {</div>
<div class="line">     mpz_set_ui (z1, 42);</div>
<div class="line">     array_mpz_push_back(array, z1);  <span class="comment">/* Push 42 in the array */</span></div>
<div class="line">     mpz_set_ui (z2, 17);</div>
<div class="line">     array_mpz_push_back(array, z2); <span class="comment">/* Push 17 in the array */</span></div>
<div class="line">     <span class="comment">// Let&#39;s iterate over all items of the container</span></div>
<div class="line">     <span class="keywordflow">for</span> M_EACH(item, array, array_mpz_t) {</div>
<div class="line">          gmp_printf(<span class="stringliteral">&quot;%Zd\n&quot;</span>, *item);</div>
<div class="line">     }</div>
<div class="line">  } <span class="comment">// All variables are cleared with the proper method beyond this point.</span></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Or even shorter when you're comfortable enough with the library:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gmp.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;m-array.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Register the oplist of a mpz_t. It is a classic oplist.</span></div>
<div class="line"><span class="preprocessor">#define M_OPL_mpz_t() M_OPEXTEND(M_CLASSIC_OPLIST(mpz),         \</span></div>
<div class="line"><span class="preprocessor">        INIT_WITH(mpz_init_set_ui), EMPLACE_TYPE(unsigned int))</span></div>
<div class="line"><span class="comment">// Define an instance of an array of mpz_t (both type and function)</span></div>
<div class="line">ARRAY_DEF(array_mpz, mpz_t)</div>
<div class="line"><span class="comment">// Register the oplist of the created instance of array of mpz_t</span></div>
<div class="line"><span class="preprocessor">#define M_OPL_array_mpz_t() ARRAY_OPLIST(array_mpz, M_OPL_mpz_t())</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="comment">// Let&#39;s define `array` as an &#39;array_mpz_t&#39; with mpz_t(17) and mpz_t(42)</span></div>
<div class="line">    M_LET((array,(17),(42)), array_mpz_t) {</div>
<div class="line">     <span class="comment">// Let&#39;s iterate over all items of the container</span></div>
<div class="line">     <span class="keywordflow">for</span> M_EACH(item, array, array_mpz_t) {</div>
<div class="line">          gmp_printf(<span class="stringliteral">&quot;%Zd\n&quot;</span>, *item);</div>
<div class="line">     }</div>
<div class="line">  } <span class="comment">// All variables are cleared with the proper method beyond this point.</span></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>There are two ways a container can known what is the oplist of a type:</p>
<ul>
<li>either the oplist is passed explicitly for each definition of container and for the <code>M_LET</code> and <code>M_EACH</code> macros,</li>
<li>or the oplist is registered globally by defining a new macro starting with the prefix <code>M_OPL_</code> and finishing with the name of type (don't forget the parenthesis and the suffix _t if needed). The macros performing the definition of container and the <code>M_LET</code> and <code>M_EACH</code> will test if such macro is defined. If it is defined, it will be used. Otherwise, default methods are used.</li>
</ul>
<p>Here we can see that we register the <code>mpz_t</code> type into the container with the minimum information of its interface needed, and another one to initialize a <code>mpz_t</code> from an unsigned integer.</p>
<p>We can also see in this example so the container ARRAY provides also a macro to define the oplist of the array itself. This is true for all containers and this enables to define proper recursive container like in this example which reads from a text file a definition of sections:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;m-array.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;m-tuple.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;m-dict.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;m-string.h&quot;</span></div>
<div class="line"> </div>
<div class="line">TUPLE_DEF2(symbol, (offset, <span class="keywordtype">long</span>), (value, <span class="keywordtype">long</span>))</div>
<div class="line"><span class="preprocessor">#define M_OPL_symbol_t() TUPLE_OPLIST(symbol, M_BASIC_OPLIST, M_BASIC_OPLIST)</span></div>
<div class="line"> </div>
<div class="line">ARRAY_DEF(array_symbol, symbol_t)</div>
<div class="line"><span class="preprocessor">#define M_OPL_array_symbol_t() ARRAY_OPLIST(array_symbol, M_OPL_symbol_t())</span></div>
<div class="line"> </div>
<div class="line">DICT_DEF2(sections, string_t, array_symbol_t)</div>
<div class="line"><span class="preprocessor">#define M_OPL_sections_t() DICT_OPLIST(sections, STRING_OPLIST, M_OPL_array_symbol_t())</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (argc &lt; 2) abort();</div>
<div class="line">  FILE *f = fopen(argv[1], <span class="stringliteral">&quot;rt&quot;</span>);</div>
<div class="line">  <span class="keywordflow">if</span> (!f) abort();</div>
<div class="line">  M_LET(sc, sections_t) {</div>
<div class="line">    sections_in_str(sc, f);</div>
<div class="line">    array_symbol_t *a = sections_get(sc, STRING_CTE(<span class="stringliteral">&quot;.text&quot;</span>));</div>
<div class="line">    <span class="keywordflow">if</span> (a == NULL) {</div>
<div class="line">      printf(<span class="stringliteral">&quot;There is no .text section.&quot;</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      printf(<span class="stringliteral">&quot;Section .text is :&quot;</span>);</div>
<div class="line">      array_symbol_out_str(stdout, *a);</div>
<div class="line">      printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This example reads the data from a file and outputs the .text section if it finds it on the terminal.</p>
<p>Other examples are available in the example folder.</p>
<p>Internal fields of the structure are subject to change even for small revision of the library.</p>
<p>The final goal of the library is to be able to write code like this in pure C while keeping type safety and compile time name resolution:</p>
<div class="fragment"><div class="line">M_LET(list, list_uint_t) {</div>
<div class="line">  push(list, 42);</div>
<div class="line">  push(list, 17);</div>
<div class="line">  <span class="keywordflow">for each</span> (item, list) {</div>
<div class="line">    M_PRINT(*item, <span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>See the <a href="https://github.com/P-p-H-d/mlib/blob/master/example/ex11-generic01.c">example</a> and M-GENERIC header for details.</p>
<h1><a class="anchor" id="autotoc_md12"></a>
Performance</h1>
<p>M*LIB performance is compared to the one of GNU C++ STL (v10.2) in the following graphs. Each graph is presented first in linear scale and then in logarithmic scale to better realize the differences. M*LIB is on par with the STL or even faster.</p>
<p>All used bench codes are available in this <a href="https://github.com/P-p-H-d/c-stl-comparison">repository</a> The results for several different libraries are also available <a href="https://github.com/P-p-H-d/mlib/wiki/performance">in a separate page</a>.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
Singly List</h3>
<p><img src="https://raw.githubusercontent.com/P-p-H-d/mlib/master/doc/bench-list.png" alt="Singly List performance" class="inline"/> <img src="https://raw.githubusercontent.com/P-p-H-d/mlib/master/doc/bench-list-log.png" alt="Singly List performance - Log Scale" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md14"></a>
Array</h3>
<p><img src="https://raw.githubusercontent.com/P-p-H-d/mlib/master/doc/bench-array.png" alt="Array performance" class="inline"/> <img src="https://raw.githubusercontent.com/P-p-H-d/mlib/master/doc/bench-array-log.png" alt="Array performance - Log Scale" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md15"></a>
Unordered Map</h3>
<p><img src="https://raw.githubusercontent.com/P-p-H-d/mlib/master/doc/bench-umap.png" alt="Unordered Map performance" class="inline"/> <img src="https://raw.githubusercontent.com/P-p-H-d/mlib/master/doc/bench-umap-log.png" alt="Unordered Map performance - Log Scale" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md16"></a>
Ordered Set</h3>
<p><img src="https://raw.githubusercontent.com/P-p-H-d/mlib/master/doc/bench-oset.png" alt="Ordered Set performance" class="inline"/> <img src="https://raw.githubusercontent.com/P-p-H-d/mlib/master/doc/bench-oset-log.png" alt="Ordered Set performance - Log Scale" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md17"></a>
OPLIST</h1>
<h2><a class="anchor" id="autotoc_md18"></a>
Definition</h2>
<p>An <code>OPLIST</code> is a fundamental notion of M*LIB that hasn't be seen in any other library. In order to know how to operate on a type, M*LIB needs additional information as the compiler doesn't know how to handle properly any type (contrary to C++). This is done by giving an operator list (or oplist in short) to any macro that needs to handle the type. As such, an oplist has only meaning within a macro. Fundamentally, this is the exposed interface of a type: that is to say the association of the operators defined by the library to the effective methods provided by the type, including their call interface. This association is done only with the C preprocessor.</p>
<p>Therefore, an oplist is an associative array of operators to methods in the following format:</p>
<div class="fragment"><div class="line">(OPERATOR1(method1), OPERATOR2(method2), ...)</div>
</div><!-- fragment --><p>It starts with a parenthesis and ends with a parenthesis. Each association is separated by a comma. Each association is composed of a predefined operator (as defined below) a method (in parentheses), and an optional API interface (see below).</p>
<p>In the given example, the function <code>method1</code> is used to handle <code>OPERATOR1</code>. The function <code>method2</code> is used to handle <code>OPERATOR2</code>, etc.</p>
<p>In case the same operator appears multiple times in the list, the first apparition of the operator has priority, and its associated method will be used. This enables overloading of operators in oplist in case you want to inherit oplists.</p>
<p>The associated method in the oplist is a preprocessor expression that shall not contain a comma as first level.</p>
<p>An oplist has no real form from the C language point of view. It is just an abstraction that disappears after the macro expansion step of the preprocessing. If an oplist remains unprocessed after the C preprocessing, a compiler error will be generated.</p>
<h2><a class="anchor" id="autotoc_md19"></a>
Usage</h2>
<p>When you define an instance of a new container for a given type, you give the type <code>OPLIST</code> alongside the type for building the container. Some functions of the container may not be available in function of the provided interface of the <code>OPLIST</code> (for optional operators). Of if some mandatory operators are missing, a compiler error is generated.</p>
<p>The generated container will also provide its own oplist, which will depends on all the oplists used to generate it. This oplist can also be used to generate new containers.</p>
<p>You can therefore use the oplist of the container to chain this new interface with another container, creating container-of-container. <img src="https://raw.githubusercontent.com/P-p-H-d/mlib/master/doc/oplist.png" alt="oplist and definition" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md20"></a>
Operators</h2>
<blockquote class="doxtable">
<p>&zwj;[!NOTE] An operator shall fail only on <b>abnormal error</b> and if it is marked as potentially raising asynchronous errors. In this case it shall throw exceptions only if exceptions are configured. Otherwise, the program shall be terminated.</p>
<p>In this case, the objects remain initialized and valid but in an unspecified state. In case of in constructors, the object is not constructed and the destructor of the object has not to be called. </p>
</blockquote>
<blockquote class="doxtable">
<p>&zwj;[!NOTE] If an operator is not marked as raising asynchronous errors, it shall not fail or throw any exceptions in any cases. </p>
</blockquote>
<p>Not all operators are needed for an oplist to handle a container. If some operator is missing, the associated default method of the operator is used if it exists.</p>
<p>The following classic operators are usually expected for an object:</p>
<ul>
<li><code>INIT(obj)</code>: initialize the object <code>obj</code> into a valid state (constructor). It may raise asynchronous error.</li>
<li><code>INIT_SET(obj, org)</code>: initialize the object <code>obj</code> into the same state as the object <code>org</code> (copy constructor). It may raise asynchronous error.</li>
<li><code>SET(obj, org)</code>: set the initialized object <code>obj</code> into the same state as the initialized object org (copy operator). It may raise asynchronous error.</li>
<li><code>CLEAR(obj)</code>: destroy the initialized object <code>obj</code>, releasing any attached memory (destructor).</li>
</ul>
<p>Other documented operators are:</p>
<ul>
<li><code>NAME()</code> --&gt; <code>prefix</code>: Return the base name <code>prefix</code> used to construct the container.</li>
<li><code>TYPE()</code> --&gt; <code>type</code>: Return the base type associated to this oplist.</li>
<li><code>SUBTYPE()</code> --&gt; <code>type</code>: Return the type of the element stored in the container (used to iterate over the container).</li>
<li><code>GENTYPE()</code> --&gt; <code>type</code>: Return the type representing TYPE suitable for a _Generic statement.</li>
<li><code>OPLIST()</code> --&gt; <code>oplist</code>: Return the oplist of the type of the elements stored in the container.</li>
<li><code>KEY_TYPE()</code> --&gt; <code>key_t</code>: Return the key type for associative containers.</li>
<li><code>VALUE_TYPE()</code> --&gt; <code>value_t</code>: Return the value type for associative containers.</li>
<li><code>KEY_OPLIST()</code> --&gt; <code>oplist</code>: Return the oplist of the key type for associative containers.</li>
<li><code>VALUE_OPLIST()</code> --&gt; <code>oplist</code>: Return the oplist of the value type for associative containers.</li>
<li><code>NEW(type)</code> --&gt; <code>type pointer</code>: allocate a new object (with suitable alignment and size) and return a pointer to it. The returned object is <b>not initialized</b> (a constructor operator shall be called afterward). The default method is <code>M_MEMORY_ALLOC</code> (that allocates from the heap). It returns NULL in case of failure.</li>
<li><code>DEL(&amp;obj)</code>: free the allocated uninitialized object <code>obj</code>. The destructor of the pointed object shall be called before freeing the memory by calling this method. The object shall have been allocated by the associated NEW method. The default method is <code>M_MEMORY_DEL</code> (that frees to the heap). <code>obj</code> shall not be NULL and shall be of the proper type.</li>
<li><code>REALLOC(type, type pointer, number)</code> --&gt; <code>type pointer</code>: reallocate the given array referenced by type pointer (either a NULL pointer or a pointer returned by the associated <code>REALLOC</code> method itself) to an array of the number of objects of this type and return a pointer to this new array. Previously objects pointed by the pointer are kept up to the minimum of the new size and old one but may have moved from their original positions (if the array is reallocated otherwhere). New objects are not initialized (a constructor operator shall be called afterward). Freed objects are not cleared (A destructor operator shall be called before). The default is <code>M_MEMORY_REALLOC</code> (that allocates from the heap). It returns NULL in case of failure in which case the original array is not modified.</li>
<li><code>FREE(&amp;obj)</code>: free the allocated uninitialized array object <code>obj</code>. The destructor of the pointed objects shall be called before freeing the memory by calling this method. The objects shall have been allocated by the associated REALLOC method. The default is <code>M_MEMORY_FREE</code> (that frees to the heap).</li>
<li><code>INC_ALLOC(size_t s)</code> --&gt; <code>size_t</code>: Define the growing policy of an array (or equivalent structure). It returns a new allocation size based on the old allocation size (<code>s</code>). Default policy is to get the maximum between <code>2*s</code> and 16.</li>
</ul>
<blockquote class="doxtable">
<p>&zwj;[!NOTE] It doesn't check for overflow: if the returned value is lower than the old one, the user shall raise an overflow error (memory error). </p>
</blockquote>
<ul>
<li><code>INIT_MOVE(objd, objc)</code>: Initialize <code>objd</code> to the same state than <code>objc</code> by stealing as many resources as possible from <code>objc</code>, and then clear <code>objc</code> (constructor of <code>objd</code> + destructor of <code>objc</code>). It is semantically equivalent to calling <code>INIT_SET(objd,objc)</code> then <code>CLEAR(objc)</code> but is usually way faster. Contrary to the C++ choice of using "conservative move" semantic (you still need to call the destructor of a moved object in C++) M*LIB implements a "destructive move" semantic (this enables better optimization). By default, all objects are assumed to be <b>trivially movable</b> (i.e. using memcpy to move an object is safe). Most C objects (even complex structure) are trivially movable and it is a very nice property to have (enabling better optimization). A notable exception are intrusive objects. If an object is not trivially movable, it shall provide an <code>INIT_MOVE</code> method or disable the <code>INIT_MOVE</code> method entirely</li>
</ul>
<blockquote class="doxtable">
<p>&zwj;[!NOTE] Some containers may assume that the objects are always trivially movable (like array). Moved objects shall use the same memory allocator. </p>
</blockquote>
<ul>
<li><code>MOVE(objd, objc)</code>: Set <code>objd</code> to the same state than <code>objc</code> by stealing as resources as possible from <code>objc</code> and then clear <code>objc</code> (destructor of <code>objc</code>). It is equivalent to calling <code>SET(objd,objc)</code> then <code>CLEAR(objc)</code> or <code>CLEAR(objd)</code> and then <code>INIT_MOVE(objd, objc)</code>. See <code>INIT_MOVE</code> for details and constraints. TBC if this operator is really needed as calling <code>CLEAR</code> then <code>INIT_MOVE</code> is what do all known implementation, and is efficient.</li>
<li><code>INIT_WITH(obj, ...)</code>: Initialize the object <code>obj</code> with the given variable set of arguments (constructor). The arguments are variable and can be of different types. It is up to the method of the object to decide how to initialize the object based on this initialization array. This operator is used by the <code>M_LET</code> macro to initialize objects with their given values and this operator defines what the <code>M_LET</code> macro supports. It may raise asynchronous error.</li>
</ul>
<blockquote class="doxtable">
<p>&zwj;[!NOTE] </p>
</blockquote>
<p>&gt;In C11, you can use <code>API_1(M_INIT_WITH_THROUGH_EMPLACE_TYPE)</code> as method to automatically use the different emplace functions defined in <code>EMPLACE_TYPE</code> through a _Generic switch case. The <code>EMPLACE_TYPE</code> shall use the LIST format. See emplace chapter. </p><blockquote class="doxtable">
<p>&zwj; </p>
</blockquote>
<p>* <code>SWAP(objd, objc)</code>: Swap the states of the object <code>objc</code> and the object <code>objd</code>.</p>
<blockquote class="doxtable">
<p>&zwj;[!NOTE] The swapped objects shall use the same allocator. </p>
</blockquote>
<ul>
<li><code>RESET(obj)</code>: Reset the object to its initialized state (Emptying the object if it is a container object).</li>
<li><code>EMPTY_P(obj)</code> --&gt; <code>bool</code>: Test if the container object is empty (true) or not.</li>
<li><code>GET_SIZE (container)</code> --&gt; <code>size_t</code>: Return the number of elements in the container object.</li>
<li><code>HASH (obj)</code> --&gt; <code>size_t</code>: return a hash of the object (not a secure hash but one that is usable for a hash table). Default is performing a hash of the memory representation of the object. This default implementation is invalid if the object holds pointer to other objects or has spare fields.</li>
<li><code>EQUAL(obj1, obj2)</code> --&gt; <code>bool</code>: Compare the two objects for equality. Return true if both objects are equal, false otherwise. Default is using the C comparison operator. 'obj1' may be an OOR object (Out of Representation) for the Open Addressing dictionary (see <code>OOR_*</code> operators): in such cases, it shall return false.</li>
<li><code>CMP(obj1, obj2)</code> --&gt; <code>int</code>: Provide a complete order the objects. return a negative integer if <code>obj1 &lt; obj2</code>, 0 if <code>obj1 = obj2</code>, a positive integer otherwise. Default is C comparison operator.</li>
</ul>
<blockquote class="doxtable">
<p>&zwj;[!NOTE] The equivalence between <code>EQUAL(a, b)</code> and <code>CMP(a, b) == 0</code> is not required, but is usually welcome. </p>
</blockquote>
<ul>
<li><code>ADD(obj1, obj2, obj3)</code>: Set obj1 to the sum of obj2 and obj3. Default is <code>+</code> C operator. It may raise asynchronous error.</li>
<li><code>SUB(obj1, obj2, obj3)</code>: Set obj1 to the difference of obj2 and obj3. Default is <code>-</code> C operator. It may raise asynchronous error.</li>
<li><code>MUL(obj1, obj2, obj3)</code>: Set obj1 to the product of obj2 and obj3. Default is <code>*</code> C operator. It may raise asynchronous error.</li>
<li><code>DIV(obj1, obj2, obj3)</code>: Set obj1 to the division of obj2 and obj3. Default is <code>/</code> C operator. It may raise asynchronous error.</li>
<li><code>GET_KEY (container, key)</code> --&gt; <code>&amp;value</code>: Return a pointer to the value object within the container associated to the key <code>key</code> if an object is associated to this key. Otherwise it may return NULL or terminate the program with a logic error (depending on the container). The pointer to the value object remains valid until any modification of the container.</li>
<li><code>SET_KEY (container, key, value)</code>: Associate the key object <code>key</code> to the value object <code>value</code> in the given container. It may raise asynchronous error.</li>
<li><code>SAFE_GET_KEY (container, key)</code> --&gt; <code>&amp;value</code>: return a pointer to the value object within the container associated to the key <code>key</code> if it exists, or create a new entry in the container and associate it to the key <code>key</code> with the default initialization before returning its pointer. The pointer to the object remains valid until any modification of the container. The returned pointer is therefore never NULL. It may raise asynchronous error.</li>
<li><code>ERASE_KEY (container, key)</code> --&gt; <code>bool</code>: Erase the object associated to the key <code>key</code> within the container. Return true if successful, false if the key is not found (nothing is done).</li>
<li><code>PUSH(container, obj)</code>: Push <code>obj</code> (of type <code>SUBTYPE()</code>) into the container <code>container</code>. How and where it is pushed is container dependent. It may raise asynchronous error.</li>
<li><code>POP(&amp;obj, container)</code>: Pop an object from the container <code>container</code> and set it in the initialized object <code>*obj</code> (of type <code>SUBTYPE()</code>) if the pointer <code>obj</code> is not NULL. Which object is popped is container dependent. It may raise asynchronous error.</li>
<li><code>PUSH_MOVE(container, &amp;obj)</code>: Push and move the object <code>*obj</code> (of type <code>SUBTYPE()</code>) into the container <code>container</code> (<code>*obj</code> destructor). How it is pushed is container dependent. <code>*obj</code> is cleared afterward and shall not be used anymore. See <code>INIT_MOVE</code> for more details and constraints. It may raise asynchronous error.</li>
<li><code>POP_MOVE(&amp;obj, container)</code>: Pop an object from the container <code>container</code> and <b>init &amp; move</b> it in the uninitialized object <code>*obj</code> (aka constructor). Which object is popped is container dependent. <code>*obj</code> shall be uninitialized. See <code>INIT_MOVE</code> for more details and constraints.</li>
</ul>
<blockquote class="doxtable">
<p>&zwj;[!NOTE] When using a <code>POP</code> operator (or any derived operator) on a container, this container shall have at least one object. </p>
</blockquote>
<p>The iterator operators are:</p>
<ul>
<li><code>IT_TYPE()</code> --&gt; <code>type</code>: Return the type of the iterator object of this container.</li>
<li><code>IT_FIRST(it_obj, obj)</code>: Set the iterator it_obj to the first sub-element of the container <code>obj</code>. What is the first element is container dependent (it may be front or back, or something else). However, iterating from FIRST to LAST (included) or END (excluded) through <code>IT_NEXT</code> ensures going through all elements of the container. If there is no sub-element in the container, it references an end of the container.</li>
<li><code>IT_LAST(it_obj, obj)</code>: Set the iterator it_obj to the last sub-element of the container <code>obj</code>. What is the last element is container dependent (it may be front or back, or something else). However, iterating from LAST to FIRST (included) or END (excluded) through <code>IT_PREVIOUS</code> ensures going through all elements of the container. If there is no sub-element in the container, it references an end of the container.</li>
<li><code>IT_END(it_obj, obj)</code>: Set the iterator it_obj to an end of the container <code>obj</code>. Once an iterator has reached an end, it can't use PREVIOUS or NEXT operators. If an iterator has reached an END, it means that there is no object referenced by the iterator (kind of NULL pointer). There can be multiple representation of the end of a container, but all of then share the same properties.</li>
<li><code>IT_SET(it_obj, it_obj2)</code>: Set the iterator it_obj to reference the same sub-element as it_obj2.</li>
<li><code>IT_END_P(it_obj)</code> --&gt; <code>bool</code>: Return true if the iterator it_obj references an end of the container, false otherwise.</li>
<li><code>IT_LAST_P(it_obj)</code> --&gt; <code>bool</code>: Return true if the iterator it_obj references the last element of the container (just before reaching an end) or has reached an end of the container, false otherwise.</li>
<li><code>IT_EQUAL_P(it_obj, it_obj2)</code> --&gt; <code>bool</code>: Return true if both iterators reference the same element, false otherwise.</li>
<li><code>IT_NEXT(it_obj)</code>: Move the iterator to the next sub-element or an end of the container if there is no more sub-element. The direction of <code>IT_NEXT</code> is container dependent. it_obj shall not be an end of the container.</li>
<li><code>IT_PREVIOUS(it_obj)</code>: Move the iterator to the previous sub-element or an end of the container if there is no more sub-element. The direction of PREVIOUS is container dependent, but it is the reverse of the <code>IT_NEXT</code> operator. it_obj shall not be an end of the container.</li>
<li><code>IT_CREF(it_obj)</code> --&gt; <code>&amp;subobj</code>: Return a constant pointer to the object referenced by the iterator (of type <code>const SUBTYPE()</code>). This pointer remains valid until any modifying operation on the container, or until another reference is taken from this container through an iterator (some containers may reduce theses constraints, for example a list). The iterator shall not be an end of the container.</li>
<li><code>IT_REF(it_obj)</code> --&gt; <code>&amp;subobj</code>: Same as <code>IT_CREF</code>, but return a modifiable pointer to the object referenced by the iterator.</li>
<li><code>IT_INSERT(obj, it_obj, subobj)</code>: Insert <code>subobj</code> after 'it_obj' in the container <code>obj</code> and update it_obj to point to the inserted object (as per <code>IT_NEXT</code> semantics). All other iterators of the same container become invalidated. If 'it_obj' is an end of the container, it inserts the object as the first one.</li>
<li><code>IT_REMOVE(obj, it_obj)</code>: Remove it_obj from the container <code>obj</code> (clearing the associated object) and update it_obj to point to the next object (as per <code>IT_NEXT</code> semantics). As it modifies the container, all other iterators of the same container become invalidated. it_obj shall not be an end of the container.</li>
<li><code>SPLICE_BACK(objd, objs, it_obj)</code>: Move the object of the container <code>objs</code> referenced by the iterator 'it_obj' to the container <code>objd</code>. Where it is moved is container dependent (it is recommended however to be like the <code>PUSH</code> method). Afterward 'it_obj' references the next item in 'containerSrc' (as per <code>IT_NEXT</code> semantics). 'it_obj' shall not be an end of the container. Both objects shall use the same allocator. It may raise asynchronous error.</li>
<li><code>SPLICE_AT(objd, id_objd, objs, it_objs)</code>: Move the object referenced by the iterator <code>it_objs</code> from the container <code>objs</code> just after the object referenced by the iterator <code>it_objd</code> in the container <code>objd</code>. If <code>it_objd</code> references an end of the container, it is inserted as the first item of the container (See operator <code>IT_INSERT</code>). Afterward <code>it_objs</code> references the next item in the container <code>objs</code>, and <code>it_objd</code> references the moved item in the container <code>objd</code>. <code>it_objs</code> shall not be an end of the container. Both objects shall use the same allocator. It may raise asynchronous error.</li>
</ul>
<blockquote class="doxtable">
<p>&zwj;[!NOTE] An iterator doesn't have a constructor nor destructor methods. Therefore, it cannot not allocate any memory. </p>
</blockquote>
<blockquote class="doxtable">
<p>&zwj;[!NOTE] A reference to an object through the pointer get from the iterator is only valid until another reference is taken from the same container (potentially through another iterator), or the iterator is modified or the container itself is modified. This reference is therefore extremely local and should not be stored anywhere else. Some containers may lessen this constraint (for example list or RB-Tree). </p>
</blockquote>
<blockquote class="doxtable">
<p>&zwj;[!NOTE] If the container is <em>modified</em>, all iterators of this container become invalid and shall not be used anymore except if the modifying operator provided itself an updated iterator. Some containers may lessen this constraint. </p>
</blockquote>
<p>The I/O operators are:</p>
<ul>
<li><code>OUT_STR(FILE* f, obj)</code>: Output <code>obj</code> as a custom formatted string into the <code>FILE*</code> stream <code>f</code>. Format is container dependent, but is human readable.</li>
<li><code>IN_STR(obj, FILE* f)</code> --&gt; <code>bool</code>: Set <code>obj</code> to the value associated to the formatted string representation of the object in the <code>FILE*</code> stream <code>f</code>. Return true in case of success (in that case the stream <code>f</code> has been advanced to the end of the parsing of the object), false otherwise (in that case, the stream <code>f</code> is in an undetermined position but is likely where the parsing fails). It ensures that an object which is output in a FILE through <code>OUT_STR</code>, and an object which is read from this FILE through <code>IN_STR</code> are considered as equal. It may raise asynchronous error.</li>
<li><code>GET_STR(string_t str, obj, bool append)</code>: Set <code>str</code> to a formatted string representation of the object <code>obj</code>. Append to the string if <code>append</code> is true, set it otherwise. This operator requires the module m-string. It may raise asynchronous error.</li>
<li><code>PARSE_STR(obj, const char *str, const char **endp)</code> --&gt; <code>bool</code>: Set <code>obj</code> to the value associated to the formatted string representation of the object in the char stream <code>str</code>. Return true in case of success (in that case if endp is not NULL, it points to the end of the parsing of the object), false otherwise (in that case, if endp is not NULL, it points to an undetermined position but likely to be where the parsing fails). It ensures that an object which is written in a string through GET_STR, and an object which is read from this string through <code>PARSE_STR</code> are considered as equal. It may raise asynchronous error.</li>
<li><code>OUT_SERIAL(m_serial_write_t *serial, obj)</code> --&gt; <code>m_serial_return_code_t</code>: Output <code>obj</code> into the configurable serialization stream <code>serial</code> (See m-serial-json.h for details and example) as per the serial object semantics. Return <code>M_SERIAL_OK_DONE</code> in case of success, or <code>M_SERIAL_FAIL</code> otherwise. It may raise asynchronous error.</li>
<li><code>IN_SERIAL(obj, m_serial_read_t *serial)</code> --&gt; <code>m_serial_return_code_t</code>: Set <code>obj</code> to its representation from the configurable serialization stream <code>serial</code> (See m-serial-json.h for details and example) as per the serial object semantics. <code>M_SERIAL_OK_DONE</code> in case of success (in that case the stream <code>serial</code> has been advanced up to the complete parsing of the object), or <code>M_SERIAL_FAIL</code> otherwise (in that case, the stream <code>serial</code> is in an undetermined position but usually around the next characters after the first failure). It may raise asynchronous error.</li>
</ul>
<p>The final operators are:</p>
<ul>
<li><code>OOR_SET(obj, int_value)</code>: Some containers want to store some information within the uninitialized objects (for example Open Addressing Hash Table). This method stores the integer value 'int_value' into an uninitialized object <code>obj</code>. It shall be able to differentiate between uninitialized object and initialized object (How is type dependent). The way to store this information is fully object dependent. In general, you use out-of-range value for detecting such values. The object remains uninitialized but sets to of out-of-range value (OOR). int_value can be 0 or 1.</li>
<li><code>OOR_EQUAL(obj, int_value)</code>: This method compares the object <code>obj</code> (initialized or uninitialized) to the out-of-range value (OOR) representation associated to 'int_value' and returns true if both objects are equal, false otherwise. See <code>OOR_SET</code>.</li>
<li><code>REVERSE(obj)</code>: Reverse the order of the items in the container <code>obj</code>. It may raise asynchronous error.</li>
<li><code>SEPARATOR()</code> --&gt; <code>character</code>: Return the character used to separate items for I/O methods (default is ',') (for internal use only).</li>
<li><code>EXT_ALGO(name, container oplist, object oplist)</code>: Define additional algorithms functions specialized for the containers (for internal use only).</li>
<li><code>PROPERTIES()</code> --&gt; <code>( properties)</code>: Return internal properties of a container in a recursive oplist format. Use M_GET_PROPERTY to get the property.</li>
<li><code>EMPLACE_TYPE( ... )</code>: Specify the types usable for "emplacing" the object (initializing the object in-place, constructor). See chapter Emplace construction. THe referenced initializing functions may raise asynchronous error.</li>
</ul>
<blockquote class="doxtable">
<p>&zwj;[!NOTE] The operator names listed above shall not be defined as macro. </p>
</blockquote>
<p>More operators are expected.</p>
<h2><a class="anchor" id="autotoc_md21"></a>
Properties</h2>
<p>Properties can be stored in a sub-oplist format in the <code>PROPERTIES</code> operator.</p>
<p>The following properties are defined:</p>
<ul>
<li><code>LET_AS_INIT_WITH(1)</code>  Defined if the macro <code>M_LET</code> shall always initialize the object with <code>INIT_WITH</code> regardless of the given input. The value of the property is 1 (enabled) or 0 (disabled/default).</li>
<li><code>NOCLEAR(1)</code>  Defined if the object <code>CLEAR</code> operator can be omitted (like for basic types or POD data). The value of the property is 1 (enabled) or 0 (disabled/default).</li>
</ul>
<blockquote class="doxtable">
<p>&zwj;[!NOTE] The properties names listed above shall not be defined as macro. </p>
</blockquote>
<p>More properties are expected.</p>
<h2><a class="anchor" id="autotoc_md22"></a>
Example:</h2>
<p>Let's take the interface of the MPZ library:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> mpz_init(mpz_t z);                    <span class="comment">// Constructor of the object z</span></div>
<div class="line"><span class="keywordtype">void</span> mpz_init_set(mpz_t z, <span class="keyword">const</span> mpz_t s); <span class="comment">// Copy Constructor of the object z</span></div>
<div class="line"><span class="keywordtype">void</span> mpz_set(mpz_t z, <span class="keyword">const</span> mpz_t s);      <span class="comment">// Copy operator of the object z</span></div>
<div class="line"><span class="keywordtype">void</span> mpz_clear(mpz_t z);                   <span class="comment">// Destructor of the object z</span></div>
</div><!-- fragment --><p>A basic oplist will be:</p>
<div class="fragment"><div class="line">(INIT(mpz_init),SET(mpz_set),INIT_SET(mpz_init_set),CLEAR(mpz_clear),TYPE(mpz_t))</div>
</div><!-- fragment --><p>Much more complete oplist can be built for this type however, enabling much more powerful generation: See in the <a href="https://github.com/P-p-H-d/mlib/blob/master/example/ex11-multi02.c">example</a></p>
<h2><a class="anchor" id="autotoc_md23"></a>
Global namespace</h2>
<p>Oplist can be registered globally by defining, for the type <code>type</code>, a macro named <code>M_OPL_ ## type ()</code> that expands to the oplist of the type. Only type without any space in their name can be registered. A typedef of the type can be used instead, but this typedef shall be used everywhere.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define M_OPL_mpz_t() (INIT(mpz_init),SET(mpz_set),          \</span></div>
<div class="line"><span class="preprocessor">        INIT_SET(mpz_init_set),CLEAR(mpz_clear),TYPE(mpz_t))</span></div>
</div><!-- fragment --><p>This can simplify a lot <code>OPLIST</code> usage and it is recommended.</p>
<p>Then each times a macro expects an oplist, you can give instead its type. This make the code much easier to read and understand.</p>
<p>There is one exception however: the macros that are used to build oplist (like <code>ARRAY_OPLIST</code>) don't perform this simplification and the oplist of the basic type shall be given instead (This is due to limitation in the C preprocessing).</p>
<h2><a class="anchor" id="autotoc_md24"></a>
API Interface Adaptation</h2>
<p>Within an <code>OPLIST</code>, you can also specify the needed low-level transformation to perform for calling your method. This is called API Interface Adaptation: it enables to transform the API requirements of the selected operator (which is very basic in general) to the API provided by the given method. Assuming that the method to call is called 'method' and the first argument of the operator is 'output', which interface is <code>OPERATOR(output, ...)</code> then the following predefined adaptation are available:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">API   </th><th class="markdownTableHeadLeft">Method   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>API_0</b>   </td><td class="markdownTableBodyLeft"><code>method(output, ...)</code>   </td><td class="markdownTableBodyLeft">No adaptation    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>API_1</b>   </td><td class="markdownTableBodyLeft"><code>method(oplist, output, ...)</code>   </td><td class="markdownTableBodyLeft">No adaptation but gives the oplist to the method    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>API_2</b>   </td><td class="markdownTableBodyLeft"><code>method(&amp;output, ...)</code>   </td><td class="markdownTableBodyLeft">Pass by address the first argument (like with <code>M_IPTR</code>)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>API_3</b>   </td><td class="markdownTableBodyLeft"><code>method(oplist, &amp;output, ...)</code>   </td><td class="markdownTableBodyLeft">Pass by address the first argument (like with <code>M_IPTR</code>) and give the oplist of the type    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>API_4</b>   </td><td class="markdownTableBodyLeft"><code>output = method(...)</code>   </td><td class="markdownTableBodyLeft">Pass by return value the first argument    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>API_5</b>   </td><td class="markdownTableBodyLeft"><code>output = method(oplist, ...)</code>   </td><td class="markdownTableBodyLeft">Pass by return value the first argument and give the oplist of the type    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>API_6</b>   </td><td class="markdownTableBodyLeft"><code>method(&amp;output, &amp;...)</code>   </td><td class="markdownTableBodyLeft">Pass by address the two first arguments    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>API_7</b>   </td><td class="markdownTableBodyLeft"><code>method(oplist, &amp;output, &amp;...)</code>   </td><td class="markdownTableBodyLeft">Pass by address the two first argument and give the oplist of the type   </td></tr>
</table>
<p>The API Adaptation to use shall be embedded in the <code>OPLIST</code> definition. For example:</p>
<div class="fragment"><div class="line">(INIT(API_0(mpz_init)), SET(API_0(mpz_set)), INIT_SET(API_0(mpz_init_set)), CLEAR(API_0(mpz_clear)))</div>
</div><!-- fragment --><p>The default adaptation is API_0 (i.e. no adaptation between operator interface and method interface). If an adaptation gives an oplist to the method, the method shall be implemented as macro.</p>
<p>Let's take the interface of a pseudo library:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{ ... } obj_t;</div>
<div class="line">obj_t *obj_init(<span class="keywordtype">void</span>);                <span class="comment">// Constructor of the object z</span></div>
<div class="line">obj_t *obj_init_str(<span class="keyword">const</span> <span class="keywordtype">char</span> *str); <span class="comment">// Constructor of the object z</span></div>
<div class="line">obj_t *obj_clone(<span class="keyword">const</span> obj_t *s);     <span class="comment">// Copy Constructor of the object z</span></div>
<div class="line"><span class="keywordtype">void</span> obj_clear(obj_t *z);             <span class="comment">// Destructor of the object z</span></div>
</div><!-- fragment --><p>The library returns a pointer to the object, so we need API_4 for these methods. There is no method for the <code>SET</code> operator available. However, we can use the macro <code>M_SET_THROUGH_INIT_SET</code> to emulate a SET semantics by using a combination of <code>CLEAR</code> + <code>INIT_SET</code>. This enables to support the type for array containers in particular. Or we can avoid this definition if we don't need it. A basic oplist will be:</p>
<div class="fragment"><div class="line">(INIT(API_4(obj_init)),SET(API_1(M_SET_THROUGH_INIT_SET)),INIT_SET(API_4(obj_clone)),CLEAR(obj_clear),TYPE(obj_t *))</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md25"></a>
Generic API Interface Adaptation</h2>
<p>You can also describe the exact transformation to perform for calling the method: this is called Generic API Interface Adaptation (or GAIA). With this, you can add constant values to parameter of the method, reorder the parameters as you wish, pass then by pointers, or even change the return value.</p>
<p>The API adaptation is also described in the operator mapping with the method name by using the API keyword. Usage in oplist:</p>
<div class="fragment"><div class="line">, OPERATOR( API( method, returncode, args...) ) ,</div>
</div><!-- fragment --><p>Within the <code>API</code> keyword,</p>
<ul>
<li>method is the pure method name (as like any other oplist)</li>
<li><code>returncode</code> is the transformation to perform of the return code.</li>
<li>args are the list of the arguments of the function. It can be:</li>
</ul>
<p><code>returncode</code> can be</p>
<ul>
<li><code>NONE</code>  no transformation,</li>
<li><code>VOID</code>  cast to void,</li>
<li><code>NEG</code>  inverse the result,</li>
<li><code>EQ(val)</code>/<code>NEQ(val)</code>/<code>LT(val</code>)/<code>GT(val)</code>/<code>LE(val)</code>/<code>GE(val)</code>  compare the return code to the given value</li>
<li><code>ARG[1-9]</code>  set the associated argument number of the operator to the return code</li>
</ul>
<p>An argument can be:</p>
<ul>
<li>a constant,</li>
<li>a variable name  probably global,</li>
<li><code>ID( constant or variable)</code>  if the constant or variable is not a valid token,</li>
<li><code>ARG[1-9]</code>  the associated argument number of the operator,</li>
<li><code>ARGPTR[1-9]</code>  the pointer of the associated argument number of the operator,</li>
<li><code>OPLIST</code>  the oplist</li>
</ul>
<p>Therefore, it supports at most 9 arguments.</p>
<p>Example:</p>
<div class="fragment"><div class="line">, EQUAL( API(mpz_cmp, EQ(0), ARG1, ARG2) ) , </div>
</div><!-- fragment --><p>This will transform a return value of 0 by the mpz_cmp method into a boolean for the <code>EQUAL</code> operator.</p>
<p>Another Example:</p>
<div class="fragment"><div class="line">, OUT_STR( API(mpz_out_str, VOID, ARG1, 10, ARG2) ) , </div>
</div><!-- fragment --><p>This will serialize the mpz_t value in base 10 using the mpz_out_str method, and discarding the return value.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
Disable an operator</h2>
<p>An operator <code>OP</code> can be defined, omitted or disabled:</p>
<ul>
<li><code>( OP(f) )</code>: the function f is the method of the operator OP</li>
<li><code>( OP(API_N(f)) )</code>: the function f is the method of the operator OP with the API transformation number N,</li>
<li><code>( )</code>: the operator OP is omitted, and the default global operation for OP is used (if it exists).</li>
<li><code>( OP(0) )</code>: the operator OP is disabled, and it can never be used.</li>
</ul>
<p>This can be useful to disable an operator in an inherited oplist.</p>
<h2><a class="anchor" id="autotoc_md27"></a>
Which &lt;tt&gt;OPLIST&lt;/tt&gt; to use?</h2>
<p>My type is:</p>
<ul>
<li>a C Boolean: <code>M_BOOL_OPLIST</code> (<code>M_BASIC_OPLIST</code> also works partially),</li>
<li>a C integer or a C float: <code>M_BASIC_OPLIST</code> (it can also be omitted),</li>
<li>a C enumerate: <code>M_ENUM_OPLIST</code>,</li>
<li>a pointer to something (the container do nothing on the pointed object): <code>M_PTR_OPLIST</code>,</li>
<li>a plain structure that can be init/copy/compare with memset/memcpy/memcmp: <code>M_POD_OPLIST</code>,</li>
<li>a plain structure that is passed by reference using [1] and can be init,copy,compare with <code>memset</code>, <code>memcpy</code>, <code>memcmp</code>: <code>M_A1_OPLIST</code>,</li>
<li>a type that offers <code>name_init</code>, <code>name_init_set</code>, <code>name_set</code>, <code>name_clear</code> methods: <code>M_CLASSIC_OPLIST</code>,</li>
<li>a const string (<code>const char *</code>) that is neither freed nor moved: <code>M_CSTR_OPLIST</code>,</li>
<li>a M*LIB string_t: <code>STRING_OPLIST</code>,</li>
<li>a M*LIB container: the <code>OPLIST</code> of the used container,</li>
<li>other things: you need to provide a custom <code>OPLIST</code> to your type.</li>
</ul>
<blockquote class="doxtable">
<p>&zwj;[!NOTE] The precise exported methods of the OPLIST depend on the version of the used C language. Typically, in C11 mode, the <code>M_BASIC_OPLIST</code> exports all needed methods to handle generic input/output of int/floats (using <code>_Generic</code> keyword) whereas it is not possible in C99 mode. </p>
</blockquote>
<p>This explains why JSON import/export is only available in C11 mode (See below chapter).</p>
<p>Basic usage of oplist is available in the <a href="https://github.com/P-p-H-d/mlib/blob/master/example/ex-array00.c">example</a></p>
<h2><a class="anchor" id="autotoc_md28"></a>
Oplist inheritance</h2>
<p>Oplist can inherit from another one. This is useful when you want to customize some specific operators while keeping other ones by default. For example, internally <code>M_BOOL_OPLIST</code> inherits from <code>M_BASIC_OPLIST</code>.</p>
<p>A typical example is if you want to provide the <code>OOR_SET</code> and <code>OOR_EQUAL</code> operators to a type so that it can be used in an <code>OA</code> dict. To do it, you use the <code>M_OPEXTEND</code> macro. It takes as first argument the oplist you want to inherit with, and then you provide the additional associations between operators to methods you want to add or override in the inherited oplist. For example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> my_int_oor_set(<span class="keywordtype">char</span> c) { <span class="keywordflow">return</span> INT_MIN + c; }</div>
<div class="line"><span class="keywordtype">bool</span> my_int_oor_equal(<span class="keywordtype">int</span> i1, <span class="keywordtype">int</span> i2) { <span class="keywordflow">return</span> i1 == i2; }</div>
<div class="line"><span class="preprocessor">#define MY_INT_OPLIST                                              \</span></div>
<div class="line"><span class="preprocessor">        M_OPEXTEND(M_BASIC_OPLIST, OOR_SET(API_4(my_int_oor_set)), \</span></div>
<div class="line"><span class="preprocessor">            OOR_EQUAL(my_int_oor_equal))</span></div>
</div><!-- fragment --><p>You can even inherit from another oplist to disable some operators in your new oplist. For example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define MY_INT_OPLIST                                              \</span></div>
<div class="line"><span class="preprocessor">        M_OPEXTEND(M_BASIC_OPLIST, HASH(0), CMP(0), EQUAL(0))</span></div>
</div><!-- fragment --><p><code>MY_INT_OPLIST</code> is a new oplist that handles integers but has disabled the operators <code>HASH</code>, <code>CMP</code> and <code>EQUAL</code>. The main interest is to disable the generation of optional methods of a container (since they are only expanded if the oplist provides some methods).</p>
<p>Usage of inheritance and oplist is available in the <a href="https://github.com/P-p-H-d/mlib/blob/master/example/ex-dict05.c">int example</a> and the <a href="https://github.com/P-p-H-d/mlib/blob/master/example/ex-dict06.c">cstr example</a></p>
<h2><a class="anchor" id="autotoc_md29"></a>
Advanced example</h2>
<p>Let's take a look at the interface of the <code>FILE*</code> interface:</p>
<div class="fragment"><div class="line">FILE *fopen(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename, <span class="keyword">const</span> <span class="keywordtype">char</span> *mode);</div>
<div class="line">fclose(FILE *f);</div>
</div><!-- fragment --><p>There is no <code>INIT</code> operator (an argument is mandatory), no <code>INIT_SET</code> operator. It is only possible to open a file from a filename. <code>FILE*</code> contains some space, so an alias is needed. There is an optional mode argument, which is a constant string, and isn't a valid preprocessing token. An oplist can therefore be:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> FILE *m_file_t;</div>
<div class="line"><span class="preprocessor">#define M_OPL_m_file_t() (INIT_WITH(API(fopen, ARG1, ARG2, ID(&quot;wt&quot;))), \</span></div>
<div class="line"><span class="preprocessor">        SET(0),INIT_SET(0),CLEAR(fclose),TYPE(m_file_t))</span></div>
</div><!-- fragment --><p>Since there is no <code>INIT_SET</code> operator available, pretty much no container can work. However, you'll be able to use a writing text <code>FILE*</code> using a <code>M_LET</code>:</p>
<div class="fragment"><div class="line">M_LET( (f, (<span class="stringliteral">&quot;tmp.txt&quot;</span>)), m_file_t) {</div>
<div class="line">  fprintf(f, <span class="stringliteral">&quot;This is a tmp file.&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>This is pretty useless, except if you enable exceptions... In which case, this enables you to close the file even if an exception is thrown.</p>
<h1><a class="anchor" id="autotoc_md30"></a>
Memory Allocation</h1>
<h2><a class="anchor" id="autotoc_md31"></a>
Customization</h2>
<p>Memory Allocation functions can be globally set by overriding the following macros before using the definition <code>_DEF</code> macros:</p>
<ul>
<li><code>M_MEMORY_ALLOC (type)</code> --&gt; <code>ptr</code>: return a pointer to a new object of type <code>type</code>.</li>
<li><code>M_MEMORY_DEL (ptr)</code>: free the single object pointed by <code>ptr</code>.</li>
<li><code>M_MEMORY_REALLOC (type, ptr, number)</code> --&gt; <code>ptr</code>: return a pointer to an array of 'number' objects of type <code>type</code>, reusing the old array pointed by <code>ptr</code>. <code>ptr</code> can be NULL, in which case the array will be created.</li>
<li><code>M_MEMORY_FREE (ptr)</code>: free the array of objects pointed by <code>ptr</code>.</li>
</ul>
<p><code>ALLOC</code> and <code>DEL</code> operators are supposed to allocate fixed size single element object (no array). These objects are not expected to grow. <code>REALLOC</code> and <code>FREE</code> operators deal with allocated memory for growing objects. Do not mix pointers between both: a pointer allocated by <code>ALLOC</code> (resp. <code>REALLOC</code>) is supposed to be only freed by <code>DEL</code> (resp. <code>FREE</code>). There are separated 'free' operators to enable specialization in the allocator (a good allocator can take this hint into account).</p>
<p><code>M_MEMORY_ALLOC</code> and <code>M_MEMORY_REALLOC</code> are supposed to return NULL in case of memory allocation failure. The defaults are <code>malloc</code>, <code>free</code>, <code>realloc</code> and <code>free</code>.</p>
<p>You can also override the methods <code>NEW</code>, <code>DEL</code>, <code>REALLOC</code> and <code>DEL</code> in the oplist given to a container so that only the container will use these memory allocation functions instead of the global ones.</p>
<h2><a class="anchor" id="autotoc_md32"></a>
Out-of-memory error</h2>
<p>When a memory exhaustion is reached, the global macro <code>M_MEMORY_FULL</code> is called and the function returns immediately after. The object remains in a valid (if previously valid) and unchanged state in this case.</p>
<p>By default, the macro prints an error message and aborts the program: handling non-trivial memory errors can be hard, testing them is even harder but still mandatory to avoid security holes. So the default behavior is rather conservative.</p>
<p>It can however be overloaded to handle other policy for error handling like:</p>
<ul>
<li>throwing an error (which is automatically done by including header m-try ),</li>
<li>set a global error and handle it when the function returns [planned, not possible yet],</li>
<li>other policy.</li>
</ul>
<p>This function takes the size in bytes of the memory that has been tried to be allocated.</p>
<p>If needed, this macro shall be defined <em><b>prior</b></em> to instantiate the structure.</p>
<blockquote class="doxtable">
<p>&zwj;[!NOTE] A good design should handle a process entire failure (using for examples multiple processes for doing the job) so that even if a process stops, it should be recovered. See <a href="http://joeduffyblog.com/2016/02/07/the-error-model/">here</a> for more information about why abandonment is good software practice. </p>
</blockquote>
<p>In M*LIB, we classify the kind of errors according to this classification:</p><ul>
<li><em>logical error</em>: the expectations of the function are not met (null pointer passed as argument, negative argument, invalid object state, ...). In which case, the sanction is abnormal halt of the program, if it is detected, regardless of the configuration of M*LIB. Normally, debug build will detect such errors.</li>
<li><em>abnormal error</em>: errors that are unlikely to be expected during the execution of the program (like no more memory). In which case, the sanction is either abnormal halt of the program or throwing an exception.</li>
<li><em>normal error</em>: errors that can be expected in the execution of the program (all I/O errors like file not found or invalid file format, parsing of invalid user input, no solution found, etc). In which case, the error is reported by the return code of the function or by polling for error (See <code>ferror</code>) in the data structure.</li>
</ul>
<h1><a class="anchor" id="autotoc_md33"></a>
Emplace construction</h1>
<p>For M*LIB, 'emplace' means pushing a new object in the container, while not giving it a copy of the new object, but the parameters needed to construct this object. This is a shortcut to the pattern of creating the object with the arguments, pushing it in the container, and deleting the created object (even if using <code>PUSH_MOVE</code> could simplify the design).</p>
<p>The containers defining an emplace like method generate the emplace functions based on the provided <code>EMPLACE_TYPE</code> of the oplist. If <code>EMPLACE_TYPE</code> doesn't exist or is disabled, no emplace function is generated. Otherwise <code>EMPLACE_TYPE</code> identifies which types can be used to construct the object and which methods to use to construct then:</p>
<ul>
<li><code>EMPLACE_TYPE( typeA )</code>, means that the object can be constructed from <code>typeA</code> using the method of the <code>INIT_WITH</code> operator. An emplace function without suffix will be generated.</li>
<li><code>EMPLACE_TYPE( (typeA, typeB, ...) )</code>, means that the object can be constructed from the lists of types <code>typeA</code>, <code>typeB</code>, <code>...</code> using the method of the <code>INIT_WITH</code> operator. An emplace function without suffix will be generated.</li>
<li><code>EMPLACE_TYPE( LIST( (suffix, function, typeA, typeB, ...)</code>, (<code>suffix</code>, <code>function</code>, <code>typeA</code>, <code>typeB</code>, <code>...</code>) means that the object can be constructed from all the provided lists of types <code>typeA</code>, <code>typeB</code>, <code>...</code> using the provided method <code>function</code>. The <code>function</code> is the method to call to construct the object from the list of types. It supports API transformation if needed. As many emplace function will be generated as there are constructor function. Each generated function will be generated by suffixing it with the provided <code>suffix</code> (if suffix is empty, no suffix will be added).</li>
</ul>
<p>For example, for an <code>ARRAY</code> definition named vec, if there is such a definition of <code>EMPLACE_TYPE(const char *)</code>, it will generate a function <code>vec_emplace_back(const char *)</code>. This function will take a <code>const char*</code> parameter, construct the object from it (for example a string_t) then push the result back on the array.</p>
<p>Another example, for an <code>ARRAY</code> definition named vec, if there is such a definition of <code>EMPLACE_TYPE( LIST( (_ui, mpz_init_set_ui, unsigned int), (_si, mpz_init_set_si, int) ) )</code>, it will generate two functions <code>vec_emplace_back_ui(unsigned int)</code> and <code>vec_emplace_back_si(int)</code>. These functions will take the (unsigned) int parameter, construct the object from it then push the result back on the array.</p>
<p>If the container is an associative array, the name will be constructed as follows:</p>
<div class="fragment"><div class="line">name_emplace[_key_keysuffix][_val_valsuffix]</div>
</div><!-- fragment --><p>where <code>keysuffix</code> (resp. <code>valsuffix</code>) is the emplace suffix of the key (resp. <code>value</code>) oplist.</p>
<p>If you take once again the example of the <code>FILE*</code>, a more complete oplist can be:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> FILE *m_file_t;</div>
<div class="line"><span class="preprocessor">#define M_OPL_m_file_t() (INIT_WITH(API_1(M_INIT_WITH_THROUGH_EMPLACE_TYPE)), \</span></div>
<div class="line"><span class="preprocessor">        SET(0),INIT_SET(0),CLEAR(fclose),TYPE(m_file_t),                      \</span></div>
<div class="line"><span class="preprocessor">        EMPLACE_TYPE(LIST((_str, API(fopen, ARG1, ARG2, ID(&quot;wb&quot;)), char *))))</span></div>
</div><!-- fragment --><p>The <code>INIT_WITH</code> operator will use the provided init methods in the <code>EMPLACE_TYPE</code>. <code>EMPLACE_TYPE</code> defines a <code>_str</code> suffix method with a GAIA for <code>fopen</code>, and accepts a <code>char*</code> as argument. The GAIA specifies that the output (ARG1) is set as return value, ARG2 is given as the first argument, and a third constant argument is used.</p>
<h1><a class="anchor" id="autotoc_md34"></a>
ERRORS &amp; COMPILERS</h1>
<p>M*LIB implements internally some controls to reduce the list of errors/warnings generated by a compiler when it detects some violation in the use of oplist by use of static assertion. It can also transform some type warnings into proper errors. In C99 mode, it will produce illegal code with the name of the error as attribute. In C11 mode, it will use static assert and produce a detailed error message.</p>
<p>The list of errors it can generate:</p>
<ul>
<li><code>M_LIB_NOT_AN_OPLIST</code>: something has been given (directly or indirectly) and it doesn't reduce as a proper oplist. You need to give an oplist for this definition.</li>
<li><code>M_LIB_ERROR(ARGUMENT_OF_*_OPLIST_IS_NOT_AN_OPLIST, name, oplist)</code>: sub error of the previous error one, identifying the root cause. The error is in the oplist construction of the given macro. You need to give an oplist for this oplist construction.</li>
<li><code>M_LIB_MISSING_METHOD</code>: a required operator doesn't define any method in the given oplist. You need to complete the oplist with the missing method.</li>
<li><code>M_LIB_TYPE_MISMATCH</code>: the given oplist and the type do not match each other. You need to give the right oplist for this type.</li>
<li><code>M_LIB_NOT_A_BASIC_TYPE</code>: The oplist <code>M_BASIC_OPLIST</code> (directly or indirectly) has been used with the given type, but the given type is not a basic C type (int/float). You need to give the right oplist for this type.</li>
</ul>
<p>You should focus mainly on the first reported error/warning even if the link between what the compiler report and what the error is is not immediate. The error is always in one of the <b>oplist definition</b>.</p>
<p>Examples of typical errors:</p>
<ul>
<li>lack of inclusion of an header,</li>
<li>overriding locally operator names by macros (like <code>NEW</code>, <code>DEL</code>, <code>INIT</code>, <code>OPLIST</code>, <code>...</code>),</li>
<li>lack of <code>( )</code> or double level of <code>( )</code> around the oplist,</li>
<li>an unknown variable (example using <code>BASIC_OPLIST</code> instead of <code>M_BASIC_OPLIST</code>),</li>
<li>the name given to the oplist is not the same as the one used to define the methods,</li>
<li>use of a type instead of an oplist in the <code>OPLIST</code> definition,</li>
<li>a missing sub oplist in the <code>OPLIST</code> definition.</li>
</ul>
<p>A good way to avoid these errors is to register the oplist globally as soon as you define the container.</p>
<p>In case of difficulties, debugging can be done by generating the preprocessed file (by usually calling the compiler with the <code>-E</code> option instead of <code>-c</code>) and check what's wrong in the preprocessed file:</p>
<div class="fragment"><div class="line">cc -std=c99 -E test-file.c |grep -v &#39;^#&#39; &gt; test-file.i</div>
<div class="line">perl -i -e &#39;s/;/;\n/g&#39; test-file.i</div>
<div class="line">cc -std=c99 -c -Wall test-file.i</div>
</div><!-- fragment --><p>If there is a warning reported by the compiler in the generated code, then there is definitely an <b>error</b> you should fix (except if it reports shadowed variables), in particular cast evolving pointers.</p>
<p>You should also turn off the macro expansion of the errors reported by your compiler. There are often completely useless and misleading:</p>
<ul>
<li>For GCC, uses <code>-ftrack-macro-expansion=0</code></li>
<li>For CLANG, uses <code>-fmacro-backtrace-limit=1</code></li>
</ul>
<p>Due to the unfortunate <a href="https://en.wikipedia.org/wiki/Strong_and_weak_typing#Pointers">weak</a> nature of the C language for pointers, you should turn incompatible pointer type warning into an error in your compiler. For GCC / CLANG, uses <code>-Werror=incompatible-pointer-types</code></p>
<p>For MS Visual C++ compiler , you need the following options:</p>
<div class="fragment"><div class="line">/Zc:__cplusplus /Zc:preprocessor /D__STDC_WANT_LIB_EXT1__ /EHsc</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md35"></a>
External Reference</h1>
<p>Many other implementation of generic container libraries in C exist. For example, a non exhaustive list is:</p>
<ul>
<li><a href="https://github.com/bkthomps/Containers">BKTHOMPS/CONTAINERS</a></li>
<li><a href="http://fxr.watson.org/fxr/source/sys/tree.h">BSD tree.h</a></li>
<li><a href="https://github.com/JacksonAllan/CC">CC</a></li>
<li><a href="https://github.com/MichaelJWelsh/cdsa">CDSA</a></li>
<li><a href="http://libcello.org/">CELLO</a></li>
<li><a href="https://github.com/LeoVen/C-Macro-Collections">C-Macro-Collections</a></li>
<li><a href="https://github.com/srdja/Collections-C">COLLECTIONS-C</a></li>
<li><a href="https://github.com/concurrencykit/ck">CONCURRENCY KIT</a></li>
<li>CTL <a href="https://github.com/glouw/ctl">by glouw</a> or <a href="https://github.com/rurban/ctl">by rurban</a></li>
<li><a href="https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;a=blob;f=gdb/common/vec.h;h=41e41b5b22c9f5ec14711aac35ce4ae6bceab1e7;hb=HEAD">GDB internal library</a></li>
<li><a href="https://wiki.gnome.org/Projects/GLib">GLIB</a></li>
<li><a href="https://github.com/attractivechaos/klib">KLIB</a></li>
<li><a href="https://github.com/mgrosvenor/libchaste">LIBCHASTE</a></li>
<li><a href="https://bitbucket.org/manvscode/libcollections">LIBCOLLECTION</a></li>
<li><a href="https://github.com/fmela/libdict">LIBDICT</a></li>
<li><a href="https://github.com/fredrikwidlund/libdynamic">LIBDYNAMIC</a></li>
<li><a href="https://www.liblfds.org/">LIBLFDS</a></li>
<li><a href="https://github.com/faragon/libsrt">LIBSRT: Safe Real-Time library for the C programming language</a></li>
<li><a href="https://github.com/ned14/nedtries">NEDTRIES</a></li>
<li><a href="https://github.com/ludocode/pottery">POTTERY</a></li>
<li><a href="http://wolkykim.github.io/qlibc/">QLIBC</a></li>
<li><a href="https://github.com/tezc/sc">SC</a></li>
<li><a href="http://sglib.sourceforge.net/">SGLIB</a></li>
<li><a href="https://github.com/Snaipe/libcsptr">Smart pointer for GNUC</a></li>
<li><a href="https://github.com/nothings/stb">STB stretchy_buffer</a></li>
<li><a href="https://github.com/tylov/STC">STC - Smart Template Container for C</a></li>
<li><a href="https://github.com/amadvance/tommyds">TommyDS</a></li>
<li><a href="http://troydhanson.github.io/uthash/index.html">UTHASH</a></li>
</ul>
<p>Each can be classified into one of the following concept:</p>
<ul>
<li>Each object is handled through a pointer to void (with potential registered callbacks to handle the contained objects for the specialized methods). From a user point of view, this makes the code harder to use (as you don't have any help from the compiler) and type unsafe with a lot of cast (so no formal proof of the code is possible). This also generally generate slower code (even if using link time optimization, this penalty can be reduced). Properly used, it can yet be the most space efficient for the code, but can consume a lot more for the data due to the obligation of using pointers. This is however the easiest to design &amp; code.</li>
<li>Macros are used to access structures in a generic way (using known fields of a structure  typically size, number, etc.). From a user point of view, this can create subtitle bug in the use of the library (as everything is done through macro expansion in the user defined code) or hard to understand warnings. This can generates fully efficient code. From a library developer point of view, this can be quite limiting in what you can offer.</li>
<li>Macros detect the type of the argument passed as parameter using _Generics, and calls the associated methods of the switch. The difficulty is how to add pure user types in this generic switch.</li>
<li>A known structure is put in an intrusive way in the type of all the objects you wan to handle. From a user point of view, he needs to modify its structure and has to perform all the allocation &amp; deallocation code itself (which is good or bad depending on the context). This can generate efficient code (both in speed and size). From a library developer point of view, this is easy to design &amp; code. You need internally a cast to go from a pointer to the known structure to the pointed object (a reverse of offsetof) that is generally type unsafe (except if mixed with the macro generating concept). This is quite limitation in what you can do: you can't move your objects so any container that has to move some objects is out-of-question (which means that you cannot use the most efficient container).</li>
<li>Header files are included multiple times with different contexts (some different values given to defined macros) in order to generate different code for each type. From a user point of view, this creates a new step before using the container: an instantiating stage that has to be done once per type and per compilation unit (The user is responsible to create only one instance of the container, which can be troublesome if the library doesn't handle proper prefix for its naming convention). The debug of the library is generally easy and can generate fully specialized &amp; efficient code. Incorrectly used, this can generate a lot of code bloat. Properly used, this can even create smaller code than the void pointer variant. The interface used to configure the library can be quite tiresome in case of a lot of specialized methods to configure: it doesn't enable to chain the configuration from a container to another one easily. It also cannot have heavy customization of the code.</li>
<li>Macros are used to generate context-dependent C code enabling to generate code for different type. This is pretty much like the headers solution but with added flexibility. From a user point of view, this creates a new step before using the container: an instantiating stage that has to be done once per type and per compilation unit (The user is responsible to create only one instance of the container, which can be troublesome if the library doesn't handle proper prefix for its naming convention). This can generate fully specialized &amp; efficient code. Incorrectly used, this can generate a lot of code bloat. Properly used, this can even create smaller code than the void pointer variant. From a library developer point of view, the library is harder to design and to debug: everything being expanded in one line, you can't step in the library (there is however a solution to overcome this limitation by adding another stage to the compilation process). You can however see the generated code by looking at the preprocessed file. You can perform heavy context-dependent customization of the code (transforming the macro preprocessing step into its own language). Properly done, you can also chain the methods from a container to another one easily, enabling expansion of the library. Errors within the macro expansion are generally hard to decipher, but errors in code using containers are easy to read and natural.</li>
</ul>
<p>M*LIB category is mainly the last one. Some macros are also defined to access structure in a generic way, but they are optional. There are also intrusive containers.</p>
<p>M*LIB main added value compared to other libraries is its oplist feature enabling it to chain the containers and/or use complex types in containers: list of array of dictionary of C++ objects are perfectly supported by M*LIB.</p>
<p>For the macro-preprocessing part, other libraries and reference also exist. For example:</p>
<ul>
<li><a href="http://www.boost.org/doc/libs/1_63_0/libs/preprocessor/doc/index.html">Boost preprocessor</a></li>
<li><a href="https://github.com/Leushenko/C99-Lambda">C99 Lambda</a></li>
<li><a href="https://github.com/pfultz2/Cloak/wiki/C-Preprocessor-tricks,-tips,-and-idioms">C Preprocessor Tricks, Tips and Idioms</a></li>
<li><a href="http://jhnet.co.uk/articles/cpp_magic">CPP MAGIC</a></li>
<li><a href="https://github.com/swansontec/map-macro">MAP MACRO</a></li>
<li><a href="https://github.com/Hirrolot/metalang99">metalang99</a></li>
<li><a href="https://github.com/rofl0r/order-pp">OrderPP</a></li>
<li><a href="http://p99.gforge.inria.fr/p99-html/">P99</a></li>
<li><a href="https://github.com/pfultz2/ZLang">Zlang</a></li>
</ul>
<p>You can also consult <a href="https://github.com/Hirrolot/awesome-c-preprocessor">awesome-c-preprocessor</a> for a more comprehensive list of libraries.</p>
<p>For the string part, there is the following libraries for example:</p>
<ul>
<li><a href="https://github.com/ludocode/pottery/tree/develop/util/pottery/string">POTTERY STRING</a></li>
<li><a href="https://github.com/antirez/sds">SDS</a></li>
<li><a href="https://github.com/tylov/C99Containers">STC - C99 Standard Container library</a></li>
<li><a href="https://github.com/maxim2266/str">STR -yet another string library for C language</a></li>
<li><a href="http://bstring.sourceforge.net/">The Better String Library</a> with a page that lists a lot of other string libraries.</li>
<li><a href="http://www.and.org/vstr/">VSTR</a> with a <a href="http://www.and.org/vstr/comparison">page</a> that lists a lot of other string libraries.</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md36"></a>
API Documentation</h1>
<p>The M*LIB reference card is available <a href="http://htmlpreview.github.io/?https://github.com/P-p-H-d/mlib/blob/master/doc/Container.html">here</a>.</p>
<h2><a class="anchor" id="autotoc_md37"></a>
Generic methods</h2>
<p>The generated containers tries to generate and provide a consistent interface: their methods would behave the same for all generated containers. This chapter will explain the generic interface. In case of difference, it will be explained in the specific container.</p>
<p>In the following description:</p>
<ul>
<li><code>name</code> is the prefix used for the container generation,</li>
<li><code>name_t</code> refers to the type of the container,</li>
<li><code>name_it_t</code> refers to the iterator type of the container,</li>
<li><code>type_t</code> refers to the type of the object stored in the container,</li>
<li><code>key_type_t</code> refers to the type of the key object used to associate an element to,</li>
<li><code>value_type_t</code> refers to the type of the value object used to associate an element to.</li>
<li><code>name_itref_t</code> refers to a pair of key and value for associative arrays.</li>
</ul>
<p>An object shall be initialized (aka constructor) before being used by other methods. It shall be cleared (aka destructor) after being used and before program termination. An iterator has not destructor but shall be set before being used.</p>
<p>A container takes as input the</p>
<ul>
<li><code>name</code>  it is a mandatory argument that is the prefix used to generate all functions and types,</li>
<li><code>type</code>  it is a mandatory argument that the basic element of the container,</li>
<li><code>oplist</code>  it is an optional argument that defines the methods associated to the type. The provided oplist (if provided) shall be the one that is associated to the type, otherwise it won't generate compilable code. If there is no oplist parameter provided, a globally registered oplist associated to the type is used if possible, or the basic oplist for basic C types is used. This oplist will be used to handle internally the objects of the container.</li>
</ul>
<p>The <code>type</code> given to any templating macro can be either an integer, a float, a boolean, an enum, a named structure, a named union, a pointer to such types, or a typedef alias of any C type: in fact, the only constraint is that the preprocessing concatenation between <code>type</code> and <code>variable</code> into 'type variable' shall be a valid C expression. Therefore the <code>type</code> cannot be a C array or a function pointer and you shall use a typedef as an intermediary named type for such types.</p>
<p>This generic interface is specified as follow:</p>
<h4><a class="anchor" id="autotoc_md38"></a>
&lt;tt&gt;void name_init(name_t container)&lt;/tt&gt;</h4>
<p>Initialize the container <code>container</code> (aka constructor) to an empty container. Also called the default constructor of the container.</p>
<h4><a class="anchor" id="autotoc_md39"></a>
&lt;tt&gt;void name_init_set(name_t container, const name_t ref)&lt;/tt&gt;</h4>
<p>Initialize the container <code>container</code> (aka constructor) and set it to a copy of <code>ref</code>. This method is only created if the <code>INIT_SET</code> &amp; <code>SET</code> methods are provided. Also called the copy constructor of the container.</p>
<h4><a class="anchor" id="autotoc_md40"></a>
&lt;tt&gt;void name_set(name_t container, const name_t ref)&lt;/tt&gt;</h4>
<p>Set the container <code>container</code> to the copy of <code>ref</code>. This method is only created if the <code>INIT_SET</code> and <code>SET</code> methods are provided.</p>
<h4><a class="anchor" id="autotoc_md41"></a>
&lt;tt&gt;void name_init_move(name_t container, name_t ref)&lt;/tt&gt;</h4>
<p>Initialize the container <code>container</code> (aka constructor) by stealing as many resources from <code>ref</code> as possible. After-wise <code>ref</code> is cleared and can no longer be used (aka destructor).</p>
<h4><a class="anchor" id="autotoc_md42"></a>
&lt;tt&gt;void name_move(name_t container, name_t ref)&lt;/tt&gt;</h4>
<p>Set the container <code>container</code> (aka constructor) by stealing as many resources from <code>ref</code> as possible. After-wise <code>ref</code> is cleared and can no longer be used (aka destructor).</p>
<h4><a class="anchor" id="autotoc_md43"></a>
&lt;tt&gt;void name_clear(name_t container)&lt;/tt&gt;</h4>
<p>Clear the container <code>container</code> (aka destructor), calling the <code>CLEAR</code> method of all the objects of the container and freeing memory. The object can't be used anymore, except to be reinitialized with a constructor.</p>
<h4><a class="anchor" id="autotoc_md44"></a>
&lt;tt&gt;void name_reset(name_t container)&lt;/tt&gt;</h4>
<p>Reset the container clearing and freeing all objects stored in it. The container becomes empty but remains initialized.</p>
<h4><a class="anchor" id="autotoc_md45"></a>
&lt;tt&gt;type_t *name_back(const name_t container)&lt;/tt&gt;</h4>
<p>Return a pointer to the data stored in the back of the container. This pointer should not be stored in a global variable.</p>
<h4><a class="anchor" id="autotoc_md46"></a>
&lt;tt&gt;type_t *name_front(const name_t container)&lt;/tt&gt;</h4>
<p>Return a pointer to the data stored in the front of the container. This pointer should not be stored in a global variable.</p>
<h4><a class="anchor" id="autotoc_md47"></a>
&lt;tt&gt;void name_push(name_t container, const type_t value)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md48"></a>
&lt;tt&gt;void name_push_back(name_t container, const type_t value)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md49"></a>
&lt;tt&gt;void name_push_front(name_t container, const type_t value)&lt;/tt&gt;</h4>
<p>Push a new element in the container <code>container</code> as a copy of the object <code>value</code>. This method is created only if the <code>INIT_SET</code> operator is provided.</p>
<p>The <code>_back</code> suffixed method will push it in the back of the container. The <code>_front</code> suffixed method will push it in the front of the container.</p>
<h4><a class="anchor" id="autotoc_md50"></a>
&lt;tt&gt;type_t *name_push_raw(name_t container)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md51"></a>
&lt;tt&gt;type_t *name_push_back_raw(name_t container)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md52"></a>
&lt;tt&gt;type_t *name_push_front_raw(name_t container)&lt;/tt&gt;</h4>
<p>Push a new element in the container <code>container</code> without initializing it and returns a pointer to the <b>non-initialized</b> data. The first thing to do after calling this function shall be to initialize the data using the proper constructor of the object of type <code>type_t</code>. This enables using more specialized constructor than the generic copy one. The user should use other <code>_push</code> function if possible rather than this one as it is low level and error prone. This pointer should not be stored in a global variable.</p>
<p>The <code>_back</code> suffixed method will push it in the back of the container. The <code>_front</code> suffixed method will push it in the front of the container.</p>
<h4><a class="anchor" id="autotoc_md53"></a>
&lt;tt&gt;type_t *name_push_new(name_t container)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md54"></a>
&lt;tt&gt;type_t *name_push_back_new(name_t container)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md55"></a>
&lt;tt&gt;type_t *name_push_front_new(name_t container)&lt;/tt&gt;</h4>
<p>Push a new element in the container <code>container</code> and initialize it with the default constructor associated to the type <code>type_t</code>. Return a pointer to the initialized object. This pointer should not be stored in a global variable. This method is only created if the <code>INIT</code> method is provided.</p>
<p>The <code>_back</code> suffixed method will push it in the back of the container. The <code>_front</code> suffixed method will push it in the front of the container.</p>
<h4><a class="anchor" id="autotoc_md56"></a>
&lt;tt&gt;void name_push_move(name_t container, type_t *value)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md57"></a>
&lt;tt&gt;void name_push_back_move(name_t container, type_t *value)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md58"></a>
&lt;tt&gt;void name_push_front_move(name_t container, type_t *value)&lt;/tt&gt;</h4>
<p>Push a new element in the container <code>container</code> as a move from the object <code>*value</code>: it will therefore steal as much resources from <code>*value</code> as possible. Afterward <code>*value</code> is cleared and cannot longer be used (aka. destructor).</p>
<p>The <code>_back</code> suffixed method will push it in the back of the container. The <code>_front</code> suffixed method will push it in the front of the container.</p>
<h4><a class="anchor" id="autotoc_md59"></a>
&lt;tt&gt;void name_emplace[suffix](name_t container, args...)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md60"></a>
&lt;tt&gt;void name_emplace_back[suffix](name_t container, args...)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md61"></a>
&lt;tt&gt;void name_emplace_front[suffix](name_t container, args...)&lt;/tt&gt;</h4>
<p>Push a new element in the container <code>container</code> by initializing it with the provided arguments. The provided arguments shall therefore match one of the constructor provided by the <code>EMPLACE_TYPE</code> operator. There is one generated method per suffix defined in the <code>EMPLACE_TYPE</code> operator, and the <code>suffix</code> in the generated method name corresponds to the suffix defined in the <code>EMPLACE_TYPE</code> operator (it can be empty). This method is created only if the <code>EMPLACE_TYPE</code> operator is provided. See emplace chapter for more details.</p>
<p>The <code>_back</code> suffixed method will push it in the back of the container. The <code>_front</code> suffixed method will push it in the front of the container.</p>
<h4><a class="anchor" id="autotoc_md62"></a>
&lt;tt&gt;void name_pop(type_t *data, name_t container)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md63"></a>
&lt;tt&gt;void name_pop_back(type_t *data, name_t container)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md64"></a>
&lt;tt&gt;void name_pop_front(type_t *data, name_t container)&lt;/tt&gt;</h4>
<p>Pop a element from the container <code>container</code>; and set <code>*data</code> to this value if data is not the NULL pointer, otherwise it only pops the data. This method is created if the <code>SET</code> or <code>INIT_MOVE</code> operator is provided.</p>
<p>The <code>_back</code> suffixed method will pop it from the back of the container. The <code>_front</code> suffixed method will pop it from the front of the container.</p>
<h4><a class="anchor" id="autotoc_md65"></a>
&lt;tt&gt;void name_pop_move(type_t *data, name_t container)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md66"></a>
&lt;tt&gt;void name_pop_move_back(type_t *data, name_t container)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md67"></a>
&lt;tt&gt;void name_pop_move_front(type_t *data, name_t container)&lt;/tt&gt;</h4>
<p>Pop a element from the container <code>container</code> and initialize and set <code>*data</code> to this value (aka. constructor) by stealing as much resources from the container as possible. data shall not be a NULL pointer.</p>
<p>The <code>_back</code> suffixed method will pop it from the back of the container. The <code>_front</code> suffixed method will pop it from the front of the container.</p>
<h4><a class="anchor" id="autotoc_md68"></a>
&lt;tt&gt;bool name_empty_p(const name_t container)&lt;/tt&gt;</h4>
<p>Return true if the container is empty, false otherwise.</p>
<h4><a class="anchor" id="autotoc_md69"></a>
&lt;tt&gt;void name_swap(name_t container1, name_t container2)&lt;/tt&gt;</h4>
<p>Swap the container <code>container1</code> and <code>container2</code>.</p>
<h4><a class="anchor" id="autotoc_md70"></a>
&lt;tt&gt;void name_set_at(name_t container, size_t key, type_t value)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md71"></a>
&lt;tt&gt;void name_set_at(name_t container, key_type_t key, value_type_t value)&lt;/tt&gt; [for associative array]</h4>
<p>Set the element associated to <code>key</code> of the container <code>container</code> to <code>value</code>.</p>
<p>If the container is sequence-like (like array), the key is an integer. The selected element is the <code>key</code>-th element of the container, The index <code>key</code> shall be within the size of the container. This method is created if the <code>INIT_SET</code> operator is provided.</p>
<p>If the container is associative-array like, the selected element is the <code>value</code> object associated to the <code>key</code> object in the container. It is created if it doesn't exist, overwritten otherwise.</p>
<h4><a class="anchor" id="autotoc_md72"></a>
&lt;tt&gt;void name_emplace_key[keysuffix](name_t container, keyargs..., value_type_t value)&lt;/tt&gt; [for associative array]</h4>
<h4><a class="anchor" id="autotoc_md73"></a>
&lt;tt&gt;void name_emplace_val[valsuffix](name_t container, key_type_t key, valargs...)&lt;/tt&gt; [for associative array]</h4>
<h4><a class="anchor" id="autotoc_md74"></a>
&lt;tt&gt;void name_emplace_key[keysuffix]_val[valsuffix](name_t container, keyargs..., valargs...)&lt;/tt&gt; [for associative array]</h4>
<p>Set the element associated to <code>key</code> of the container <code>container</code> to <code>value</code>. <code>key</code> (resp. value) is constructed from the provided args <code>keyargs</code> (resp. <code>valargs</code>) if not provided.</p>
<p><code>keyargs</code> (resp. <code>valargs</code>) shall therefore match one of the constructor provided by the <code>EMPLACE_TYPE</code> operator of the key (resp. the value).</p>
<p>There is:</p>
<ul>
<li>one generated method per suffix defined in the <code>EMPLACE_TYPE</code> operator of the key,</li>
<li>one generated method per suffix defined in the <code>EMPLACE_TYPE</code> operator of the value,</li>
<li>one generated method per pair of suffix defined in the <code>EMPLACE_TYPE</code> operators of the key and value,</li>
</ul>
<p>The <code>suffix</code> in the generated method name corresponds to the suffix defined in in the <code>EMPLACE_TYPE</code> operator (it can be empty). This method is created only if one <code>EMPLACE_TYPE</code> operator is provided. See emplace chapter for more details.</p>
<h4><a class="anchor" id="autotoc_md75"></a>
&lt;tt&gt;type_t *name_get(const name_t container, size_t key)&lt;/tt&gt; [for sequence-like]</h4>
<h4><a class="anchor" id="autotoc_md76"></a>
&lt;tt&gt;const type_t *name_cget(const name_t container, size_t key)&lt;/tt&gt; [for sequence-like]</h4>
<h4><a class="anchor" id="autotoc_md77"></a>
&lt;tt&gt;type_t *name_get(const name_t container, const type_t key)&lt;/tt&gt; [for set-like]</h4>
<h4><a class="anchor" id="autotoc_md78"></a>
&lt;tt&gt;const type_t *name_cget(const name_t container, const type_t key)&lt;/tt&gt; [for set-like]</h4>
<h4><a class="anchor" id="autotoc_md79"></a>
&lt;tt&gt;value_type_t *name_get(const name_t container, const key_type_t key)&lt;/tt&gt; [for associative array]</h4>
<h4><a class="anchor" id="autotoc_md80"></a>
&lt;tt&gt;const value_type_t *name_cget(const name_t container, const key_type_t key)&lt;/tt&gt; [for associative array]</h4>
<p>Return a modifiable (resp. constant) pointer to the element associated to <code>key</code> in the container.</p>
<p>If the container is sequence-like, the key is an integer. The selected element is the <code>key</code>-th element of the container, the front being at the index 0, the last at the index (<code>size-1</code>). The index <code>key</code> shall be within the size of the container. Therefore, it will never return NULL in this case.</p>
<p>If the container is associative array like, the selected element is the <code>value</code> object associated to the <code>key</code> object in the container. If the key is not found, it returns NULL.</p>
<p>If the container is set-like, the selected element is the <code>value</code> object which is equal to the <code>key</code> object in the container. If the key is not found, it returns NULL.</p>
<p>This pointer remains valid until the container is modified by another method. This pointer should not be stored in a global variable.</p>
<h4><a class="anchor" id="autotoc_md81"></a>
&lt;tt&gt;type_t *name_get_emplace[suffix](const name_t container, args...)&lt;/tt&gt; [for set-like]</h4>
<h4><a class="anchor" id="autotoc_md82"></a>
&lt;tt&gt;value_type_t * name_get_emplace[suffix](name_t container, args...)&lt;/tt&gt; [for associative array]</h4>
<p>Return a modifiable (resp. constant) pointer to the element associated to the key constructed from <code>args</code> in the container. The selected element is the <code>value</code> object associated to the <code>key</code> object in the container for an associative array, or the element itself for a set. If the key is not found, it returns NULL.</p>
<p>This pointer remains valid until the container is modified by another method. This pointer should not be stored in a global variable.</p>
<h4><a class="anchor" id="autotoc_md83"></a>
&lt;tt&gt;type_t *name_safe_get(name_t container, size_t key)&lt;/tt&gt; [for sequence]</h4>
<h4><a class="anchor" id="autotoc_md84"></a>
&lt;tt&gt;type_t *name_safe_get(name_t container, const type_t key)&lt;/tt&gt; [for set]</h4>
<h4><a class="anchor" id="autotoc_md85"></a>
&lt;tt&gt;value_type_t *name_safe_get(name_t container, const key_type_t key)&lt;/tt&gt; [for associative array]</h4>
<p>Return a modifiable pointer to the element associated to <code>key</code> in the container, creating a new element if it doesn't exist (ensuring therefore a safe <code>get</code> operation).</p>
<p>If the container is sequence-like, key_type_t is an alias for size_t and key an integer, the selected element is the <code>key</code>-th element of the container. If the element doesn't exist, the container size will be increased if needed (creating new elements with the <code>INIT</code> operator), which might increase the container to much in some cases.</p>
<p>The returned pointer cannot be NULL. This method is only created if the <code>INIT</code> method is provided. This pointer remains valid until the array is modified by another method. This pointer should not be stored in a global variable.</p>
<h4><a class="anchor" id="autotoc_md86"></a>
&lt;tt&gt;bool name_erase(name_t container, const size_t key)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md87"></a>
&lt;tt&gt;bool name_erase(name_t container, const type_t key)&lt;/tt&gt; [for set]</h4>
<h4><a class="anchor" id="autotoc_md88"></a>
&lt;tt&gt;bool name_erase(name_t container, const key_type_t key)&lt;/tt&gt; [for associative array]</h4>
<p>Remove the element referenced by the key <code>key</code> in the container <code>container</code>. Do nothing if <code>key</code> is no present in the container. Return true if the key was present and erased, false otherwise.</p>
<h4><a class="anchor" id="autotoc_md89"></a>
&lt;tt&gt;size_t name_size(const name_t container)&lt;/tt&gt;</h4>
<p>Return the number elements of the container (its size). Return 0 if there is no element.</p>
<h4><a class="anchor" id="autotoc_md90"></a>
&lt;tt&gt;size_t name_capacity(const name_t container)&lt;/tt&gt;</h4>
<p>Return the capacity of the container, i.e. the maximum number of elements supported by the container before a reserve operation is needed to accommodate new elements.</p>
<h4><a class="anchor" id="autotoc_md91"></a>
&lt;tt&gt;void name_resize(name_t container, size_t size)&lt;/tt&gt;</h4>
<p>Resize the container <code>container</code> to the size <code>size</code>, increasing or decreasing the size of the container by initializing new elements or clearing existing ones. This method is only created if the INIT method is provided.</p>
<h4><a class="anchor" id="autotoc_md92"></a>
&lt;tt&gt;void name_reserve(name_t container, size_t capacity)&lt;/tt&gt;</h4>
<p>Extend or reduce the capacity of the <code>container</code> to a rounded value based on <code>capacity</code>. If the given capacity is below the current size of the container, the capacity is set to a rounded value based on the size of the container. Therefore a capacity of 0 is used to perform a shrink-to-fit operation on the container, i.e. reducing the container usage to the minimum possible allocation.</p>
<h4><a class="anchor" id="autotoc_md93"></a>
&lt;tt&gt;void name_it(name_it_t it, const name_t container)&lt;/tt&gt;</h4>
<p>Set the iterator <code>it</code> to the first element of the container <code>container</code>. There is no destructor associated to this initialization.</p>
<h4><a class="anchor" id="autotoc_md94"></a>
&lt;tt&gt;void name_it_set(name_it_t it, const name_it_t ref)&lt;/tt&gt;</h4>
<p>Set the iterator <code>it</code> to the iterator <code>ref</code>. There is no destructor associated to this initialization.</p>
<h4><a class="anchor" id="autotoc_md95"></a>
&lt;tt&gt;void name_it_end(name_it_t it, const name_t container)&lt;/tt&gt;</h4>
<p>Set the iterator <code>it</code> to a non valid element of the container. There is no destructor associated to this initialization.</p>
<h4><a class="anchor" id="autotoc_md96"></a>
&lt;tt&gt;bool name_end_p(const name_it_t it)&lt;/tt&gt;</h4>
<p>Return true if the iterator doesn't reference a valid element anymore.</p>
<h4><a class="anchor" id="autotoc_md97"></a>
&lt;tt&gt;bool name_last_p(const name_it_t it)&lt;/tt&gt;</h4>
<p>Return true if the iterator references the last element of the container or if the iterator doesn't reference a valid element anymore.</p>
<h4><a class="anchor" id="autotoc_md98"></a>
&lt;tt&gt;bool name_it_equal_p(const name_it_t it1, const name_it_t it2)&lt;/tt&gt;</h4>
<p>Return true if the iterator <code>it1</code> references the same element than the iterator <code>it2</code>.</p>
<h4><a class="anchor" id="autotoc_md99"></a>
&lt;tt&gt;void name_next(name_it_t it)&lt;/tt&gt;</h4>
<p>Move the iterator to the next element of the container.</p>
<h4><a class="anchor" id="autotoc_md100"></a>
&lt;tt&gt;void name_previous(name_it_t it)&lt;/tt&gt;</h4>
<p>Move the iterator <code>it</code> to the previous element of the container.</p>
<h4><a class="anchor" id="autotoc_md101"></a>
&lt;tt&gt;type_t *name_ref(name_it_t it)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md102"></a>
&lt;tt&gt;const type_t *name_cref(const name_it_t it)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md103"></a>
&lt;tt&gt;name_itref_t *name_ref(name_it_t it)&lt;/tt&gt;  [for associative array]</h4>
<h4><a class="anchor" id="autotoc_md104"></a>
&lt;tt&gt;const name_itref_t *name_cref(name_it_t it)&lt;/tt&gt;  [for associative array]</h4>
<p>Return a modifiable (resp. constant) pointer to the element pointed by the iterator. For associative-array like container, this element is the pair composed of the key (<code>key</code> field) and the associated value (<code>value</code> field); otherwise this element is simply the basic type of the container (<code>type_t</code>).</p>
<p>This pointer should not be stored in a global variable. This pointer remains valid until the container is modified by another method.</p>
<h4><a class="anchor" id="autotoc_md105"></a>
&lt;tt&gt;void name_insert(name_t container, const name_it_t it, const type_t x)&lt;/tt&gt;</h4>
<p>Insert the object <code>x</code> after the position referenced by the iterator <code>it</code> in the container <code>container</code> or if the iterator <code>it</code> doesn't reference anymore to a valid element of the container, it is added as the first element of the container. <code>it</code> shall be an iterator of the container <code>container</code>.</p>
<h4><a class="anchor" id="autotoc_md106"></a>
&lt;tt&gt;void name_remove(name_t container, name_it_t it)&lt;/tt&gt;</h4>
<p>Remove the element referenced by the iterator <code>it</code> from the container <code>container</code>. <code>it</code> shall be an iterator of the container <code>container</code>. Afterwards, <code>it</code> references the next element of the container if it exists, or not a valid element otherwise.</p>
<h4><a class="anchor" id="autotoc_md107"></a>
&lt;tt&gt;bool name_equal_p(const name_t container1, const name_t container2)&lt;/tt&gt;</h4>
<p>Return true if both containers <code>container1</code> and <code>container2</code> are considered equal. This method is only created if the <code>EQUAL</code> method is provided.</p>
<h4><a class="anchor" id="autotoc_md108"></a>
&lt;tt&gt;size_t name_hash(const name_t container)&lt;/tt&gt;</h4>
<p>Return a fast hash value of the container <code>container</code>, suitable to be used by a dictionary. This method is only created if the <code>HASH</code> method is provided.</p>
<h4><a class="anchor" id="autotoc_md109"></a>
&lt;tt&gt;void name_get_str(string_t str, const name_t container, bool append)&lt;/tt&gt;</h4>
<p>Set <code>str</code> to the formatted string representation of the container <code>container</code> if <code>append</code> is false or append <code>str</code> with this representation if <code>append</code> is true. This method is only created if the <code>GET_STR</code> method is provided.</p>
<h4><a class="anchor" id="autotoc_md110"></a>
&lt;tt&gt;bool name_parse_str(name_t container, const char str[], const char **endp)&lt;/tt&gt;</h4>
<p>Parse the formatted string <code>str</code>, that is assumed to be a string representation of a container, and set <code>container</code> to this representation. It returns true if success, false otherwise. If <code>endp</code> is not NULL, it sets <code>*endp</code> to the pointer of the first character not decoded by the function (or where the parsing fails). This method is only created if the <code>PARSE_STR</code> &amp; <code>INIT</code> methods are provided.</p>
<p>It is ensured that the container gets from parsing a formatted string representation gets from <code>name_get_str</code> and the original container are equal.</p>
<h4><a class="anchor" id="autotoc_md111"></a>
&lt;tt&gt;void name_out_str(FILE *file, const name_t container)&lt;/tt&gt;</h4>
<p>Generate a formatted string representation of the container <code>container</code> and outputs it into the file <code>FILE*</code>. The file <code>FILE*</code> shall be opened in write text mode and without error. This method is only created if the <code>OUT_STR</code> methods is provided.</p>
<h4><a class="anchor" id="autotoc_md112"></a>
&lt;tt&gt;bool name_in_str(name_t container, FILE *file)&lt;/tt&gt;</h4>
<p>Read from the file <code>FILE*</code> a formatted string representation of a container and set <code>container</code> to this representation. It returns true if success, false otherwise. This method is only created if the <code>IN_STR</code> &amp; <code>INIT</code> methods are provided.</p>
<p>It is ensured that the container gets from parsing a formatted string representation gets from name_out_str and the original container are equal.</p>
<h4><a class="anchor" id="autotoc_md113"></a>
&lt;tt&gt;m_serial_return_code_t name_out_serial(m_serial_write_t serial, const name_t container)&lt;/tt&gt;</h4>
<p>Output the container <code>container</code> into the serializing object <code>serial</code>. How and where it is output depends on the serializing object. It returns <code>M_SERIAL_OK_DONE</code> in case of success, or <code>M_SERIAL_FAILURE</code> in case of failure. In case of failure, the serializing object is in an unspecified but valid state. This method is only created if the <code>OUT_SERIAL</code> methods is provided.</p>
<h4><a class="anchor" id="autotoc_md114"></a>
&lt;tt&gt;m_serial_return_code_t name_in_serial(name_t container, m_serial_read_t serial)&lt;/tt&gt;</h4>
<p>Read from the serializing object <code>serial</code> a representation of a container and set <code>container</code> to this representation. It returns <code>M_SERIAL_OK_DONE</code> in case of success, or <code>M_SERIAL_FAILURE</code> in case of failure. In case of failure, the serializing object is in an unspecified but valid state. This method is only created if the <code>IN_SERIAL</code> &amp; <code>INIT</code> methods are provided.</p>
<p>It is ensured that the container gets from parsing a representation gets from name_out_serial and the original container are equal (using the same type of serialization object).</p>
<hr  />
<h2><a class="anchor" id="autotoc_md115"></a>
M-LIST</h2>
<p>This header is for creating <a href="https://en.wikipedia.org/wiki/Linked_list">singly linked list</a>.</p>
<p>A linked list is a linear collection of elements, in which each element points to the next, all of then representing a sequence.</p>
<p>A fundamental property of a list is that the objects created within the list will remain at their initialized address, and won't moved due to operations done on the list (except if it is removed). Therefore a returned pointer to an element of the container remains valid until this element is destroyed in the container.</p>
<h3><a class="anchor" id="autotoc_md116"></a>
&lt;tt&gt;LIST_DEF(name, type [, oplist])&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md117"></a>
&lt;tt&gt;LIST_DEF_AS(name, name_t, name_it_t, type [, oplist])&lt;/tt&gt;</h3>
<p><code>LIST_DEF</code> defines the singly linked list named <code>name_t</code> that contains objects of type <code>type</code> and their associated methods as <code>static inline</code> functions. <code>name</code> shall be a C identifier that will be used to identify the list. It will be used to create all the types (including the iterator) and functions to handle the container. This definition shall be done once per name and per compilation unit.</p>
<p>The oplist shall have at least the following operators (<code>INIT_SET</code>, <code>SET</code> and <code>CLEAR</code>), otherwise it won't generate compilable code.</p>
<p>For this container, the back is always the first element, and the front is the last element: the list grows from the back. Therefore, the iteration of this container using iterator objects will go from the back element to the front element (contrary to an array).</p>
<p>Even if it provides random access functions, theses access are slow and should be avoided: it iterates linearly over all the elements of the container until it reaches the requested element. The size method has the same drawback.</p>
<p>The push/pop methods of the container always operate on the back of the container.</p>
<p><code>LIST_DEF_AS</code> is the same as <code>LIST_DEF</code> except the name of the types <code>name_t</code>, <code>name_it_t</code> are provided by the user, and not computed from the <code>name</code> prefix.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gmp.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;m-list.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define MPZ_OUT_STR(stream, x) mpz_out_str(stream, 0, x)</span></div>
<div class="line">LIST_DEF(list_mpz, mpz_t,                                  \</div>
<div class="line">    (INIT(mpz_init), INIT_SET(mpz_init_set), SET(mpz_set), \</div>
<div class="line">        CLEAR(mpz_clear), OUT_STR(MPZ_OUT_STR)))</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">  list_mpz_t a;</div>
<div class="line">  list_mpz_init(a);</div>
<div class="line">  mpz_t x;</div>
<div class="line">  mpz_init_set_ui(x, 16);</div>
<div class="line">  list_mpz_push_back (a, x);</div>
<div class="line">  mpz_set_ui(x, 45);             </div>
<div class="line">  list_mpz_push_back (a, x);</div>
<div class="line">  mpz_clear(x);</div>
<div class="line">  printf (<span class="stringliteral">&quot;LIST is: &quot;</span>);</div>
<div class="line">  list_mpz_out_str(stdout, a);</div>
<div class="line">  printf (<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">  printf (<span class="stringliteral">&quot;First element is: &quot;</span>);</div>
<div class="line">  mpz_out_str(stdout, 0, *list_mpz_back(a));</div>
<div class="line">  printf (<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">  list_mpz_clear(a);</div>
<div class="line">}</div>
</div><!-- fragment --><p>If the given oplist contain the method <code>MEMPOOL</code>, then <code>LIST_DEF</code> macro will create a dedicated mempool that is named with the given value of the method <code>MEMPOOL</code>. This mempool (see mempool chapter) is optimized for this kind of list:</p>
<ul>
<li>it creates a mempool named by the concatenation of <code>name</code> and <code>_mempool</code>,</li>
<li>it creates a variable named by the value of the method <code>MEMPOOL</code> with the linkage defined by the value of the method <code>MEMPOOL_LINKAGE</code> (can be extern, static or none). This variable is shared by all lists of the same type.</li>
<li>it links the memory allocation of the list to use this mempool with this variable.</li>
</ul>
<p><code>mempool</code> create heavily efficient list. However, it is only worth the effort in some heavy performance context. Using mempool should be therefore avoided except in performance critical code. The created mempool has to be explicitly initialized before using any methods of the created list by calling <code>mempool_list_name_init(variable)</code> and cleared by calling <code>mempool_list_name_clear(variable)</code>.</p>
<p>Example:</p>
<div class="fragment"><div class="line">LIST_DEF(list_uint, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, (MEMPOOL(list_mpool), MEMPOOL_LINKAGE(<span class="keyword">static</span>)))</div>
<div class="line"> </div>
<div class="line">static <span class="keywordtype">void</span> test_list (<span class="keywordtype">size_t</span> n)</div>
<div class="line">{</div>
<div class="line">  list_uint_mempool_init(list_mpool);</div>
<div class="line">  M_LET(a1, LIST_OPLIST(uint)) {</div>
<div class="line">      <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; n; i++)</div>
<div class="line">          list_uint_push_back(a1, rand_get() );</div>
<div class="line">  }</div>
<div class="line">  list_uint_mempool_clear(list_mpool);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md118"></a>
&lt;tt&gt;LIST_OPLIST(name [, oplist])&lt;/tt&gt;</h3>
<p>Return the oplist of the list defined by calling <code>LIST_DEF</code> and <code>LIST_DUAL_PUSH_DEF</code> with name &amp; oplist. If there is no given oplist, the basic oplist for basic C types is used. There is no globally registered oplist support.</p>
<h3><a class="anchor" id="autotoc_md119"></a>
&lt;tt&gt;LIST_INIT_VALUE()&lt;/tt&gt;</h3>
<p>Define an initial value that is suitable to initialize global variable(s) of type <code>list</code> as created by <code>LIST_DEF</code> or <code>LIST_DEF_AS</code>. It enables to create a list as a global variable and to initialize it.</p>
<p>The list shall still be cleared manually to avoid leaking memory.</p>
<p>Example:</p>
<div class="fragment"><div class="line">LIST_DEF(list_int, <span class="keywordtype">int</span>)</div>
<div class="line">list_int_t my_list = LIST_INIT_VALUE();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md120"></a>
Created types</h3>
<p>The following types are automatically defined by the previous definition macro if not provided by the user:</p>
<h3><a class="anchor" id="autotoc_md121"></a>
&lt;tt&gt;name_t&lt;/tt&gt;</h3>
<p>Type of the list of <code>type</code> objects.</p>
<h3><a class="anchor" id="autotoc_md122"></a>
&lt;tt&gt;name_it_t&lt;/tt&gt;</h3>
<p>Type of an iterator over this list.</p>
<h3><a class="anchor" id="autotoc_md123"></a>
Generic methods</h3>
<p>The following methods of the generic interface are defined (See generic interface for details):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> name_init(name_t list)</div>
<div class="line"><span class="keywordtype">void</span> name_init_set(name_t list, <span class="keyword">const</span> name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_set(name_t list, <span class="keyword">const</span> name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_init_move(name_t list, name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_move(name_t list, name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_clear(name_t list)</div>
<div class="line"><span class="keywordtype">void</span> name_reset(name_t list)</div>
<div class="line">type *name_back(<span class="keyword">const</span> name_t list)</div>
<div class="line"><span class="keywordtype">void</span> name_push_back(name_t list, <span class="keyword">const</span> type value)</div>
<div class="line">type *name_push_raw(name_t list)</div>
<div class="line">type *name_push_new(name_t list)</div>
<div class="line"><span class="keywordtype">void</span> name_push_move(name_t list, type *value)</div>
<div class="line"><span class="keywordtype">void</span> name_emplace_back[suffix](name_t list, args...)</div>
<div class="line">void name_pop_back(type *data, name_t list)</div>
<div class="line"><span class="keywordtype">void</span> name_pop_move(type *data, name_t list)</div>
<div class="line"><span class="keywordtype">bool</span> name_empty_p(const name_t list)</div>
<div class="line"><span class="keywordtype">void</span> name_swap(name_t list1, name_t list2)</div>
<div class="line"><span class="keywordtype">void</span> name_it(name_it_t it, const name_t list)</div>
<div class="line"><span class="keywordtype">void</span> name_it_set(name_it_t it, const name_it_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_it_end(name_it_t it, const name_t list)</div>
<div class="line"><span class="keywordtype">bool</span> name_end_p(const name_it_t it)</div>
<div class="line"><span class="keywordtype">bool</span> name_last_p(const name_it_t it)</div>
<div class="line"><span class="keywordtype">bool</span> name_it_equal_p(const name_it_t it1, const name_it_t it2)</div>
<div class="line"><span class="keywordtype">void</span> name_next(name_it_t it)</div>
<div class="line">type *name_ref(name_it_t it)</div>
<div class="line">const type *name_cref(const name_it_t it)</div>
<div class="line">type *name_get(const name_t list, <span class="keywordtype">size_t</span> i)</div>
<div class="line">const type *name_cget(const name_t list, <span class="keywordtype">size_t</span> i)</div>
<div class="line"><span class="keywordtype">size_t</span> name_size(const name_t list)</div>
<div class="line"><span class="keywordtype">void</span> name_insert(name_t list, const name_it_t it, const type x)</div>
<div class="line"><span class="keywordtype">void</span> name_remove(name_t list, name_it_t it)</div>
<div class="line"><span class="keywordtype">void</span> name_get_str(string_t str, const name_t list, <span class="keywordtype">bool</span> append)</div>
<div class="line"><span class="keywordtype">bool</span> name_parse_str(name_t list, const <span class="keywordtype">char</span> str[], const <span class="keywordtype">char</span> **endp)</div>
<div class="line"><span class="keywordtype">void</span> name_out_str(FILE *file, const name_t list)</div>
<div class="line"><span class="keywordtype">bool</span> name_in_str(name_t list, FILE *file)</div>
<div class="line">m_serial_return_code_t name_out_serial(m_serial_write_t serial, const name_t container)</div>
<div class="line">m_serial_return_code_t name_in_str(name_t container, m_serial_read_t serial)</div>
<div class="line"><span class="keywordtype">bool</span> name_equal_p(const name_t list1, const name_t list2)</div>
<div class="line"><span class="keywordtype">size_t</span> name_hash(const name_t list)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md124"></a>
Specialized methods</h3>
<p>The following specialized methods are automatically created by the previous definition macro:</p>
<h4><a class="anchor" id="autotoc_md125"></a>
&lt;tt&gt;void name_splice_back(name_t list1, name_t list2, name_it_t it)&lt;/tt&gt;</h4>
<p>Move the element referenced by the iterator <code>it</code> from the list <code>list2</code> to the back position of the list <code>list1</code>. <code>it</code> shall be an iterator of <code>list2</code>. Afterwards, <code>it</code> references the next element of the list if it exists, or not a valid element otherwise.</p>
<h4><a class="anchor" id="autotoc_md126"></a>
&lt;tt&gt;void name_splice_at(name_t list1, name_it_t it1, name_t list2, name_it_t it2)&lt;/tt&gt;</h4>
<p>Move the element referenced by the iterator <code>it2</code> from the list <code>list2</code> to the position just after <code>it1</code> in the list <code>list1</code>. (If <code>it1</code> is not a valid position, it inserts it at the back just like <code>name_insert</code>). <code>it1</code> shall be an iterator of <code>list1</code>. <code>it2</code> shall be an iterator of <code>list2</code>. Afterwards, <code>it2</code> references the next element of the list if it exists, or not a valid element otherwise, and <code>it1</code> references the inserted element in <code>list1</code>.</p>
<h4><a class="anchor" id="autotoc_md127"></a>
&lt;tt&gt;void name_splice(name_t list1, name_t list2)&lt;/tt&gt;</h4>
<p>Move all the element of the list <code>list2</code> into the list <code>list1</code>, moving the last element of <code>list2</code> after the first element of <code>list1</code>. Afterwards, <code>list2</code> remains initialized but is emptied.</p>
<h4><a class="anchor" id="autotoc_md128"></a>
&lt;tt&gt;void name_reverse(name_t list)&lt;/tt&gt;</h4>
<p>Reverse the order of the list.</p>
<h3><a class="anchor" id="autotoc_md129"></a>
&lt;tt&gt;LIST_DUAL_PUSH_DEF(name, type[, oplist])&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md130"></a>
&lt;tt&gt;LIST_DUAL_PUSH_DEF_AS(name, name_t, name_it_t, type [, oplist])&lt;/tt&gt;</h3>
<p><code>LIST_DUAL_PUSH_DEF</code> defines the singly linked list named <code>name_t</code> that contains the objects of type <code>type</code> and their associated methods as <code>static inline</code> functions.</p>
<p>The only difference with the list defined by <code>LIST_DEF</code> is the support of the method for <code>PUSH_FRONT</code> in addition to the one for <code>PUSH_BACK</code> (so the <code>DUAL_PUSH</code> name). However, there is still only <code>POP</code> method (associated to <code>POP_BACK</code>). The list is a bit bigger to be able to handle such method to work, but not the nodes.</p>
<p>This list is therefore able to represent:</p>
<ul>
<li>either a stack (<code>PUSH_BACK</code> + <code>POP_BACK</code>)</li>
<li>or a queue (<code>PUSH_FRONT</code> + <code>POP_BACK</code>).</li>
</ul>
<p><code>LIST_DUAL_PUSH_DEF_AS</code> is the same as <code>LIST_DUAL_PUSH_DEF</code> except the name of the types <code>name_t</code>, <code>name_it_t</code> are provided by the user.</p>
<p>See <code>LIST_DEF</code> for more details and constraints.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gmp.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;m-list.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define MPZ_OUT_STR(stream, x) mpz_out_str(stream, 0, x)</span></div>
<div class="line">LIST_DUAL_PUSH_DEF(list_mpz, mpz_t,                        \</div>
<div class="line">    (INIT(mpz_init), INIT_SET(mpz_init_set), SET(mpz_set), \</div>
<div class="line">        CLEAR(mpz_clear), OUT_STR(MPZ_OUT_STR)))</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">  list_mpz_t a;</div>
<div class="line">  list_mpz_init(a);</div>
<div class="line">  mpz_t x;</div>
<div class="line">  mpz_init_set_ui(x, 16);</div>
<div class="line">  list_mpz_push_back (a, x);</div>
<div class="line">  mpz_set_ui(x, 45);             </div>
<div class="line">  list_mpz_push_back (a, x);</div>
<div class="line">  mpz_clear(x);</div>
<div class="line">  printf (<span class="stringliteral">&quot;LIST is: &quot;</span>);</div>
<div class="line">  list_mpz_out_str(stdout, a);</div>
<div class="line">  printf (<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">  printf (<span class="stringliteral">&quot;First element is: &quot;</span>);</div>
<div class="line">  mpz_out_str(stdout, 0, *list_mpz_back(a));</div>
<div class="line">  printf (<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">  list_mpz_clear(a);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The methods follow closely the methods defined by <code>LIST_DEF</code>.</p>
<h3><a class="anchor" id="autotoc_md131"></a>
&lt;tt&gt;LIST_DUAL_PUSH_INIT_VALUE()&lt;/tt&gt;</h3>
<p>Define an initial value that is suitable to initialize global variable(s) of type <code>list</code> as created by <code>LIST_DUAL_PUSH_DEF</code> or <code>LIST_DUAL_PUSH_DEF_AS</code>. It enables to create a list as a global variable and to initialize it.</p>
<p>The list should still be cleared manually to avoid leaking memory.</p>
<p>Example:</p>
<div class="fragment"><div class="line">LIST_DUAL_PUSH_DEF(list_int, <span class="keywordtype">int</span>)</div>
<div class="line">list_int_t my_list = LIST_DUAL_PUSH_INIT_VALUE();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md132"></a>
Created types</h3>
<p>The following types are automatically defined by the previous definition macro if not provided by the user:</p>
<h3><a class="anchor" id="autotoc_md133"></a>
&lt;tt&gt;name_t&lt;/tt&gt;</h3>
<p>Type of the list of <code>type</code>.</p>
<h3><a class="anchor" id="autotoc_md134"></a>
&lt;tt&gt;name_it_t&lt;/tt&gt;</h3>
<p>Type of an iterator over this list.</p>
<h3><a class="anchor" id="autotoc_md135"></a>
Generic methods</h3>
<p>The following methods of the generic interface are defined (See generic interface for details):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> name_init(name_t list)</div>
<div class="line"><span class="keywordtype">void</span> name_init_set(name_t list, <span class="keyword">const</span> name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_set(name_t list, <span class="keyword">const</span> name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_init_move(name_t list, name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_move(name_t list, name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_clear(name_t list)</div>
<div class="line"><span class="keywordtype">void</span> name_reset(name_t list)</div>
<div class="line">type *name_back(<span class="keyword">const</span> name_t list)</div>
<div class="line"><span class="keywordtype">void</span> name_push_back(name_t list, type value)</div>
<div class="line">type *name_push_back_raw(name_t list)</div>
<div class="line">type *name_push_back_new(name_t list)</div>
<div class="line"><span class="keywordtype">void</span> name_push_back_move(name_t list, type *value)</div>
<div class="line"><span class="keywordtype">void</span> name_emplace_back[suffix](name_t list, args...)</div>
<div class="line">const type *name_front(const name_t list)</div>
<div class="line"><span class="keywordtype">void</span> name_push_front(name_t list, type value)</div>
<div class="line">type *name_push_front_raw(name_t list)</div>
<div class="line">type *name_push_front_new(name_t list)</div>
<div class="line"><span class="keywordtype">void</span> name_push_front_move(name_t list, type *value)</div>
<div class="line"><span class="keywordtype">void</span> name_emplace_front[suffix](name_t list, args...)</div>
<div class="line"><span class="keywordtype">void</span> name_pop_back(type *data, name_t list)</div>
<div class="line"><span class="keywordtype">void</span> name_pop_move(type *data, name_t list)</div>
<div class="line"><span class="keywordtype">bool</span> name_empty_p(const name_t list)</div>
<div class="line"><span class="keywordtype">void</span> name_swap(name_t list1, name_t list2)</div>
<div class="line"><span class="keywordtype">void</span> name_it(name_it_t it, name_t list)</div>
<div class="line"><span class="keywordtype">void</span> name_it_set(name_it_t it, const name_it_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_it_end(name_it_t it, const name_t list)</div>
<div class="line"><span class="keywordtype">bool</span> name_end_p(const name_it_t it)</div>
<div class="line"><span class="keywordtype">bool</span> name_last_p(const name_it_t it)</div>
<div class="line"><span class="keywordtype">bool</span> name_it_equal_p(const name_it_t it1, const name_it_t it2)</div>
<div class="line"><span class="keywordtype">void</span> name_next(name_it_t it)</div>
<div class="line">type *name_ref(name_it_t it)</div>
<div class="line">const type *name_cref(const name_it_t it)</div>
<div class="line"><span class="keywordtype">size_t</span> name_size(const name_t list)</div>
<div class="line"><span class="keywordtype">void</span> name_insert(name_t list, const name_it_t it, const type x)</div>
<div class="line"><span class="keywordtype">void</span> name_remove(name_t list, name_it_t it)</div>
<div class="line"><span class="keywordtype">void</span> name_get_str(string_t str, const name_t list, <span class="keywordtype">bool</span> append)</div>
<div class="line"><span class="keywordtype">bool</span> name_parse_str(name_t list, const <span class="keywordtype">char</span> str[], const <span class="keywordtype">char</span> **endp)</div>
<div class="line"><span class="keywordtype">void</span> name_out_str(FILE *file, const name_t list)</div>
<div class="line"><span class="keywordtype">bool</span> name_in_str(name_t list, FILE *file)</div>
<div class="line">m_serial_return_code_t name_out_serial(m_serial_write_t serial, const name_t container)</div>
<div class="line">m_serial_return_code_t name_in_str(name_t container, m_serial_read_t serial)</div>
<div class="line"><span class="keywordtype">bool</span> name_equal_p(const name_t list1, const name_t list2)</div>
<div class="line"><span class="keywordtype">size_t</span> name_hash(const name_t list)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md136"></a>
Specialized methods</h3>
<p>The following specialized methods are automatically created by the previous definition macro:</p>
<h4><a class="anchor" id="autotoc_md137"></a>
&lt;tt&gt;void name_splice_back(name_t list1, name_t list2, name_it_t it)&lt;/tt&gt;</h4>
<p>Move the element pointed by <code>it</code> from the list <code>list2</code> to the back position of the list <code>list1</code>. <code>it</code> shall be an iterator of <code>list2</code>. Afterwards, <code>it</code> points to the next element of <code>list2</code>.</p>
<h4><a class="anchor" id="autotoc_md138"></a>
&lt;tt&gt;void name_splice(name_t list1, name_t list2)&lt;/tt&gt;</h4>
<p>Move all the element of the list <code>list2</code> into the list <code>list1</code>, moving the last element of <code>list2</code> after the first element of <code>list1</code>. Afterwards, <code>list2</code> is emptied.</p>
<h4><a class="anchor" id="autotoc_md139"></a>
&lt;tt&gt;void name_reverse(name_t list)&lt;/tt&gt;</h4>
<p>Reverse the order of the list.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md140"></a>
M-ARRAY</h2>
<p>An <a href="https://en.wikipedia.org/wiki/Array_data_structure">array</a> is a growable collection of element that are individually indexable.</p>
<h3><a class="anchor" id="autotoc_md141"></a>
&lt;tt&gt;ARRAY_DEF(name, type [, oplist])&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md142"></a>
&lt;tt&gt;ARRAY_DEF_AS(name, name_t, name_it_t, type [, oplist])&lt;/tt&gt;</h3>
<p><code>ARRAY_DEF</code> defines the array <code>name_t</code> that contains the objects of type <code>type</code> in a sequence and its associated methods as <code>static inline</code> functions. Compared to C arrays, the created methods handle automatically the size (aka growable array). <code>name</code> shall be a C identifier that will be used to identify the container. It will be used to create all the types (including the iterator) and functions to handle the container.</p>
<p>The provided oplist shall have at least the following operators (<code>CLEAR</code>). It should also provide the following operators (<code>INIT</code>, <code>INIT_SET</code>, <code>SET</code>), so that at least some methods are defined for the array!</p>
<p>The push / pop methods of the container always operate on the back of the container, acting like a stack-like container.</p>
<p><code>ARRAY_DEF_AS</code> is the same as <code>ARRAY_DEF</code> except the name of the types <code>name_t</code>, <code>name_it_t</code> are provided by the user.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gmp.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;m-array.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define MPZ_OUT_STR(stream, x) mpz_out_str(stream, 0, x)</span></div>
<div class="line">ARRAY_DEF(array_mpz, mpz_t,                                \</div>
<div class="line">    (INIT(mpz_init), INIT_SET(mpz_init_set), SET(mpz_set), \</div>
<div class="line">        CLEAR(mpz_clear), OUT_STR(MPZ_OUT_STR)))</div>
<div class="line">    </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">  array_mpz_t a;</div>
<div class="line">  array_mpz_init(a);</div>
<div class="line">  mpz_t x;</div>
<div class="line">  mpz_init_set_ui(x, 16);</div>
<div class="line">  array_mpz_push_back (a, x);</div>
<div class="line">  mpz_set_ui(x, 45);             </div>
<div class="line">  array_mpz_push_back (a, x);</div>
<div class="line">  mpz_clear(x);</div>
<div class="line">  printf (<span class="stringliteral">&quot;ARRAY is: &quot;</span>);</div>
<div class="line">  array_mpz_out_str(stdout, a);</div>
<div class="line">  printf (<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">  printf (<span class="stringliteral">&quot;First element is: &quot;</span>);</div>
<div class="line">  mpz_out_str(stdout, 0, *array_mpz_get(a, 0));</div>
<div class="line">  printf (<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">  array_mpz_clear(a);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md143"></a>
&lt;tt&gt;ARRAY_OPLIST(name [, oplist])&lt;/tt&gt;</h3>
<p>Return the oplist of the array defined by calling <code>ARRAY_DEF</code> with name &amp; oplist. If there is no given oplist, the basic oplist for basic C types is used.</p>
<h3><a class="anchor" id="autotoc_md144"></a>
&lt;tt&gt;ARRAY_INIT_VALUE()&lt;/tt&gt;</h3>
<p>Define an initial value that is suitable to initialize global variable(s) of type <code>array</code> as created by <code>ARRAY_DEF</code> or <code>ARRAY_DEF_AS</code>. It enables to create an array as a global variable and to initialize it.</p>
<p>The array should still be cleared manually to avoid leaking memory.</p>
<p>Example:</p>
<div class="fragment"><div class="line">ARRAY_DEF(array_int_t, <span class="keywordtype">int</span>)</div>
<div class="line">array_int_t my_array = ARRAY_INIT_VALUE();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md145"></a>
Created types</h3>
<p>The following types are automatically defined by the previous definition macro if not provided by the user:</p>
<h3><a class="anchor" id="autotoc_md146"></a>
&lt;tt&gt;name_t&lt;/tt&gt;</h3>
<p>Type of the array of <code>type</code>.</p>
<h3><a class="anchor" id="autotoc_md147"></a>
&lt;tt&gt;name_it_t&lt;/tt&gt;</h3>
<p>Type of an iterator over this array.</p>
<h3><a class="anchor" id="autotoc_md148"></a>
Generic methods</h3>
<p>The following methods of the generic interface are defined (See generic interface for details):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> name_init(name_t array)</div>
<div class="line"><span class="keywordtype">void</span> name_init_set(name_t array, <span class="keyword">const</span> name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_set(name_t array, <span class="keyword">const</span> name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_init_move(name_t array, name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_move(name_t array, name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_clear(name_t array)</div>
<div class="line"><span class="keywordtype">void</span> name_reset(name_t array)</div>
<div class="line">type *name_push_raw(name_t array)</div>
<div class="line"><span class="keywordtype">void</span> name_push_back(name_t array, <span class="keyword">const</span> type value)</div>
<div class="line">type *name_push_new(name_t array)</div>
<div class="line"><span class="keywordtype">void</span> name_push_move(name_t array, type *val)</div>
<div class="line"><span class="keywordtype">void</span> name_emplace_back[suffix](name_t array, args...)</div>
<div class="line">void name_pop_back(type *data, name_t array)</div>
<div class="line"><span class="keywordtype">void</span> name_pop_move(type *data, name_t array)</div>
<div class="line">type *name_front(const name_t array)</div>
<div class="line">type *name_back(const name_t array)</div>
<div class="line"><span class="keywordtype">void</span> name_set_at(name_t array, <span class="keywordtype">size_t</span> i, type value)</div>
<div class="line">type *name_get(name_t array, <span class="keywordtype">size_t</span> i)</div>
<div class="line">const type *name_cget(const name_t it, <span class="keywordtype">size_t</span> i)</div>
<div class="line">type *name_safe_get(name_t array, <span class="keywordtype">size_t</span> i)</div>
<div class="line"><span class="keywordtype">bool</span> name_empty_p(const name_t array)</div>
<div class="line"><span class="keywordtype">size_t</span> name_size(const name_t array)</div>
<div class="line"><span class="keywordtype">size_t</span> name_capacity(const name_t array)</div>
<div class="line"><span class="keywordtype">void</span> name_resize(name_t array, <span class="keywordtype">size_t</span> size)</div>
<div class="line"><span class="keywordtype">void</span> name_reserve(name_t array, <span class="keywordtype">size_t</span> capacity)</div>
<div class="line"><span class="keywordtype">void</span> name_swap(name_t array1, name_t array2)</div>
<div class="line"><span class="keywordtype">void</span> name_it(name_it_t it, name_t array)</div>
<div class="line"><span class="keywordtype">void</span> name_it_last(name_it_t it, name_t array)</div>
<div class="line"><span class="keywordtype">void</span> name_it_end(name_it_t it, name_t array)</div>
<div class="line"><span class="keywordtype">void</span> name_it_set(name_it_t it1, name_it_t it2)</div>
<div class="line"><span class="keywordtype">bool</span> name_end_p(name_it_t it)</div>
<div class="line"><span class="keywordtype">bool</span> name_last_p(name_it_t it)</div>
<div class="line"><span class="keywordtype">bool</span> name_it_equal_p(const name_it_t it1, const name_it_t it2)</div>
<div class="line"><span class="keywordtype">void</span> name_next(name_it_t it)</div>
<div class="line"><span class="keywordtype">void</span> name_previous(name_it_t it)</div>
<div class="line">type *name_ref(name_it_t it)</div>
<div class="line">const type *name_cref(const name_it_t it)</div>
<div class="line"><span class="keywordtype">void</span> name_remove(name_t array, name_it_t it)</div>
<div class="line"><span class="keywordtype">void</span> name_insert(name_t array, name_it_t it, const type x)</div>
<div class="line"><span class="keywordtype">void</span> name_get_str(string_t str, const name_t array, <span class="keywordtype">bool</span> append)</div>
<div class="line"><span class="keywordtype">bool</span> name_parse_str(name_t array, const <span class="keywordtype">char</span> str[], const <span class="keywordtype">char</span> **endp)</div>
<div class="line"><span class="keywordtype">void</span> name_out_str(FILE *file, const name_t array)</div>
<div class="line"><span class="keywordtype">bool</span> name_in_str(name_t array, FILE *file)</div>
<div class="line">m_serial_return_code_t name_out_serial(m_serial_write_t serial, const name_t container)</div>
<div class="line">m_serial_return_code_t name_in_str(name_t container, m_serial_read_t serial)</div>
<div class="line"><span class="keywordtype">bool</span> name_equal_p(const name_t array1, const name_t array2)</div>
<div class="line"><span class="keywordtype">size_t</span> name_hash(const name_t array)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md149"></a>
Specialized methods</h3>
<p>The following specialized methods are automatically created by the previous definition macro:</p>
<h4><a class="anchor" id="autotoc_md150"></a>
&lt;tt&gt;void name_push_at(name_t array, size_t key, const type x)&lt;/tt&gt;</h4>
<p>Push a new element into the position <code>key</code> of the array <code>array</code> with the value <code>value</code>. All elements after the position <code>key</code> (included) will be moved in the array towards the back, and the array will have one more element. <code>key</code> shall be a valid position of the array: from 0 to the size of array (included). This method is created only if the <code>INIT_SET</code> operator is provided.</p>
<h4><a class="anchor" id="autotoc_md151"></a>
&lt;tt&gt;void name_pop_until(name_t array, array_it_t position)&lt;/tt&gt;</h4>
<p>Pop all elements of the array <code>array</code> from 'position' to the back of the array, while clearing them. This method is created only if the <code>INIT</code> operator is provided.</p>
<h4><a class="anchor" id="autotoc_md152"></a>
&lt;tt&gt;void name_pop_at(type *dest, name_t array, size_t key)&lt;/tt&gt;</h4>
<p>Set <code>*dest</code> to the value the element <code>key</code> if dest is not NULL, then remove the element <code>key</code> from the array (decreasing the array size). <code>key</code> shall be within the size of the array. This method is created only if the SET or INIT_MOVE operator is provided.</p>
<h4><a class="anchor" id="autotoc_md153"></a>
&lt;tt&gt;void name_remove_v(name_t array, size_t i, size_t j)&lt;/tt&gt;</h4>
<p>Remove the element <code>i</code> (included) to the element <code>j</code> (excluded) from the array. <code>i</code> and <code>j</code> shall be within the size of the array, and <code>i &lt; j</code>.</p>
<h4><a class="anchor" id="autotoc_md154"></a>
&lt;tt&gt;void name_insert_v(name_t array, size_t i, size_t j)&lt;/tt&gt;</h4>
<p>Insert from the element <code>i</code> (included) to the element <code>j</code> (excluded) new empty elements to the array. <code>i</code> and <code>j</code> shall be within the size of the array, and <code>i &lt; j</code>. This method is only defined if the type of the element defines an <code>INIT</code> method.</p>
<h4><a class="anchor" id="autotoc_md155"></a>
&lt;tt&gt;void name_swap_at(name_t array, size_t i, size_t j)&lt;/tt&gt;</h4>
<p>Swap the elements <code>i</code> and <code>j</code> of the array <code>array</code>. <code>i</code> and <code>j</code> shall reference valid elements of the array. This method is created if the <code>INIT_SET</code> or <code>INIT_MOVE</code> operator is provided.</p>
<h4><a class="anchor" id="autotoc_md156"></a>
&lt;tt&gt;void name_special_sort(name_t array)&lt;/tt&gt;</h4>
<p>Sort the array <code>array</code>. This method is defined if the type of the element defines <code>CMP</code> method. This method uses the qsort function of the C library.</p>
<h4><a class="anchor" id="autotoc_md157"></a>
&lt;tt&gt;void name_special_stable_sort(name_t array)&lt;/tt&gt;</h4>
<p>Sort the array <code>array</code> using a stable sort. This method is defined if the type of the element defines <code>CMP</code> and <code>SWAP</code> and <code>SET</code> methods. This method provides an ad-hoc implementation of the stable sort. In practice, it is faster than the _sort method for small types and fast comparisons.</p>
<h4><a class="anchor" id="autotoc_md158"></a>
&lt;tt&gt;void name_splice(name_t array1, name_t array2)&lt;/tt&gt;</h4>
<p>Move all the elements of the array <code>array2</code> to the end of the array <code>array1</code>. Afterwards, <code>array2</code> is empty.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md159"></a>
M-DEQUE</h2>
<p>This header is for creating <a href="https://en.wikipedia.org/wiki/Double-ended_queue">double-ended queue</a> (or deque). A deque is an abstract data type that generalizes a queue, for that elements can be added to or removed from either the front (head) or back (tail)</p>
<h3><a class="anchor" id="autotoc_md160"></a>
&lt;tt&gt;DEQUE_DEF(name, type [, oplist])&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md161"></a>
&lt;tt&gt;DEQUE_DEF_AS(name, name_t, name_it_t, type [, oplist])&lt;/tt&gt;</h3>
<p><code>DEQUE_DEF</code> defines the deque <code>name_t</code> that contains the objects of type <code>type</code> and its associated methods as <code>static inline</code> functions. <code>name</code> shall be a C identifier that will be used to identify the deque. It will be used to create all the types (including the iterator) and functions to handle the container. This definition shall be done once per name and per compilation unit.</p>
<p>The oplist shall have at least the following operators (<code>INIT</code>, <code>INIT_SET</code>, <code>SET</code> and <code>CLEAR</code>), otherwise it won't generate compilable code.</p>
<p>The algorithm complexity to access random elements is in O(ln(n)). Removing an element may unbalance the deque, which breaks the promise of algorithm complexity for the _get method.</p>
<p><code>DEQUE_DEF_AS</code> is the same as <code>DEQUE_DEF</code> except the name of the types <code>name_t</code>, <code>name_it_t</code> are provided.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gmp.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;m-deque.h&quot;</span></div>
<div class="line"> </div>
<div class="line">DEQUE_DEF(deque_mpz, mpz_t,                                           \</div>
<div class="line">          (INIT(mpz_init), INIT_SET(mpz_init_set), SET(mpz_set), CLEAR(mpz_clear)))</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">  deque_mpz_t a;</div>
<div class="line">  deque_mpz_init(a);</div>
<div class="line">  mpz_t x;</div>
<div class="line">  mpz_init_set_ui(x, 16);</div>
<div class="line">  deque_mpz_push_back (a, x);</div>
<div class="line">  mpz_set_ui(x, 45);             </div>
<div class="line">  deque_mpz_push_front (a, x);</div>
<div class="line">  deque_mpz_pop_back(&amp;x, a);</div>
<div class="line">  mpz_set_ui(x, 5);</div>
<div class="line">  deque_mpz_push_back (a, x);</div>
<div class="line">  mpz_clear(x);</div>
<div class="line"> </div>
<div class="line">  printf (<span class="stringliteral">&quot;First element is: &quot;</span>);</div>
<div class="line">  mpz_out_str(stdout, 0, *deque_mpz_front(a));</div>
<div class="line">  printf (<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">  printf (<span class="stringliteral">&quot;Last element is: &quot;</span>);</div>
<div class="line">  mpz_out_str(stdout, 0, *deque_mpz_back(a));</div>
<div class="line">  printf (<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">  deque_mpz_clear(a);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md162"></a>
&lt;tt&gt;DEQUE_OPLIST(name [, oplist])&lt;/tt&gt;</h3>
<p>Return the oplist of the deque defined by calling <code>DEQUE_DEF</code> with name <code>oplist</code>.</p>
<h3><a class="anchor" id="autotoc_md163"></a>
Created types</h3>
<p>The following types are automatically defined by the previous definition macro if not provided by the user:</p>
<h3><a class="anchor" id="autotoc_md164"></a>
&lt;tt&gt;name_t&lt;/tt&gt;</h3>
<p>Type of the deque of <code>type</code>.</p>
<h3><a class="anchor" id="autotoc_md165"></a>
&lt;tt&gt;name_it_t&lt;/tt&gt;</h3>
<p>Type of an iterator over this deque.</p>
<h3><a class="anchor" id="autotoc_md166"></a>
Generic methods</h3>
<p>The following methods of the generic interface are defined (See generic interface for details):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> name_init(name_t deque)</div>
<div class="line"><span class="keywordtype">void</span> name_init_set(name_t deque, <span class="keyword">const</span> name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_set(name_t deque, <span class="keyword">const</span> name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_init_move(name_t deque, name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_move(name_t deque, name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_clear(name_t deque)</div>
<div class="line"><span class="keywordtype">void</span> name_reset(name_t deque)</div>
<div class="line">type *name_back(<span class="keyword">const</span> name_t deque)</div>
<div class="line"><span class="keywordtype">void</span> name_push_back(name_t deque, type value)</div>
<div class="line">type *name_push_back_raw(name_t deque)</div>
<div class="line">type *name_push_back_new(name_t deque)</div>
<div class="line"><span class="keywordtype">void</span> name_emplace_back[suffix](name_t list, args...)</div>
<div class="line">void name_pop_back(type *data, name_t deque)</div>
<div class="line">type *name_front(const name_t deque)</div>
<div class="line"><span class="keywordtype">void</span> name_push_front(name_t deque, type value)</div>
<div class="line">type *name_push_front_raw(name_t deque)</div>
<div class="line">type *name_push_front_new(name_t deque)</div>
<div class="line"><span class="keywordtype">void</span> name_emplace_front[suffix](name_t list, args...)</div>
<div class="line"><span class="keywordtype">void</span> name_pop_front(type *data, name_t deque)</div>
<div class="line"><span class="keywordtype">bool</span> name_empty_p(const name_t deque)</div>
<div class="line"><span class="keywordtype">void</span> name_swap(name_t deque1, name_t deque2)</div>
<div class="line"><span class="keywordtype">void</span> name_it(name_it_t it, name_t deque)</div>
<div class="line"><span class="keywordtype">void</span> name_it_set(name_it_t it, const name_it_t ref)</div>
<div class="line"><span class="keywordtype">bool</span> name_end_p(const name_it_t it)</div>
<div class="line"><span class="keywordtype">bool</span> name_last_p(const name_it_t it)</div>
<div class="line"><span class="keywordtype">bool</span> name_it_equal_p(const name_it_t it1, const name_it_t it2)</div>
<div class="line"><span class="keywordtype">void</span> name_next(name_it_t it)</div>
<div class="line"><span class="keywordtype">void</span> name_previous(name_it_t it)</div>
<div class="line">type *name_ref(name_it_t it)</div>
<div class="line">const type *name_cref(const name_it_t it)</div>
<div class="line"><span class="keywordtype">void</span> name_remove(name_t deque, name_it_t it)</div>
<div class="line">type *name_get(const name_t deque, <span class="keywordtype">size_t</span> i)</div>
<div class="line">const type *name_cget(const name_t deque, <span class="keywordtype">size_t</span> i)</div>
<div class="line"><span class="keywordtype">size_t</span> name_size(const name_t deque)</div>
<div class="line"><span class="keywordtype">void</span> name_get_str(string_t str, const name_t deque, <span class="keywordtype">bool</span> append)</div>
<div class="line"><span class="keywordtype">bool</span> name_parse_str(name_t deque, const <span class="keywordtype">char</span> str[], const <span class="keywordtype">char</span> **endp)</div>
<div class="line"><span class="keywordtype">void</span> name_out_str(FILE *file, const name_t deque)</div>
<div class="line"><span class="keywordtype">bool</span> name_in_str(name_t deque, FILE *file)</div>
<div class="line">m_serial_return_code_t name_out_serial(m_serial_write_t serial, const name_t container)</div>
<div class="line">m_serial_return_code_t name_in_str(name_t container, m_serial_read_t serial)</div>
<div class="line"><span class="keywordtype">bool</span> name_equal_p(const name_t deque1, const name_t deque2)</div>
<div class="line"><span class="keywordtype">size_t</span> name_hash(const name_t deque)</div>
<div class="line"><span class="keywordtype">void</span> name_swap_at(name_t deque, <span class="keywordtype">size_t</span> i, <span class="keywordtype">size_t</span> j)</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md167"></a>
M-DICT</h2>
<p>A <a href="https://en.wikipedia.org/wiki/Associative_array">dictionary</a> (or associative array, map, symbol table) is an abstract data type composed of a collection of (key, value) pairs, such that each possible key appears at most once in the collection, and is associated to only one value. It is possible to search for a key in the dictionary and get back its value.</p>
<p>Several dictionaries are proposed. The "best" to use depends on the data type and in particular the size of the data. For very small, fast types (integer, or floats, or pair of such types), <code>DICT_OA_DEF2</code> may be the best to use (but slightly more complex to instantiate). However <code>DICT_DEF2</code> should be good enough for all scenarios.</p>
<h3><a class="anchor" id="autotoc_md168"></a>
&lt;tt&gt;DICT_DEF2(name, key_type[, key_oplist], value_type[, value_oplist])&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md169"></a>
&lt;tt&gt;DICT_DEF2_AS(name,  name_t, name_it_t, name_itref_t, key_type[, key_oplist], value_type[, value_oplist])&lt;/tt&gt;</h3>
<p><code>DICT_DEF2</code> defines the dictionary <code>name_t</code> and its associated methods as <code>static inline</code> functions as an associative array of <code>key_type</code> to <code>value_type</code>.</p>
<p><code>name</code> shall be a C identifier that will be used to identify the dictionary. It will be used to create all the types (including the iterator and the iterated object type) and functions to handle the container. This definition shall be done once per name and per compilation unit.</p>
<p>Both oplist shall have at least the following operators (<code>INIT_SET</code>, <code>SET</code> and <code>CLEAR</code>), otherwise it won't generate compilable code. The <code>key_oplist</code> shall also define the additional operators (<code>HASH</code> and <code>EQUAL</code>).</p>
<p>Elements in the dictionary are <b>unordered</b>. On insertion of a new element, contained objects may moved. Maximum number of elements of this dictionary is 3'006'477'107 elements.</p>
<p>The <code>_set_at</code> method overwrites the already existing value if <code>key</code> is already present in the dictionary (contrary to C++).</p>
<p>The iterated object type <code>name##_itref_t</code> is a pair of key_type and value_type.</p>
<p>What is exactly the "first" element for the iteration is not specified. It is only ensured that all elements of the dictionary are explored by going from "first" to "end".</p>
<p><code>DICT_DEF2_AS</code> is the same as <code>DICT_DEF2</code> except the name of the types <code>name_t</code>, <code>name_it_t</code>, <code>name_itref_t</code> are provided.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;m-string.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;m-dict.h&quot;</span></div>
<div class="line"> </div>
<div class="line">DICT_DEF2(dict_string, string_t, <span class="keywordtype">unsigned</span>)</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">  dict_string_t a;</div>
<div class="line">  dict_string_init(a);</div>
<div class="line">  string_t x;</div>
<div class="line">  string_init_set_str(x, <span class="stringliteral">&quot;This is an example&quot;</span>);</div>
<div class="line">  dict_string_set_at (a, x, 1);</div>
<div class="line">  string_set_str(x, <span class="stringliteral">&quot;This is an another example&quot;</span>);</div>
<div class="line">  dict_string_set_at (a, x, 2);</div>
<div class="line"> </div>
<div class="line">  string_set_str(x, <span class="stringliteral">&quot;This is an example&quot;</span>);</div>
<div class="line">  <span class="keywordtype">unsigned</span> *val = dict_string_get(a, x);</div>
<div class="line">  printf (<span class="stringliteral">&quot;Value of %s is %u\n&quot;</span>, string_get_cstr(x), *val);</div>
<div class="line">  string_clear(x);</div>
<div class="line"> </div>
<div class="line">  printf (<span class="stringliteral">&quot;Dictionary is: &quot;</span>);</div>
<div class="line">  dict_string_out_str(stdout, a);</div>
<div class="line">  printf (<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">  dict_string_clear(a);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md170"></a>
&lt;tt&gt;DICT_OA_DEF2(name, key_type[, key_oplist], value_type[, value_oplist])&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md171"></a>
&lt;tt&gt;DICT_OA_DEF2_AS(name,  name_t, name_it_t, name_itref_t, key_type[, key_oplist], value_type[, value_oplist])&lt;/tt&gt;</h3>
<p><code>DICT_OA_DEF2</code> defines the dictionary <code>name_t</code> and its associated methods as <code>static inline</code> functions much like <code>DICT_DEF2</code>. The difference is that it uses an Open Addressing Hash-Table as container that stores the data with the table.</p>
<p>The <code>key_oplist</code> shall also define the additional operators: <code>OOR_EQUAL</code> and <code>OOR_SET</code></p>
<p>The Out-Of-Range operators (<code>OOR_EQUAL</code> and <code>OOR_SET</code>) are used to store uninitialized keys in the dictionary and be able to detect it. This enables avoiding a separate bit-field to know the state of the entry in the dictionary (which increases memory usage and is cache unfriendly).</p>
<p>The elements may move when inserting / deleting other elements (and not just the iterators).</p>
<p>This implementation is in general faster for small types of keys (like integer or float) but are slower for larger types.</p>
<p><code>DICT_OA_DEF2_AS</code> is the same as <code>DICT_OA_DEF2</code> except the name of the types <code>name_t</code>, <code>name_it_t</code>, <code>name_itref_t</code> are provided.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;m-string.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;m-dict.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define an Out Of Range equal function</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> oor_equal_p(<span class="keywordtype">unsigned</span> k, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> n) {</div>
<div class="line">  <span class="keywordflow">return</span> k == (unsigned)(-n-1);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// Define an Out Of Range function</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> oor_set(<span class="keywordtype">unsigned</span> *k, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> n) {</div>
<div class="line">  *k = (unsigned)(-n-1);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">DICT_OA_DEF2(dict_unsigned, <span class="keywordtype">unsigned</span>, M_OPEXTEND(M_BASIC_OPLIST, </div>
<div class="line">            OOR_EQUAL(oor_equal_p), OOR_SET(API_2(oor_set))), <span class="keywordtype">long</span> <span class="keywordtype">long</span>, M_BASIC_OPLIST)</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">unsigned</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">  dict_unsigned_t a;</div>
<div class="line">  dict_unsigned_init(a);</div>
<div class="line">  dict_unsigned_set_at (a, 13566, 14890943049);</div>
<div class="line">  dict_unsigned_set_at (a, 656, -2);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">long</span> <span class="keywordtype">long</span> *val = dict_unsigned_get(a, 458);</div>
<div class="line">  printf (<span class="stringliteral">&quot;Value of %d is %p\n&quot;</span>, 458, val); <span class="comment">// Not found value</span></div>
<div class="line">  val = dict_unsigned_get(a, 656);</div>
<div class="line">  printf (<span class="stringliteral">&quot;Value of %d is %lld\n&quot;</span>, 656, *val);</div>
<div class="line"> </div>
<div class="line">  dict_unsigned_clear(a);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md172"></a>
&lt;tt&gt;DICT_OPLIST(name[, key_oplist, value_oplist])&lt;/tt&gt;</h3>
<p>Return the oplist of the dictionary defined by calling any <code>DICT_*_DEF2</code> with <code>name</code>, <code>key_oplist</code>, <code>value_oplist</code>.</p>
<h3><a class="anchor" id="autotoc_md173"></a>
&lt;tt&gt;DICT_SET_DEF(name, key_type[, key_oplist])&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md174"></a>
&lt;tt&gt;DICT_SET_DEF_AS(name,  name_t, name_it_t, key_type[, key_oplist])&lt;/tt&gt;</h3>
<p><code>DICT_SET_DEF</code> defines the dictionary set <code>name_t</code> and its associated methods as <code>static inline</code> functions. A dictionary set is a specialized version of a dictionary with no value (only keys).</p>
<p><code>name</code> shall be a C identifier that will be used to identify the dictionary. It will be used to create all the types (including the iterator) and functions to handle the container. This definition shall be done once per name and per compilation unit.</p>
<p>The oplist shall have at least the following operators (<code>INIT_SET</code>, <code>SET</code>, <code>CLEAR</code>, <code>HASH</code> and <code>EQUAL</code>), otherwise it won't generate compilable code.</p>
<p>The <code>_push</code> method will overwrite the already existing value if <code>key</code> is already present in the dictionary (contrary to C++).</p>
<p>What is exactly the "first" element for the iteration is not specified. It is only ensured that all elements of the dictionary are explored by going from "first" to "end".</p>
<p><code>DICT_SET_DEF_AS</code> is the same as <code>DICT_SET_DEF</code> except the name of the types <code>name_t</code>, <code>name_it_t</code> are provided.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;m-string.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;m-dict.h&quot;</span></div>
<div class="line"> </div>
<div class="line">DICT_SET_DEF(set_string, <span class="keywordtype">double</span>)</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">unsigned</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">  set_string_t a;</div>
<div class="line">  set_string_init(a);</div>
<div class="line">  set_string_push (a, 13566);</div>
<div class="line">  set_string_push (a, 656);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> *val = set_string_get(a, 458);</div>
<div class="line">  printf (<span class="stringliteral">&quot;Value of %d is %p\n&quot;</span>, 458, val); <span class="comment">// Not found value</span></div>
<div class="line">  val = set_string_get(a, 656);</div>
<div class="line">  printf (<span class="stringliteral">&quot;Value of %d is %f\n&quot;</span>, 656, *val);</div>
<div class="line"> </div>
<div class="line">  printf(<span class="stringliteral">&quot;Set is &quot;</span>);</div>
<div class="line">  set_string_out_str(stdout, a);</div>
<div class="line">  printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">  set_string_clear(a);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md175"></a>
&lt;tt&gt;DICT_OASET_DEF(name, key_type[, key_oplist])&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md176"></a>
&lt;tt&gt;DICT_OASET_DEF_AS(name,  name_t, name_it_t, key_type[, key_oplist])&lt;/tt&gt;</h3>
<p><code>DICT_OASET_DEF</code> defines the dictionary set <code>name_t</code> and its associated methods as <code>static inline</code> functions just like <code>DICT_SET_DEF</code>. The difference is that it uses an Open Addressing Hash-Table as container.</p>
<p>The <code>key_oplist</code> shall also define the additional operators: <code>OOR_EQUAL</code> and <code>OOR_SET</code></p>
<p>The elements may move when inserting / deleting other elements (and not just the iterators).</p>
<p>This implementation is in general faster for small types of keys (like integer) but slower for larger types.</p>
<p><code>DICT_OASET_DEF_AS</code> is the same as <code>DICT_OASET_DEF</code> except the name of the types <code>name_t</code>, <code>name_it_t</code> are provided.</p>
<h3><a class="anchor" id="autotoc_md177"></a>
&lt;tt&gt;DICT_SET_OPLIST(name[, key_oplist])&lt;/tt&gt;</h3>
<p>Return the oplist of the set defined by calling <code>DICT_SET_DEF</code> (or <code>DICT_OASET_DEF</code>) with <code>name</code> and <code>key_oplist</code>.</p>
<h3><a class="anchor" id="autotoc_md178"></a>
Created types</h3>
<p>The following types are automatically defined by the previous definition macro if not provided by the user:</p>
<h4><a class="anchor" id="autotoc_md179"></a>
&lt;tt&gt;name_t&lt;/tt&gt;</h4>
<p>Type of the dictionary which</p><ul>
<li>either associate <code>key_type</code> to <code>value_type</code>,</li>
<li>or store unique element <code>key_type</code>.</li>
</ul>
<h4><a class="anchor" id="autotoc_md180"></a>
&lt;tt&gt;name_it_t&lt;/tt&gt;</h4>
<p>Type of an iterator over this dictionary.</p>
<h4><a class="anchor" id="autotoc_md181"></a>
&lt;tt&gt;name_itref_t&lt;/tt&gt; [only for associative array]</h4>
<p>Type of one item referenced in the dictionary for associative array. It is a structure composed of the key (field <code>key</code>) and the value (field <code>value</code>). This type is created only for associative arrays (<code>_DEF2</code> suffix) and not for sets.</p>
<h3><a class="anchor" id="autotoc_md182"></a>
Generic methods</h3>
<p>The following methods of the generic interface are defined (See generic interface for details):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> name_init(name_t dict)</div>
<div class="line"><span class="keywordtype">void</span> name_clear(name_t dict)</div>
<div class="line"><span class="keywordtype">void</span> name_init_set(name_t dict, <span class="keyword">const</span> name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_set(name_t dict, <span class="keyword">const</span> name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_init_move(name_t dict, name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_move(name_t dict, name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_reset(name_t dict)</div>
<div class="line"><span class="keywordtype">size_t</span> name_size(<span class="keyword">const</span> name_t dict)</div>
<div class="line"><span class="keywordtype">bool</span> name_empty_p(<span class="keyword">const</span> name_t dict)</div>
<div class="line">value_type *name_get(<span class="keyword">const</span> name_t dict, <span class="keyword">const</span> key_type key)</div>
<div class="line">value_type_t * name_get_emplace[suffix](name_t container, args...)</div>
<div class="line">value_type *name_safe_get(name_t dict, const key_type key)</div>
<div class="line"><span class="keywordtype">void</span> name_set_at(name_t dict, const key_type key, const value_type value)   <span class="comment">/* for associative array */</span></div>
<div class="line"><span class="keywordtype">void</span> name_push(name_t dict, const key_type key)       <span class="comment">/* for dictionary set */</span></div>
<div class="line"><span class="keywordtype">bool</span> name_erase(name_t dict, const key_type key)</div>
<div class="line"><span class="keywordtype">void</span> name_it(name_it_t it, name_t dict)</div>
<div class="line"><span class="keywordtype">void</span> name_it_set(name_it_t it, const name_it_t ref)</div>
<div class="line"><span class="keywordtype">bool</span> name_end_p(const name_it_t it)</div>
<div class="line"><span class="keywordtype">bool</span> name_last_p(const name_it_t it)</div>
<div class="line"><span class="keywordtype">void</span> name_next(name_it_t it)</div>
<div class="line">name_itref_t *name_ref(name_it_t it)  <span class="comment">/* for associative array */</span></div>
<div class="line">key_type *name_ref(name_it_t it)       <span class="comment">/* for dictionary set */</span></div>
<div class="line">const name_itref_t *name_cref(name_it_t it)  <span class="comment">/* for associative array */</span></div>
<div class="line">const key_type *name_cref(name_it_t it)       <span class="comment">/* for dictionary set */</span></div>
<div class="line"><span class="keywordtype">void</span> name_get_str(string_t str, const name_t dict, <span class="keywordtype">bool</span> append)</div>
<div class="line"><span class="keywordtype">bool</span> name_parse_str(name_t dict, const <span class="keywordtype">char</span> str[], const <span class="keywordtype">char</span> **endp)</div>
<div class="line"><span class="keywordtype">void</span> name_out_str(FILE *file, const name_t dict)</div>
<div class="line"><span class="keywordtype">bool</span> name_in_str(name_t dict, FILE *file)</div>
<div class="line">m_serial_return_code_t name_out_serial(m_serial_write_t serial, const name_t container)</div>
<div class="line">m_serial_return_code_t name_in_str(name_t container, m_serial_read_t serial)</div>
<div class="line"><span class="keywordtype">bool</span> name_equal_p(const name_t dict1, const name_t dict2)</div>
<div class="line"><span class="keywordtype">void</span> name_emplace[suffix](name_t container, keyargs...) [for dictionary set */</div>
<div class="line"><span class="keywordtype">void</span> name_emplace_key[keysuffix]_val[valsuffix](name_t container, keyargs..., valargs...) <span class="comment">/* for associative array */</span></div>
<div class="line"><span class="keywordtype">void</span> name_reserve(name_t dict, <span class="keywordtype">size_t</span> capacity)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md183"></a>
Specialized methods</h3>
<p>The following specialized methods are automatically created by the previous definition macro:</p>
<h4><a class="anchor" id="autotoc_md184"></a>
&lt;tt&gt;void name_splice(name_t dict1, name_t dict2)&lt;/tt&gt;</h4>
<p>Move all items from <code>dict2</code> into <code>dict1</code>. If there is the same key between <code>dict2</code> into <code>dict1</code>, then their values are added (as per the <code>ADD</code> method of the value type). Afterward <code>dict2</code> is reset (i.e. empty). This method is only defined if the value type defines an <code>ADD</code> method.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md185"></a>
M-TUPLE</h2>
<p>A <a href="https://en.wikipedia.org/wiki/Tuple">tuple</a> is a finite ordered list of elements of different types.</p>
<h3><a class="anchor" id="autotoc_md186"></a>
&lt;tt&gt;TUPLE_DEF2(name, (element1, type1[, oplist1]) [, ...])&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md187"></a>
&lt;tt&gt;TUPLE_DEF2_AS(name,  name_t, (element1, type1[, oplist1]) [, ...])&lt;/tt&gt;</h3>
<p><code>TUPLE_DEF2</code> defines the tuple <code>name_t</code> and its associated methods as <code>static inline</code> functions. Each parameter of the macro is expected to be an element of the tuple. Each element is defined by three parameters within parenthesis:</p>
<ul>
<li>the element name (the field name of the structure)</li>
<li>the element type (the associated type)</li>
<li>and the optional element oplist associated to this type (see generic interface for the behavior if it is absent)</li>
</ul>
<p><code>name</code> and <code>element</code> shall be C identifiers that will be used to identify the container and the fields.</p>
<p>It will be used to create all the types (including the iterator) and functions to handle the container. This definition shall be done once per name and per compilation unit.</p>
<p>This is more or less a C structure. The main added value compared to using a C struct is that it generates also all the basic methods to handle it which is quite handy.</p>
<p>The oplist shall have at least the following operators (<code>INIT_SET</code>, <code>SET</code> and <code>CLEAR</code>), otherwise it won't generate compilable code.</p>
<p>In general, an optional method of the tuple will only be created if all oplists define the needed optional methods for the underlying type.</p>
<p>The <code>_hash</code> (resp. <code>_equal_p</code> and <code>_cmp</code>) method is an exception. This method is created only if at least one oplist of the tuple defines the <code>HASH</code> (resp. <code>EQUAL</code>) method. You can disable the use of a specific field for the hash computation of the tuple by disabling the <code>HASH</code> operator of such field (with <code>HASH(0)</code> in its oplist), in which case it is coherent to also disable the <code>EQUAL</code> operator too. Resp., you can disable the use of a field for the equality of the tuple by disabling the <code>EQUAL</code> operator of such field (with <code>EQUAL(0)</code> in its oplist)</p>
<p>The comparison of two tuples uses lexicographic order of the fields defining the <code>CMP</code> method. It is created only if at least one oplist of the tuple define <code>CMP</code> method. You can disable the use of a field for the comparison of the tuple by disabling the <code>CMP</code> operator of such field (with <code>CMP(0)</code> in its oplist)</p>
<p><code>TUPLE_DEF2_AS</code> is the same as <code>TUPLE_DEF2</code> except the name of the type <code>name_t</code> is provided.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gmp.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;m-string.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;m-tuple.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define MPZ_OUT_STR(stream, x) mpz_out_str(stream, 0, x)</span></div>
<div class="line">TUPLE_DEF2(pair, (key_field, string_t, STRING_OPLIST),     \</div>
<div class="line">    (value_field, mpz_t, M_OPEXTEND(M_CLASSIC_OPLIST(mpz), \</div>
<div class="line">        OUT_STR(MPZ_OUT_STR))))</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">  pair_t p1;</div>
<div class="line">  pair_init (p1);</div>
<div class="line">  string_set_str(p1-&gt;key_field, <span class="stringliteral">&quot;HELLO&quot;</span>);</div>
<div class="line">  mpz_set_str(p1-&gt;value_field, <span class="stringliteral">&quot;1742&quot;</span>, 10);</div>
<div class="line">  printf(<span class="stringliteral">&quot;The pair is &quot;</span>);</div>
<div class="line">  pair_out_str(stdout, p1);</div>
<div class="line">  printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">  pair_clear(p1);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md188"></a>
&lt;tt&gt;TUPLE_OPLIST(name, oplist1[, ...] )&lt;/tt&gt;</h3>
<p>Return the oplist of the tuple defined by calling <code>TUPLE_DEF2</code> with the given <code>name</code> and the <code>oplist</code>.</p>
<h3><a class="anchor" id="autotoc_md189"></a>
Created types</h3>
<p>The following type is automatically defined by the previous definition macro if not provided by the user:</p>
<h3><a class="anchor" id="autotoc_md190"></a>
&lt;tt&gt;name_t&lt;/tt&gt;</h3>
<p>Type of the defined tuple.</p>
<h3><a class="anchor" id="autotoc_md191"></a>
Generic methods</h3>
<p>The following methods of the generic interface are defined (See generic interface for details):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> name_init(name_t tuple)</div>
<div class="line"><span class="keywordtype">void</span> name_init_set(name_t tuple, <span class="keyword">const</span> name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_set(name_t tuple, <span class="keyword">const</span> name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_init_move(name_t tuple, name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_move(name_t tuple, name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_clear(name_t tuple)</div>
<div class="line"><span class="keywordtype">void</span> name_reset(name_t tuple)</div>
<div class="line"><span class="keywordtype">void</span> name_get_str(string_t str, <span class="keyword">const</span> name_t tuple, <span class="keywordtype">bool</span> append)</div>
<div class="line"><span class="keywordtype">bool</span> name_parse_str(name_t tuple, <span class="keyword">const</span> <span class="keywordtype">char</span> str[], <span class="keyword">const</span> <span class="keywordtype">char</span> **endp)</div>
<div class="line"><span class="keywordtype">void</span> name_out_str(FILE *file, <span class="keyword">const</span> name_t tuple)</div>
<div class="line"><span class="keywordtype">bool</span> name_in_str(name_t tuple, FILE *file)</div>
<div class="line">m_serial_return_code_t name_out_serial(m_serial_write_t serial, <span class="keyword">const</span> name_t container)</div>
<div class="line">m_serial_return_code_t name_in_str(name_t container, m_serial_read_t serial)</div>
<div class="line"><span class="keywordtype">size_t</span> name_hash(<span class="keyword">const</span> name_t tuple)</div>
<div class="line"><span class="keywordtype">int</span> name_equal_p(<span class="keyword">const</span> name_t tuple1, <span class="keyword">const</span> name_t tuple2)</div>
<div class="line"><span class="keywordtype">int</span> name_cmp(<span class="keyword">const</span> name_t tuple1, <span class="keyword">const</span> name_t tuple2)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md192"></a>
Specialized methods</h3>
<p>The following specialized methods are automatically created by the previous definition macro:</p>
<h4><a class="anchor" id="autotoc_md193"></a>
&lt;tt&gt;void name_init_emplace(name_t tuple, const type1 element1[, ...])&lt;/tt&gt;</h4>
<p>Initialize the tuple <code>tuple</code> (aka constructor) and set it to the value of the constructed tuple (<code>element1[, ...]</code>).</p>
<h4><a class="anchor" id="autotoc_md194"></a>
&lt;tt&gt;void name_emplace(name_t tuple, const type1 element1[, ...])&lt;/tt&gt;</h4>
<p>Set the tuple <code>tuple</code> to the value of the tuple constructed with (<code>element1[, ...]</code>).</p>
<h4><a class="anchor" id="autotoc_md195"></a>
&lt;tt&gt;const type1 *name_cget_at_element1(const name_t tuple)&lt;/tt&gt;</h4>
<p>Return a constant pointer to the element <code>element1</code> of the tuple. There is as many methods as there are elements.</p>
<h4><a class="anchor" id="autotoc_md196"></a>
&lt;tt&gt;type1 *name_get_at_element1(const name_t tuple)&lt;/tt&gt;</h4>
<p>Return a pointer to the element <code>element1</code> of the tuple. There is as many methods as there are elements.</p>
<h4><a class="anchor" id="autotoc_md197"></a>
&lt;tt&gt;void name_set_element1(name_t tuple, type1 element1)&lt;/tt&gt;</h4>
<p>Set the element of the tuple to <code>element1</code> There is as many methods as there are elements.</p>
<h4><a class="anchor" id="autotoc_md198"></a>
&lt;tt&gt;int name_cmp_order(const name_t tuple1, const name_t tuple2, const int order[])&lt;/tt&gt;</h4>
<p>Compare <code>tuple1</code> to <code>tuple2</code> using the given order. <code>order</code> is a NULL terminated array of int that defines the order of comparison: an order of {1, 4, 2, 0} indicates to compare first the first field, if it is equal, to compare the fourth and so on. The third field is not compared. A negative value indicates to revert the comparison. This method is created only if all oplist of the tuple define <code>CMP</code> method.</p>
<h4><a class="anchor" id="autotoc_md199"></a>
&lt;tt&gt;int name_cmp_element1(const name_t tuple1, const name_t tuple2)&lt;/tt&gt;</h4>
<p>Compare <code>tuple1</code> to <code>tuple2</code> using only the element <code>element1</code> as reference. This method is created only if the oplist of element1 defines the <code>CMP</code> method.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md200"></a>
M-VARIANT</h2>
<p>A <a href="https://en.wikipedia.org/wiki/Variant_type">variant</a> is a finite exclusive list of elements of different types: the variant can only be equal to one element at a time.</p>
<h3><a class="anchor" id="autotoc_md201"></a>
&lt;tt&gt;VARIANT_DEF2(name, (element1, type1[, oplist1]) [, ...])&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md202"></a>
&lt;tt&gt;VARIANT_DEF2_AS(name,  name_t, (element1, type1[, oplist1]) [, ...])&lt;/tt&gt;</h3>
<p><code>VARIANT_DEF2</code> defines the variant <code>name_t</code> and its associated methods as <code>static inline</code> functions. Each parameter of the macro is expected to be an element of the variant. Each element is defined by three parameters within parenthesis:</p>
<ul>
<li>the mandatory element name,</li>
<li>the mandatory element type</li>
<li>and the optional element oplist.</li>
</ul>
<p>If an <code>OPLIST</code> is given, it shall be the one matching the associated type. <code>name</code> and <code>element&lt;n&gt;</code> shall be C identifiers that will be used to identify the variant. <code>name</code> will be used to create all the types (including the iterator) and functions to handle the container. This definition shall be done once per name and per compilation unit.</p>
<p>This is like a C union. The main added value compared to using a union is that it generates all the basic methods to handle and it dynamically identifies which element is stored within. It is also able to store an <code>EMPTY</code> state for the variant, contrary to an union (this is the state when default constructing it).</p>
<p>The oplists shall have at least the following operators (<code>INIT_SET</code>, <code>SET</code> and <code>CLEAR</code>), otherwise it won't generate compilable code. In general, an optional method of the variant will only be created if all oplists define the needed optional methods for the underlying type.</p>
<p><code>VARIANT_DEF2_AS</code> is the same as <code>VARIANT_DEF2</code> except the name of the type <code>name_t</code> is provided.</p>
<p><code>name_parse_str</code> and <code>name_in_str</code> depend also on the <code>INIT</code> operator.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;m-string.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;m-variant.h&quot;</span></div>
<div class="line"> </div>
<div class="line">VARIANT_DEF2(item,</div>
<div class="line">             (name, string_t),</div>
<div class="line">             (age, <span class="keywordtype">long</span>))</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">  item_t p1;</div>
<div class="line">  item_init (p1);</div>
<div class="line">  item_set_name(p1, STRING_CTE(<span class="stringliteral">&quot;HELLO&quot;</span>));</div>
<div class="line">  printf(<span class="stringliteral">&quot;The variant is &quot;</span>);</div>
<div class="line">  item_out_str(stdout, p1);</div>
<div class="line">  printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  item_set_age(p1, 43);</div>
<div class="line">  printf(<span class="stringliteral">&quot;The variant is now &quot;</span>);</div>
<div class="line">  item_out_str(stdout, p1);</div>
<div class="line">  printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">  </div>
<div class="line">  item_clear(p1);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md203"></a>
&lt;tt&gt;VARIANT_OPLIST(name, oplist1[, ...] )&lt;/tt&gt;</h3>
<p>Return the oplist of the variant defined by calling <code>VARIANT_DEF2</code> with the given <code>name</code> and the <code>oplists</code> used to generate it.</p>
<h3><a class="anchor" id="autotoc_md204"></a>
Created types</h3>
<p>The following type is automatically defined by the previous definition macro if not provided by the user:</p>
<h3><a class="anchor" id="autotoc_md205"></a>
&lt;tt&gt;name_t&lt;/tt&gt;</h3>
<p>Type of the defined variant.</p>
<h3><a class="anchor" id="autotoc_md206"></a>
Generic methods</h3>
<p>The following methods of the generic interface are defined (See generic interface for details):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> name_init(name_t variant)</div>
<div class="line"><span class="keywordtype">void</span> name_init_set(name_t variant, <span class="keyword">const</span> name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_set(name_t variant, <span class="keyword">const</span> name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_init_move(name_t variant, name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_move(name_t variant, name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_clear(name_t variant)</div>
<div class="line"><span class="keywordtype">void</span> name_reset(name_t variant)</div>
<div class="line"><span class="keywordtype">bool</span> name_empty_p(<span class="keyword">const</span> name_t variant)</div>
<div class="line"><span class="keywordtype">size_t</span> name_hash(<span class="keyword">const</span> name_t variant)</div>
<div class="line"><span class="keywordtype">bool</span> name_equal_p(<span class="keyword">const</span> name_t variant1, <span class="keyword">const</span> name_t variant2)</div>
<div class="line"><span class="keywordtype">void</span> name_swap(name_t variant1, name_t variant2)</div>
<div class="line"><span class="keywordtype">void</span> name_get_str(string_t str, name_t variant, <span class="keywordtype">bool</span> append)</div>
<div class="line"><span class="keywordtype">bool</span> name_parse_str(name_t variant, <span class="keyword">const</span> <span class="keywordtype">char</span> str[], <span class="keyword">const</span> <span class="keywordtype">char</span> **endp)</div>
<div class="line"><span class="keywordtype">void</span> name_out_str(FILE *file, name_t variant)</div>
<div class="line"><span class="keywordtype">bool</span> name_in_str(name_t variant, FILE *file)</div>
<div class="line">m_serial_return_code_t name_out_serial(m_serial_write_t serial, <span class="keyword">const</span> name_t container)</div>
<div class="line">m_serial_return_code_t name_in_str(name_t container, m_serial_read_t serial)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md207"></a>
Specialized methods</h3>
<p>The following specialized methods are automatically created by the previous definition macro:</p>
<h4><a class="anchor" id="autotoc_md208"></a>
&lt;tt&gt;void name_init_elementN(name_t variant)&lt;/tt&gt;</h4>
<p>Initialize the variant <code>variant</code> to the type of <code>element1</code> [constructor] using the default constructor of this element. This method is defined if all methods define an <code>INIT</code> method.</p>
<h4><a class="anchor" id="autotoc_md209"></a>
&lt;tt&gt;void name_init_set_elementN(name_t variant, const typeN elementN)&lt;/tt&gt;</h4>
<p>Initialize the variant <code>variant</code> and set it to the type and value of <code>elementN</code> [constructor]</p>
<h4><a class="anchor" id="autotoc_md210"></a>
&lt;tt&gt;void name_move_elementN(name_t variant, typeN ref)&lt;/tt&gt;</h4>
<p>Set the variant <code>variant</code> by stealing as many resources from <code>ref</code> as possible. Afterwards <code>ref</code> is cleared (destructor) This method is created only if all oplist of the variant define <code>MOVE</code> method.</p>
<h4><a class="anchor" id="autotoc_md211"></a>
&lt;tt&gt;void name_set_elementN(name_t variant, const typeN elementN)&lt;/tt&gt;</h4>
<p>Set the variant <code>variant</code> to the type and value of <code>elementN</code>.</p>
<h4><a class="anchor" id="autotoc_md212"></a>
&lt;tt&gt;const typeN *name_cget_at_elementN(name_t variant)&lt;/tt&gt;</h4>
<p>Return a pointer to the <code>variant</code> viewed as of type <code>typeN</code>. If the variant isn't an object of such type, it returns NULL.</p>
<h4><a class="anchor" id="autotoc_md213"></a>
&lt;tt&gt;typeN *name_get_at_elementN(name_t variant)&lt;/tt&gt;</h4>
<p>Return a pointer to the <code>variant</code> viewed as of type <code>typeN</code>. If the variant isn't an object of such type, it returns NULL.</p>
<h4><a class="anchor" id="autotoc_md214"></a>
&lt;tt&gt;bool name_elementN_p(const name_t variant)&lt;/tt&gt;</h4>
<p>Return true if the variant is of the type of <code>elementN</code>.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md215"></a>
M-RBTREE</h2>
<p>A binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child. A node without any child is called a leaf. It can be seen as an ordered set.</p>
<p>A R-B Tree is a tree where all elements are also totally ordered, and the worst-case of any operation is in logarithm of the number of elements in the tree. The current implementation is <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">RED-BLACK TREE</a> which provides performance guarantee for both insertion and lockup operations. It has not to be confused with a <a href="https://en.wikipedia.org/wiki/B-tree">B-TREE</a>.</p>
<h3><a class="anchor" id="autotoc_md216"></a>
&lt;tt&gt;RBTREE_DEF(name, type[, oplist])&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md217"></a>
&lt;tt&gt;RBTREE_DEF_AS(name,  name_t, name_it_t, type[, oplist])&lt;/tt&gt;</h3>
<p>RBTREE_DEF defines the binary ordered tree <code>name_t</code> and its associated methods as <code>static inline</code> functions. <code>name</code> shall be a C identifier that will be used to identify the R-B Tree. It will be used to create all the types (including the iterator) and functions to handle the container. This definition shall be done once per name and per compilation unit.</p>
<p>The <code>CMP</code> operator is used to perform the total ordering of the elements.</p>
<p>The oplist shall have at least the following operators (<code>INIT</code>, <code>INIT_SET</code>, <code>SET</code>, <code>CLEAR</code> &amp; <code>CMP</code>), otherwise it won't generate compilable code.</p>
<p>Some methods may return a modifiable pointer to the found element (for example, <code>_get</code>). In this case, the user shall not modify the key order of the element, as there is no reordering of the tree in this case.</p>
<p>A push method on the tree will put the given <code>key</code> in its right place in the tree by keeping the tree ordered. It overwrites the already existing value if the key is already present in the dictionary (contrary to C++).</p>
<p><code>RBTREE_DEF_AS</code> is the same as <code>RBTREE_DEF2</code> except the name of the types <code>name_t</code>, <code>name_it_t</code> are provided by the user.</p>
<p>Example:</p>
<div class="fragment"><div class="line">RBTREE_DEF(rbtree_uint, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)</div>
<div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num) {</div>
<div class="line">        rbtree_uint_t tree;</div>
<div class="line">        rbtree_uint_init(tree);</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; num; i++)</div>
<div class="line">                rbtree_uint_push(tree, i);</div>
<div class="line">        rbtree_uint_clear(tree);                              </div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md218"></a>
&lt;tt&gt;RBTREE_OPLIST(name [, oplist])&lt;/tt&gt;</h3>
<p>Return the oplist of the Red-Black tree defined by calling <code>RBTREE_DEF</code> with <code>name</code> and <code>oplist</code>. If there is no given oplist, the basic oplist for basic C types is used.</p>
<h3><a class="anchor" id="autotoc_md219"></a>
Created types</h3>
<p>The following types are automatically defined by the previous definition macro with <code>name</code> if not provided by the user:</p>
<h4><a class="anchor" id="autotoc_md220"></a>
&lt;tt&gt;name_t&lt;/tt&gt;</h4>
<p>Type of the Red Black Tree.</p>
<h4><a class="anchor" id="autotoc_md221"></a>
&lt;tt&gt;name_it_t&lt;/tt&gt;</h4>
<p>Type of an iterator over this Red Black Tree.</p>
<h3><a class="anchor" id="autotoc_md222"></a>
Generic methods</h3>
<p>The following methods of the generic interface are defined (See generic interface for details):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> name_init(name_t rbtree)</div>
<div class="line"><span class="keywordtype">void</span> name_clear(name_t rbtree)</div>
<div class="line"><span class="keywordtype">void</span> name_init_set(name_t rbtree, <span class="keyword">const</span> name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_set(name_t rbtree, <span class="keyword">const</span> name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_init_move(name_t rbtree, name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_move(name_t rbtree, name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_reset(name_t rbtree)</div>
<div class="line"><span class="keywordtype">size_t</span> name_size(<span class="keyword">const</span> name_t rbtree)</div>
<div class="line"><span class="keywordtype">void</span> name_push(name_t rbtree, <span class="keyword">const</span> type data)</div>
<div class="line"><span class="keywordtype">void</span> name_emplace[suffix](name_t rbtree, args...)</div>
<div class="line">type *name_get(const name_t rbtree, const type data)</div>
<div class="line">const type *name_cget(const name_t rbtree, const type data)</div>
<div class="line"><span class="keywordtype">void</span> name_swap(name_t rbtree1, name_t rbtree2)</div>
<div class="line"><span class="keywordtype">bool</span> name_empty_p(const name_t rbtree)</div>
<div class="line"><span class="keywordtype">void</span> name_it(name_it_t it, name_t rbtree)</div>
<div class="line"><span class="keywordtype">void</span> name_it_set(name_it_t it, const name_it_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_it_last(name_it_t it, name_t rbtree)</div>
<div class="line"><span class="keywordtype">void</span> name_it_end(name_it_t it, name_t rbtree)</div>
<div class="line"><span class="keywordtype">bool</span> name_end_p(const name_it_t it)</div>
<div class="line"><span class="keywordtype">bool</span> name_last_p(const name_it_t it)</div>
<div class="line"><span class="keywordtype">void</span> name_it_remove(name_t rbtree, name_it_t it)</div>
<div class="line"><span class="keywordtype">void</span> name_next(name_it_t it)</div>
<div class="line"><span class="keywordtype">void</span> name_previous(name_it_t it)</div>
<div class="line">type *name_ref(name_it_t it)</div>
<div class="line">const type *name_ref(name_it_t it)</div>
<div class="line"><span class="keywordtype">void</span> name_get_str(string_t str, const name_t rbtree, <span class="keywordtype">bool</span> append)</div>
<div class="line"><span class="keywordtype">bool</span> name_parse_str(name_t tree, const <span class="keywordtype">char</span> str[], const <span class="keywordtype">char</span> **endp)</div>
<div class="line"><span class="keywordtype">void</span> name_out_str(FILE *file, const name_t rbtree)</div>
<div class="line"><span class="keywordtype">bool</span> name_in_str(name_t rbtree, FILE *file)</div>
<div class="line">m_serial_return_code_t name_out_serial(m_serial_write_t serial, const name_t container)</div>
<div class="line">m_serial_return_code_t name_in_str(name_t container, m_serial_read_t serial)</div>
<div class="line"><span class="keywordtype">bool</span> name_equal_p(const name_t rbtree1, const name_t rbtree2)</div>
<div class="line"><span class="keywordtype">size_t</span> name_hash(const name_t rbtree)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md223"></a>
Specialized methods</h3>
<p>The following specialized methods are automatically created by the previous definition macro:</p>
<h4><a class="anchor" id="autotoc_md224"></a>
&lt;tt&gt;void name_pop(type *dest, name_t rbtree, const type data)&lt;/tt&gt;</h4>
<p>Pop <code>data</code> from the Red Black Tree <code>rbtree</code> and save the popped value into <code>dest</code> if the pointer is not null while keeping the tree balanced. Do nothing if <code>data</code> is no present in the Red Black Tree.</p>
<h4><a class="anchor" id="autotoc_md225"></a>
&lt;tt&gt;type * name_min(const name_t rbtree)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md226"></a>
&lt;tt&gt;const type * name_cmin(const name_t rbtree)&lt;/tt&gt;</h4>
<p>Return a pointer to the minimum element of the tree or NULL if there is no element.</p>
<h4><a class="anchor" id="autotoc_md227"></a>
&lt;tt&gt;type * name_max(const name_t rbtree)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md228"></a>
&lt;tt&gt;const type * name_cmax(const name_t rbtree)&lt;/tt&gt;</h4>
<p>Return a pointer to the maximum element of the tree or NULL if there is no element.</p>
<h4><a class="anchor" id="autotoc_md229"></a>
&lt;tt&gt;void name_it_from(name_it_t it, const name_t rbtree, const type data)&lt;/tt&gt;</h4>
<p>Set the iterator <code>it</code> to the lowest element of the tree <code>rbtree</code> greater or equal than <code>data</code> or an iterator to no element is there is none.</p>
<h4><a class="anchor" id="autotoc_md230"></a>
&lt;tt&gt;bool name_it_until_p(const name_it_t it, const type data)&lt;/tt&gt;</h4>
<p>Return true if <code>it</code> references an element that is greater or equal than <code>data</code> or if it references no longer a valid element, false otherwise.</p>
<h4><a class="anchor" id="autotoc_md231"></a>
&lt;tt&gt;bool name_it_while_p(const name_it_t it, const type data)&lt;/tt&gt;</h4>
<p>Return true if <code>it</code> references an element that is lower or equal than <code>data</code>. Otherwise (or if it references no longer a valid element) it returns false.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md232"></a>
M-BPTREE</h2>
<p>A <a href="https://en.wikipedia.org/wiki/B%2B_tree">B+TREE</a> is a variant of <a href="https://en.wikipedia.org/wiki/B-tree">BTREE</a> that itself is a generalization of <a href="https://en.wikipedia.org/wiki/Binary_tree">Binary Tree</a>.</p>
<p>A B+TREE is an N-ary tree with a variable but often large number of children per node. It is mostly used for handling slow media by file system and database.</p>
<p>It provides a fully sorted container enabling fast access to individual item or range of items, and as such is concurrent to Red-Black Tree. On modern architecture, a B+TREE is typically faster than a red-black tree due to being more cache friendly (The RAM itself can be considered as a slow media nowadays!)</p>
<p>When defining a B+TREE it is necessary to give the type of the item within, but also the maximum number of child per node (<code>N</code>). The best maximum number of child per node depends on the type itself (its size, its compare cost) and the cache of the processor.</p>
<h3><a class="anchor" id="autotoc_md233"></a>
&lt;tt&gt;BPTREE_DEF2(name, N, key_type, key_oplist, value_type, value_oplist)&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md234"></a>
&lt;tt&gt;BPTREE_DEF2_AS(name,  name_t, name_it_t, name_itref_t, N, key_type, key_oplist, value_type, value_oplist)&lt;/tt&gt;</h3>
<p>Define the B+TREE tree of rank <code>N</code> <code>name_t</code> and its associated methods as <code>static inline</code> functions. This B+TREE will be created as an associative array of the <code>key_type</code> to the <code>value_type</code>.</p>
<p>The <code>CMP</code> operator is used to perform the total ordering of the key elements.</p>
<p><code>N</code> is the number of items per node and shall be greater or equal than 2.</p>
<p>It shall be done once per type and per compilation unit. It also define the iterator <code>name##_it_t</code> and its associated methods as <code>static inline</code> functions.</p>
<p>The object oplist shall have at least the operators (<code>INIT</code>, <code>INIT_SET</code>, <code>SET</code>, <code>CLEAR</code> and <code>CMP</code>).</p>
<p><code>BPTREE_DEF2_AS</code> is the same as <code>BPTREE_DEF2</code> except the name of the container type <code>name_t</code>, the iterator type <code>name_it_t</code>, and the iterated object type <code>name_itref_t</code> are provided by the user.</p>
<p>Example:</p>
<div class="fragment"><div class="line">BPTREE_DEF2(tree_uint, 4, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, (), <span class="keywordtype">float</span>, ())</div>
<div class="line">void f(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num) {</div>
<div class="line">        tree_uint_t tree;</div>
<div class="line">        tree_uint_init(tree);</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; num; i++)</div>
<div class="line">                tree_uint_set_at(tree, i, (<span class="keywordtype">float</span>) i);</div>
<div class="line">        tree_uint_clear(tree);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md235"></a>
&lt;tt&gt;BPTREE_OPLIST2(name, key_oplist, value_oplist)&lt;/tt&gt;</h3>
<p>Return the oplist of the <code>BPTREE</code> defined by calling <code>BPTREE_DEF2</code> with <code>name</code>, <code>key_oplist</code> and <code>value_oplist</code>.</p>
<h3><a class="anchor" id="autotoc_md236"></a>
&lt;tt&gt;BPTREE_DEF(name, N, key_type[, key_oplist])&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md237"></a>
&lt;tt&gt;BPTREE_DEF_AS(name,  name_t, name_it_t, name_itref_t, N, key_type, key_oplist)&lt;/tt&gt;</h3>
<p>Define the B+TREE tree of rank <code>N</code> <code>name_t</code> and its associated methods as <code>static inline</code> functions. This B+TREE will be created as an ordered set of <code>key_type</code>.</p>
<p>The <code>CMP</code> operator is used to perform the total ordering of the key elements.</p>
<p><code>N</code> is the number of items per node and shall be greater or equal than 2.</p>
<p>It shall be done once per type and per compilation unit. It also define the iterator <code>name##_it_t</code> and its associated methods as <code>static inline</code> functions.</p>
<p>The object oplist shall have at least the operators (<code>INIT</code>, <code>INIT_SET</code>, <code>SET</code>, <code>CLEAR</code> and <code>CMP</code>).</p>
<p><code>BPTREE_DEF_AS</code> is the same as <code>BPTREE_DEF</code> except the name of the container type <code>name_t</code>, the iterator type <code>name_it_t</code> and the iterated object type <code>name_itref_t</code> are provided by the user.</p>
<p>Example:</p>
<div class="fragment"><div class="line">BPTREE_DEF(tree_uint, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)</div>
<div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num) {</div>
<div class="line">        tree_uint_t tree;</div>
<div class="line">        tree_uint_init(tree);</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; num; i++)</div>
<div class="line">                tree_uint_push(tree, i);</div>
<div class="line">        tree_uint_clear(tree);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md238"></a>
&lt;tt&gt;BPTREE_OPLIST(name[, key_oplist])&lt;/tt&gt;</h3>
<p>Return the oplist of the <code>BPTREE</code> defined by calling <code>BPTREE_DEF</code> with <code>name</code> and <code>key_oplist</code>. If there is no given oplist, the basic oplist for basic C types is used.</p>
<h3><a class="anchor" id="autotoc_md239"></a>
&lt;tt&gt;BPTREE_MULTI_DEF2(name, N, key_type, key_oplist, value_type, value_oplist)&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md240"></a>
&lt;tt&gt;BPTREE_MULTI_DEF2_AS(name,  name_t, name_it_t, name_itref_t, N, key_type, key_oplist, value_type, value_oplist)&lt;/tt&gt;</h3>
<p>Define the B+TREE tree of rank <code>N</code> <code>name_t</code> and its associated methods as <code>static inline</code> functions. This B+TREE will be created as an associative array of the <code>key_type</code> to the <code>value_type</code> and allows multiple instance of the same key in the tree (aka it is a multi-map: re-adding the same key in the tree will add a new instance of the key in the tree rather than update the value associated to the key).</p>
<p>See <code>BPTREE_DEF2</code> for additional details and example.</p>
<p><code>BPTREE_MULTI_DEF2_AS</code> is the same as <code>BPTREE_MULTI_DEF2</code> except the name of the types <code>name_t</code>, <code>name_it_t</code>, <code>name_itref_t</code> are provided by the user.</p>
<h3><a class="anchor" id="autotoc_md241"></a>
&lt;tt&gt;BPTREE_MULTI_DEF(name, N, key_type[, key_oplist])&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md242"></a>
&lt;tt&gt;BPTREE_MULTI_DEF_AS(name,  name_t, name_it_t, name_itref_t, N, key_type, key_oplist)&lt;/tt&gt;</h3>
<p>Define the B+TREE tree of rank <code>N</code> <code>name_t</code> and its associated methods as <code>static inline</code> functions. This B+TREE will be created as an ordered set of <code>key_type</code> and allows multiple instance of the same key in the tree (aka it is a multi set: re-adding the same key in the tree will add a new instance of the key in the tree rather than update the key value).</p>
<p>See <code>BPTREE_DEF</code> for additional details and example.</p>
<p><code>BPTREE_MULTI_DEF_AS</code> is the same as <code>BPTREE_MULTI_DEF</code> except the name of the types <code>name_t</code>, <code>name_it_t</code>, <code>name_itref_t</code> are provided by the user.</p>
<h3><a class="anchor" id="autotoc_md243"></a>
Created types</h3>
<p>The following types are automatically defined by the previous definition macro if not provided by the user:</p>
<h4><a class="anchor" id="autotoc_md244"></a>
&lt;tt&gt;name_t&lt;/tt&gt;</h4>
<p>Type of the B+Tree of <code>type</code>.</p>
<h4><a class="anchor" id="autotoc_md245"></a>
&lt;tt&gt;name_it_t&lt;/tt&gt;</h4>
<p>Type of an iterator over this B+Tree.</p>
<h4><a class="anchor" id="autotoc_md246"></a>
&lt;tt&gt;name_itref_t&lt;/tt&gt;</h4>
<p>Type of one item referenced in the B+Tree. It is either:</p>
<ul>
<li>a structure composed of a pointer to the key (field <code>key_ptr</code>) and a pointer to the value (field <code>value_ptr</code>) if the B+Tree is an associative array,</li>
<li>or the basic type of the container if the B+Tree is a set.</li>
</ul>
<h3><a class="anchor" id="autotoc_md247"></a>
Generic methods</h3>
<p>The following methods of the generic interface are defined (See generic interface for details):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> name_init(name_t tree)</div>
<div class="line"><span class="keywordtype">void</span> name_clear(name_t tree)</div>
<div class="line"><span class="keywordtype">void</span> name_init_set(name_t tree, <span class="keyword">const</span> name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_set(name_t tree, <span class="keyword">const</span> name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_init_move(name_t tree, name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_move(name_t tree, name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_reset(name_t tree)</div>
<div class="line"><span class="keywordtype">size_t</span> name_size(<span class="keyword">const</span> name_t tree)</div>
<div class="line"><span class="keywordtype">void</span> name_push(name_t tree, <span class="keyword">const</span> key_type data) [<span class="keywordflow">for</span> set definition only]</div>
<div class="line"><span class="keywordtype">void</span> name_set_at(name_t tree, <span class="keyword">const</span> key_type data, <span class="keyword">const</span> value_type val)  <span class="comment">/* for associative array definition only */</span></div>
<div class="line"><span class="keywordtype">bool</span> name_erase(name_t tree, <span class="keyword">const</span> key_type data)</div>
<div class="line">value_type *name_get(<span class="keyword">const</span> name_t tree, <span class="keyword">const</span> key_type data)</div>
<div class="line"><span class="keyword">const</span> value_type *name_cget(<span class="keyword">const</span> name_t tree, <span class="keyword">const</span> key_type data)</div>
<div class="line">value_type *name_safe_get(name_t tree, <span class="keyword">const</span> key_type data)</div>
<div class="line"><span class="keywordtype">void</span> name_swap(name_t tree1, name_t tree2)</div>
<div class="line"><span class="keywordtype">bool</span> name_empty_p(<span class="keyword">const</span> name_t tree)</div>
<div class="line"><span class="keywordtype">void</span> name_it(name_it_t it, name_t tree)</div>
<div class="line"><span class="keywordtype">void</span> name_it_set(name_it_t it, <span class="keyword">const</span> name_it_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_it_end(name_it_t it, name_t tree)</div>
<div class="line"><span class="keywordtype">bool</span> name_end_p(<span class="keyword">const</span> name_it_t it)</div>
<div class="line"><span class="keywordtype">bool</span> name_it_equal_p(<span class="keyword">const</span> name_it_t it1, <span class="keyword">const</span> name_it_t it1)</div>
<div class="line"><span class="keywordtype">void</span> name_next(name_it_t it)</div>
<div class="line">name_itref_t *name_ref(name_it_t it)</div>
<div class="line"><span class="keyword">const</span> name_itref_t *name_cref(name_it_t it)</div>
<div class="line"><span class="keywordtype">void</span> name_get_str(string_t str, <span class="keyword">const</span> name_t tree, <span class="keywordtype">bool</span> append)</div>
<div class="line"><span class="keywordtype">bool</span> name_parse_str(name_t tree, <span class="keyword">const</span> <span class="keywordtype">char</span> str[], <span class="keyword">const</span> <span class="keywordtype">char</span> **endp)</div>
<div class="line"><span class="keywordtype">void</span> name_out_str(FILE *file, <span class="keyword">const</span> name_t tree)</div>
<div class="line"><span class="keywordtype">bool</span> name_in_str(name_t tree, FILE *file)</div>
<div class="line">m_serial_return_code_t name_out_serial(m_serial_write_t serial, <span class="keyword">const</span> name_t container)</div>
<div class="line">m_serial_return_code_t name_in_str(name_t container, m_serial_read_t serial)</div>
<div class="line"><span class="keywordtype">bool</span> name_equal_p(<span class="keyword">const</span> name_t tree1, <span class="keyword">const</span> name_t tree2)</div>
<div class="line"><span class="keywordtype">size_t</span> name_hash(<span class="keyword">const</span> name_t tree)</div>
<div class="line"><span class="keywordtype">void</span> name_emplace[suffix](name_t container, keyargs...) [<span class="keywordflow">for</span> dictionary set]</div>
<div class="line"><span class="keywordtype">void</span> name_emplace_key[keysuffix]_val[valsuffix](name_t container, keyargs..., valargs...) <span class="comment">/* for associative array */</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md248"></a>
Specialized methods</h3>
<p>The following specialized methods are automatically created by the previous definition macro:</p>
<h4><a class="anchor" id="autotoc_md249"></a>
&lt;tt&gt;void name_pop(value_type *dest, name_t tree, const key_type data)&lt;/tt&gt;</h4>
<p>Pop <code>data</code> from the B+Tree <code>tree</code> and save the popped value into <code>dest</code> if the pointer is not NULL while keeping the tree balanced. Do nothing if <code>data</code> is no present in the B+Tree.</p>
<h4><a class="anchor" id="autotoc_md250"></a>
&lt;tt&gt;value_type *name_min(const name_t tree)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md251"></a>
&lt;tt&gt;const value_type *name_cmin(const name_t tree)&lt;/tt&gt;</h4>
<p>Return a pointer to the minimum element of the tree or NULL if there is no element in the B+Tree.</p>
<h4><a class="anchor" id="autotoc_md252"></a>
&lt;tt&gt;value_type *name_max(const name_t tree)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md253"></a>
&lt;tt&gt;const value_type *name_cmax(const name_t tree)&lt;/tt&gt;</h4>
<p>Return a pointer to the maximum element of the tree or NULL if there is no element in the B+Tree.</p>
<h4><a class="anchor" id="autotoc_md254"></a>
&lt;tt&gt;void name_it_from(name_it_t it, const name_t tree, const type data)&lt;/tt&gt;</h4>
<p>Set the iterator <code>it</code> to the lowest element of <code>tree</code> greater or equal than <code>data</code> or the end iterator is there is none.</p>
<h4><a class="anchor" id="autotoc_md255"></a>
&lt;tt&gt;bool name_it_until_p(const name_it_t it, const type data)&lt;/tt&gt;</h4>
<p>Return true if <code>it</code> references an element that is greater or equal than <code>data</code> or if it references no longer a valid element, false otherwise.</p>
<h4><a class="anchor" id="autotoc_md256"></a>
&lt;tt&gt;bool name_it_while_p(const name_it_t it, const type data)&lt;/tt&gt;</h4>
<p>Return true if <code>it</code> references an element that is lower or equal than <code>data</code>. Otherwise (or if it references no longer a valid element) it returns false.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md257"></a>
M-TREE</h2>
<p>A <a href="https://en.wikipedia.org/wiki/Tree_(data_structure)">tree</a> is an abstract data type to represent the hierarchic nature of a structure with a set of connected nodes. Each node in the tree can be connected to many children, but must be connected to exactly one parent, except for the root node, which has no parent.</p>
<h3><a class="anchor" id="autotoc_md258"></a>
&lt;tt&gt;TREE_DEF(name, type [, oplist])&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md259"></a>
&lt;tt&gt;TREE_DEF_AS(name,  name_t, name_it_t, type [, oplist])&lt;/tt&gt;</h3>
<p>Define the tree <code>name_t</code> and its associated methods as <code>static inline</code> functions. The tree will be composed of object of type <code>type</code>, connected each other.</p>
<p><code>name</code> shall be a C identifier that will be used to identify the tree. It will be used to create all the types (including the iterator) and functions to handle the container. This definition shall be done once per name and per compilation unit.</p>
<p>Any insert (resp. remove) in the tree shall specific the insertion point (resp. deleting point). To construct a tree, you start by creating the root node (using the <code>_set_root</code> method) and then insert new nodes from there. Each insertion of node in the tree will return an iterator of the inserted node. This can be used to construct quickly a full tree.</p>
<p>The oplist shall have at least the following operators (<code>INIT_SET</code> &amp; <code>CLEAR</code>), otherwise it won't generate compilable code.</p>
<p>The tree handles its own pool of nodes for the nodes. It is called the capacity of the tree. This pool of nodes will increase when needed by default. However, in case of capacity increased, all the nodes of the tree may move in memory to accommodate the new need. You may also request to reserve more capacity to avoid moving the items, and disable this auto-expand feature (in which a <code>MEMORY_FAILURE</code> is raised).</p>
<p>There are several way to iterate over this container:</p>
<ul>
<li>Scan all nodes: first the parent then the children (pre-order walk).</li>
<li>Scan all nodes: first the children then the parent (post-order walk).</li>
<li>Scan the nodes of a sub-tree: first the parent then the children (pre-order walk of a sub-tree).</li>
<li>Scan the nodes of a sub-tree: first the children then the parent (post-order walk of a sub-tree).</li>
</ul>
<p>On insertion, all iterators remain valid. Except if it says otherwise, all functions accepting iterators expect a valid iterator (i.e. it references an existing node).</p>
<p><code>TRREE_DEF_AS</code> is the same as <code>TREE_DEF</code> except the name of the types <code>name_t</code>, <code>name_it_t</code> are provided.</p>
<h3><a class="anchor" id="autotoc_md260"></a>
&lt;tt&gt;TREE_OPLIST(name, [, oplist])&lt;/tt&gt;</h3>
<p>Define the oplist of the generic tree defined with <code>name</code> and potentially <code>oplist</code>. If there is no given oplist, the basic oplist for basic C types is used.</p>
<h3><a class="anchor" id="autotoc_md261"></a>
Created types</h3>
<p>The following types are automatically defined by the previous definition macro if not provided by the user:</p>
<h4><a class="anchor" id="autotoc_md262"></a>
&lt;tt&gt;name_t&lt;/tt&gt;</h4>
<p>Type of the generic tree of <code>type</code>.</p>
<h4><a class="anchor" id="autotoc_md263"></a>
&lt;tt&gt;name_it_t&lt;/tt&gt;</h4>
<p>Type of an iterator over this generic tree.</p>
<h3><a class="anchor" id="autotoc_md264"></a>
Generic methods</h3>
<p>The following methods of the generic interface are defined (See generic interface for details):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> name_init(name_t tree)</div>
<div class="line"><span class="keywordtype">void</span> name_init_set(name_t tree, <span class="keyword">const</span> name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_init_move(name_t tree, name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_set(name_t tree, <span class="keyword">const</span> name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_move(name_t tree, name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_clear(name_t tree)</div>
<div class="line"><span class="keywordtype">void</span> name_reset(name_t tree)</div>
<div class="line"><span class="keywordtype">size_t</span> name_size(<span class="keyword">const</span> name_t tree)</div>
<div class="line"><span class="keywordtype">size_t</span> name_capacity(<span class="keyword">const</span> name_t tree)</div>
<div class="line"><span class="keywordtype">void</span> name_reserve(name_t tree, <span class="keywordtype">size_t</span> capacity)</div>
<div class="line"><span class="keywordtype">bool</span> name_empty_p(<span class="keyword">const</span> name_t tree)</div>
<div class="line"><span class="keywordtype">void</span> name_swap(name_t tree1, name_t tree2)</div>
<div class="line"><span class="keywordtype">bool</span> name_equal_p(<span class="keyword">const</span> name_t tree1, <span class="keyword">const</span> name_t tree2)</div>
<div class="line"><span class="keywordtype">bool</span> name_end_p(<span class="keyword">const</span> name_it_t it)</div>
<div class="line"><span class="keywordtype">bool</span> name_it_equal_p(<span class="keyword">const</span> name_it_t it1, <span class="keyword">const</span> name_it_t it2)</div>
<div class="line"><span class="keyword">const</span> type *name_cref(name_it_t it)</div>
<div class="line">type *name_ref(name_it_t it)</div>
<div class="line"><span class="keywordtype">bool</span> name_remove(it_t it)</div>
<div class="line"><span class="keywordtype">void</span> name_get_str(string_t str, <span class="keyword">const</span> name_t tree, <span class="keywordtype">bool</span> append)</div>
<div class="line"><span class="keywordtype">bool</span> name_parse_str(name_t tree, <span class="keyword">const</span> <span class="keywordtype">char</span> str[], <span class="keyword">const</span> <span class="keywordtype">char</span> **endp)</div>
<div class="line"><span class="keywordtype">void</span> name_out_str(FILE *file, <span class="keyword">const</span> name_t tree)</div>
<div class="line"><span class="keywordtype">bool</span> name_in_str(name_t tree, FILE *file)</div>
<div class="line">m_serial_return_code_t name_out_serial(m_serial_write_t serial, <span class="keyword">const</span> name_t container)</div>
<div class="line">m_serial_return_code_t name_in_str(name_t container, m_serial_read_t serial)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md265"></a>
Specialized methods</h3>
<p>The following specialized methods are automatically created by the previous definition macro:</p>
<h4><a class="anchor" id="autotoc_md266"></a>
&lt;tt&gt;void name_lock(name_t tree, bool lock)&lt;/tt&gt;</h4>
<p>Disable the auto-resize feature of the tree (if lock is true), or enable it otherwise. By default, the feature is enabled. Locking a tree shall be done after reserving the maximum number of nodes that can be added by your tree, so that the returned pointers to the internal types won't move on inserting a new node.</p>
<h4><a class="anchor" id="autotoc_md267"></a>
&lt;tt&gt;name_it_t name_set_root(name_t tree, const type value)&lt;/tt&gt;</h4>
<p>Set the tree to a single root node and set this node to <code>value</code>.</p>
<h4><a class="anchor" id="autotoc_md268"></a>
&lt;tt&gt;name_it_t name_emplace_root[suffix](name_t tree, args...)&lt;/tt&gt;</h4>
<p>Set the tree to a single root node and set this node to the value initialized with the given args. The provided arguments shall therefore match one of the constructor provided by the <code>EMPLACE_TYPE</code> operator. See emplace chapter for more details.</p>
<h4><a class="anchor" id="autotoc_md269"></a>
&lt;tt&gt;it_t name_insert_up_raw(it_t ref)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md270"></a>
&lt;tt&gt;it_t name_insert_left_raw(it_t ref)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md271"></a>
&lt;tt&gt;it_t name_insert_right_raw(it_t ref)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md272"></a>
&lt;tt&gt;it_t name_insert_down_raw(it_t ref)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md273"></a>
&lt;tt&gt;it_t name_insert_child_raw(it_t ref)&lt;/tt&gt;</h4>
<p>Insert a node up (resp. left, right, down and down) the given referenced iterator without initializing it. It returns an iterator to the inserted node with <b>non-initialized</b> data. The first thing to do after calling this function shall be to initialize the data using the proper constructor of the object of type <code>type</code> (the pointer can be get through <code>name_ref</code>) This enables using more specialized constructor than the generic copy one. The user should use other the non <code>_raw</code> function if possible rather than this one as it is low level and error prone.</p>
<p><code>name_insert_down_raw</code> will move all children of the referenced node as children of the inserted children, whereas <code>name_insert_child_raw</code> will insert the node as the new first child of the referenced node.</p>
<h4><a class="anchor" id="autotoc_md274"></a>
&lt;tt&gt;it_t name_insert_up(it_t ref, const type value)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md275"></a>
&lt;tt&gt;it_t name_insert_left(it_t ref, const type value)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md276"></a>
&lt;tt&gt;it_t name_insert_right(it_t ref, const type value)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md277"></a>
&lt;tt&gt;it_t name_insert_down(it_t ref, const type value)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md278"></a>
&lt;tt&gt;it_t name_insert_child(it_t ref, const type value)&lt;/tt&gt;</h4>
<p>Insert a node up (resp. left, right, down and down) the given referenced iterator and initialize it with a copy of <code>value</code>. It returns an iterator to the inserted node.</p>
<p><code>name_insert_down</code> will move all children of the referenced node as children of the inserted children, whereas <code>name_insert_child</code> will insert the node as the new first child of the referenced node.</p>
<h4><a class="anchor" id="autotoc_md279"></a>
&lt;tt&gt;it_t name_move_up(it_t ref, type *value)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md280"></a>
&lt;tt&gt;it_t name_move_left(it_t ref, type *value)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md281"></a>
&lt;tt&gt;it_t name_move_right(it_t ref, type *value)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md282"></a>
&lt;tt&gt;it_t name_move_down(it_t ref, type *value)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md283"></a>
&lt;tt&gt;it_t name_move_child(it_t ref, type *value)&lt;/tt&gt;</h4>
<p>Insert a node up (resp. left, right, down and down) the given referenced iterator and initialize it with <code>value</code> by stealing as much resource from <code>value</code> as possible (and destroy <code>*value</code>) It returns an iterator to the inserted node.</p>
<p><code>name_move_down</code> will move all children of the referenced node as children of the inserted children, whereas <code>name_move_child</code> will insert the node as the new first child of the referenced node.</p>
<h4><a class="anchor" id="autotoc_md284"></a>
&lt;tt&gt;it_t name_emplace_up[suffix](it_t ref, args...)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md285"></a>
&lt;tt&gt;it_t name_emplace_left[suffix](it_t ref, args...)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md286"></a>
&lt;tt&gt;it_t name_emplace_right[suffix](it_t ref, args...)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md287"></a>
&lt;tt&gt;it_t name_emplace_down[suffix](it_t ref, args...)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md288"></a>
&lt;tt&gt;it_t name_emplace_child[suffix](it_t ref, args...)&lt;/tt&gt;</h4>
<p>Insert a node up (resp. left, right, down and down) the given referenced iterator and initialize this node to the value initialized with the given args. The provided arguments shall therefore match one of the constructor provided by the <code>EMPLACE_TYPE</code> operator. See emplace chapter for more details. It returns an iterator to the inserted node.</p>
<p><code>name_emplace_down</code> will move all children of the referenced node as children of the inserted children, whereas <code>name_emplace_child</code> will insert the node as the new first child of the referenced node.</p>
<h4><a class="anchor" id="autotoc_md289"></a>
&lt;tt&gt;type *name_up_ref(name_it_t it)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md290"></a>
&lt;tt&gt;type *name_down_ref(name_it_t it)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md291"></a>
&lt;tt&gt;type *name_left_ref(name_it_t it)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md292"></a>
&lt;tt&gt;type *name_right_ref(name_it_t it)&lt;/tt&gt;</h4>
<p>Return a pointer to the type of the node which is</p>
<ul>
<li>up the given iterator,</li>
<li>down the given iterator (i.e. the first child of the node)</li>
<li>left the given iterator,</li>
<li>right the given iterator,</li>
</ul>
<p>respectively. It returns NULL if there is no such node.</p>
<h4><a class="anchor" id="autotoc_md293"></a>
&lt;tt&gt;bool name_it_up(it_t *it)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md294"></a>
&lt;tt&gt;bool name_it_down(it_t *it)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md295"></a>
&lt;tt&gt;bool name_it_left(it_t *it)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md296"></a>
&lt;tt&gt;bool name_it_right(it_t *it)&lt;/tt&gt;</h4>
<p>Update the iterator to point to the node which is up (resp. down, left and right) the given iterator. Return true in case of success, false otherwise (as such node doesn't exist, the iterator remains unchanged).</p>
<h4><a class="anchor" id="autotoc_md297"></a>
&lt;tt&gt;bool name_root_p(const it_t it)&lt;/tt&gt;</h4>
<p>Return true if <code>it</code> references the root node, false otherwise.</p>
<h4><a class="anchor" id="autotoc_md298"></a>
&lt;tt&gt;bool name_node_p(const it_t it)&lt;/tt&gt;</h4>
<p>Return true if <code>it</code> references a non-leaf node, false otherwise.</p>
<h4><a class="anchor" id="autotoc_md299"></a>
&lt;tt&gt;bool name_leaf_p(const it_t it)&lt;/tt&gt;</h4>
<p>Return true if <code>it</code> references a leaf node, false otherwise.</p>
<h4><a class="anchor" id="autotoc_md300"></a>
&lt;tt&gt;int32_t name_degree(const it_t it)&lt;/tt&gt;</h4>
<p>Return the degree of the referenced node (aka the number of children). A leaf node has a degree of 0. This function is linear in the number of children of the node.</p>
<h4><a class="anchor" id="autotoc_md301"></a>
&lt;tt&gt;int32_t name_depth(const it_t it)&lt;/tt&gt;</h4>
<p>Return the depth of the referenced node (aka the number of nodes until reaching the root node). The root node has a depth of 0. This function is linear in the depth of the node.</p>
<h4><a class="anchor" id="autotoc_md302"></a>
&lt;tt&gt;type *name_unlink(it_t it)&lt;/tt&gt;</h4>
<p>Unlink the referenced node from the tree, so that the node is removed from the tree. All children of the removed node become children of the parent node. If the removed node is the root node, than the root node shall have only one child.</p>
<p>Return a reference to the internal type and give back ownership of the type: you shall destroy the type (using <code>CLEAR</code> or <code>MOVE</code> methods) before calling any other tree functions (as the memory area used by the node may be removed on inserting a new node)</p>
<p>You should use the remove service instead as it has the same semantics but it is safer as it perform the clear of the data.</p>
<h4><a class="anchor" id="autotoc_md303"></a>
&lt;tt&gt;void name_prune(name_it_t it)&lt;/tt&gt;</h4>
<p>Remove the referenced node including all its children. See <code>name_remove</code> for more details.</p>
<h4><a class="anchor" id="autotoc_md304"></a>
&lt;tt&gt;name_it_t name_it_end(name_t tree)&lt;/tt&gt;</h4>
<p>Return an iterator that references no valid node.</p>
<h4><a class="anchor" id="autotoc_md305"></a>
&lt;tt&gt;void name_it_set(name_it_t *it, const name_it_t ref)&lt;/tt&gt;</h4>
<p>Set the iterator <code>*it</code> to <code>ref</code>. </p><blockquote class="doxtable">
<p>&zwj;[!NOTE] You can use the <code>=</code> affectation operator of the C language to copy tree iterators too. </p>
</blockquote>
<h4><a class="anchor" id="autotoc_md306"></a>
&lt;tt&gt;name_it_t name_it(name_t tree)&lt;/tt&gt;</h4>
<p>Return an iterator of the tree that will iterator on the tree in global pre-order walk (the root).</p>
<h4><a class="anchor" id="autotoc_md307"></a>
&lt;tt&gt;void name_next(name_it_t *it)&lt;/tt&gt;</h4>
<p>Update the iterator of the tree so that it references the next node in a global pre-order walk, or set it to invalid if the walk is finished.</p>
<h4><a class="anchor" id="autotoc_md308"></a>
&lt;tt&gt;name_it_t name_it_post(name_t tree)&lt;/tt&gt;</h4>
<p>Return an iterator of the tree that will iterator on the tree in global post-order walk</p>
<h4><a class="anchor" id="autotoc_md309"></a>
&lt;tt&gt;void name_next_post(name_it_t *it)&lt;/tt&gt;</h4>
<p>Update the iterator of the tree so that it references the next node in a global post-order walk, or set it to invalid if the walk is finished.</p>
<h4><a class="anchor" id="autotoc_md310"></a>
&lt;tt&gt;name_it_t name_it_subpre(name_t tree, const name_it_t ref)&lt;/tt&gt;</h4>
<p>Return an iterator of the tree that will iterator on the tree in pre-order walk of the child nodes of the referenced one.</p>
<h4><a class="anchor" id="autotoc_md311"></a>
&lt;tt&gt;void name_next_subpre(name_it_t it, const name_it_t ref)&lt;/tt&gt;</h4>
<p>Update the iterator of the tree so that it references the next node in a local pre-order walk of the child nodes of the referenced one, or set it to invalid if the walk is finished (the sub tree is fully scanned).</p>
<p>The referenced iterator shall be the same as the one used to create the updated iterator (with <code>name_it_subpre</code>).</p>
<h4><a class="anchor" id="autotoc_md312"></a>
&lt;tt&gt;name_it_t name_it_subpost(name_t tree, const name_it_t ref)&lt;/tt&gt;</h4>
<p>Return an iterator of the tree that will iterator on the tree in post-order walk of the child nodes of the referenced one.</p>
<h4><a class="anchor" id="autotoc_md313"></a>
&lt;tt&gt;void name_next_subpost(name_it_t it, const name_it_t ref)&lt;/tt&gt;</h4>
<p>Update the iterator of the tree so that it references the next node in a local post-order walk of the child nodes of the referenced one, or set it to invalid if the walk is finished (the sub-tree is fully scanned).</p>
<p>The referenced iterator shall be the same as the one used to create the updated iterator (with <code>name_it_subpost</code>).</p>
<h4><a class="anchor" id="autotoc_md314"></a>
&lt;tt&gt;void name_lca(name_it_t it1, name_it_t it2)&lt;/tt&gt;</h4>
<p>Compute the Lowest Common Ancestor of the two iterators. Both iterators shall belong to the same tree.</p>
<h4><a class="anchor" id="autotoc_md315"></a>
&lt;tt&gt;void name_swap_at(name_it_t it1, name_it_t it2, bool swapChild)&lt;/tt&gt;</h4>
<p>Swap the node referenced by <code>it1</code> and the node referenced by <code>it2</code> in the tree. If <code>swapChild</code> is true, the children nodes perform the swap with their parent. Otherwise, only the referenced nodes are swapped.</p>
<h4><a class="anchor" id="autotoc_md316"></a>
&lt;tt&gt;void name_sort_child(name_it_t it1)&lt;/tt&gt;</h4>
<p>Sort the child of the node referenced by <code>it1</code> in the order of the type. This method is constructed if the basic type exports the <code>CMP</code> type.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md317"></a>
M-PRIOQUEUE</h2>
<p>A <a href="https://en.wikipedia.org/wiki/Priority_queue">priority queue</a> is a queue where each element has a "priority" associated with it: an element with high priority is served before an element with low priority. It is currently implemented as a <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">heap</a>.</p>
<h3><a class="anchor" id="autotoc_md318"></a>
&lt;tt&gt;PRIOQUEUE_DEF(name, type [, oplist])&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md319"></a>
&lt;tt&gt;PRIOQUEUE_DEF_AS(name,  name_t, name_it_t, type [, oplist])&lt;/tt&gt;</h3>
<p>Define the priority queue <code>name_t</code> and its associated methods as <code>static inline</code> functions. The queue will be composed of object of type <code>type</code>.</p>
<p><code>name</code> shall be a C identifier that will be used to identify the queue. It will be used to create all the types (including the iterator) and functions to handle the container. This definition shall be done once per name and per compilation unit.</p>
<p>The <code>CMP</code> operator is used to sort the queue so that the highest priority is the minimum. The <code>EQUAL</code> operator is used to identify an item on update or remove operations. It is uncorrelated with the <code>CMP</code> operator from the point of view of this container. (i.e. <code>EQUAL() == TRUE</code> is not equivalent to <code>CMP() == 0</code> for this container)</p>
<p>This queue will push the object at the right place in the queue in function of their priority. A pop from this queue will always return the minimum of all objects within the queue (contrary to C++ which returns the maximum), and the front method will reference this object.</p>
<p>The oplist shall have at least the following operators (<code>INIT</code>, <code>INIT_SET</code>, <code>SET</code>, <code>CLEAR</code>, <code>CMP</code>), otherwise it won't generate compilable code.</p>
<p>The <code>equal_p</code>, <code>update</code> &amp; <code>erase</code> methods have a complexity of <code>O(n)</code> due to the linear search of the data and are only created if the <code>EQUAL</code> method is defined.</p>
<p>Iteration over this container won't iterate from minimum to maximum but in an implementation define way that ensures that all items are accessed.</p>
<p><code>PRIOQUEUE_DEF_AS</code> is the same as <code>PRIOQUEUE_DEF</code> except the name of the types <code>name_t</code>, <code>name_it_t</code> are provided.</p>
<h3><a class="anchor" id="autotoc_md320"></a>
&lt;tt&gt;PRIOQUEUE_OPLIST(name, [, oplist])&lt;/tt&gt;</h3>
<p>Define the oplist of the <code>PRIOQUEUE</code> defined with <code>name</code> and potentially <code>oplist</code>. If there is no given oplist, the basic oplist for basic C types is used.</p>
<h3><a class="anchor" id="autotoc_md321"></a>
Created types</h3>
<p>The following types are automatically defined by the previous definition macro if not provided by the user:</p>
<h4><a class="anchor" id="autotoc_md322"></a>
&lt;tt&gt;name_t&lt;/tt&gt;</h4>
<p>Type of the priority queue of <code>type</code>.</p>
<h4><a class="anchor" id="autotoc_md323"></a>
&lt;tt&gt;name_it_t&lt;/tt&gt;</h4>
<p>Type of an iterator over this priority queue.</p>
<h3><a class="anchor" id="autotoc_md324"></a>
Generic methods</h3>
<p>The following methods of the generic interface are defined (See generic interface for details):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> name_init(name_t queue)</div>
<div class="line"><span class="keywordtype">void</span> name_clear(name_t queue)</div>
<div class="line"><span class="keywordtype">void</span> name_init_set(name_t queue, <span class="keyword">const</span> name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_set(name_t queue, <span class="keyword">const</span> name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_init_move(name_t queue, name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_move(name_t queue, name_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_reset(name_t queue)</div>
<div class="line"><span class="keywordtype">size_t</span> name_size(<span class="keyword">const</span> name_t queue)</div>
<div class="line"><span class="keywordtype">bool</span> name_empty_p(<span class="keyword">const</span> name_t queue)</div>
<div class="line"><span class="keywordtype">void</span> name_swap(name_t queue1, name_t queue2)</div>
<div class="line"><span class="keywordtype">void</span> name_push(name_t queue, <span class="keyword">const</span> type x)</div>
<div class="line"><span class="keyword">const</span> type *name_front(name_t queue)</div>
<div class="line"><span class="keywordtype">void</span> name_pop(type *dest, name_t queue)</div>
<div class="line"><span class="keywordtype">bool</span> name_equal_p(<span class="keyword">const</span> name_t queue1, <span class="keyword">const</span> name_t queue2)</div>
<div class="line"><span class="keywordtype">bool</span> name_erase(name_t queue, <span class="keyword">const</span> type_t val)</div>
<div class="line"><span class="keywordtype">void</span> name_it(name_it_t it, name_t queue)</div>
<div class="line"><span class="keywordtype">void</span> name_it_last(name_it_t it, name_t queue)</div>
<div class="line"><span class="keywordtype">void</span> name_it_set(name_it_t it, <span class="keyword">const</span> name_it_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_it_end(name_it_t it, name_t queue)</div>
<div class="line"><span class="keywordtype">bool</span> name_end_p(<span class="keyword">const</span> name_it_t it)</div>
<div class="line"><span class="keywordtype">bool</span> name_last_p(<span class="keyword">const</span> name_it_t it)</div>
<div class="line"><span class="keywordtype">bool</span> name_it_equal_p(<span class="keyword">const</span> name_it_t it1, <span class="keyword">const</span> name_it_t it2)</div>
<div class="line"><span class="keywordtype">void</span> name_next(name_it_t it)</div>
<div class="line"><span class="keywordtype">void</span> name_previous(name_it_t it)</div>
<div class="line"><span class="keyword">const</span> type *name_cref(name_it_t it)</div>
<div class="line"><span class="keywordtype">void</span> name_get_str(string_t str, <span class="keyword">const</span> name_t queue, <span class="keywordtype">bool</span> append)</div>
<div class="line"><span class="keywordtype">bool</span> name_parse_str(name_t queue, <span class="keyword">const</span> <span class="keywordtype">char</span> str[], <span class="keyword">const</span> <span class="keywordtype">char</span> **endp)</div>
<div class="line"><span class="keywordtype">void</span> name_out_str(FILE *file, <span class="keyword">const</span> name_t queue)</div>
<div class="line"><span class="keywordtype">bool</span> name_in_str(name_t queue, FILE *file)</div>
<div class="line">m_serial_return_code_t name_out_serial(m_serial_write_t serial, <span class="keyword">const</span> name_t container)</div>
<div class="line">m_serial_return_code_t name_in_str(name_t container, m_serial_read_t serial)</div>
<div class="line"><span class="keywordtype">void</span> name_emplace[suffix](name_t queue, args...)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md325"></a>
Specialized methods</h3>
<p>The following specialized methods are automatically created by the previous definition macro:</p>
<h4><a class="anchor" id="autotoc_md326"></a>
&lt;tt&gt;void name_update(name_t queue, const type_t old_val, const type_t new_val)&lt;/tt&gt;</h4>
<p>Change the priority of the data of the priority equals to <code>old_val</code> (in <code>EQUAL</code> sense) to <code>new_val</code> (increase or decrease priority). This method has a complexity of <code>O(n)</code> (due to linear search of the data). This method is defined only if the <code>EQUAL</code> method is defined.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md327"></a>
M-BUFFER</h2>
<p>This header implements different kind of fixed circular buffer.</p>
<p>A <a href="https://en.wikipedia.org/wiki/Circular_buffer">circular buffer</a> (or ring buffer or circular queue) is a data structure using a single, bounded buffer as if its head was connected to its tail.</p>
<h3><a class="anchor" id="autotoc_md328"></a>
BUFFER_DEF(name, type, size, policy[, oplist])</h3>
<h3><a class="anchor" id="autotoc_md329"></a>
BUFFER_DEF_AS(name,  name_t, type, size, policy[, oplist])</h3>
<p>Define the buffer <code>name_t</code> and its associated methods as <code>static inline</code> functions. A buffer is a fixed circular queue implementing a queue (or stack) interface. It can be used to transfer message from multiple producer threads to multiple consumer threads. This is done internally using a mutex and conditional waits (if it is built with the <code>BUFFER_THREAD_SAFE</code> option  default)</p>
<p><code>name</code> shall be a C identifier that will be used to identify the buffer. It will be used to create all the types (including the iterator) and functions to handle the container. This definition shall be done once per name and per compilation unit.</p>
<p>The <code>size</code> parameter defined the fixed size of the queue. It can be 0. In this case, the fixed size is defined at initialization time only and the needed objects to handle the buffer are allocated at initialization time too. Otherwise the needed objects are embedded within the structure, preventing any other allocations.</p>
<p>The size of the buffer shall be lower or equal than the maximum of the type <code>int</code>.</p>
<p>Multiple additional policy can be applied to the buffer by performing a logical or of the following properties:</p>
<ul>
<li><code>BUFFER_QUEUE</code>  define a FIFO queue (default),</li>
<li><code>BUFFER_STACK</code>  define a stack (exclusive with <code>BUFFER_QUEUE</code>),</li>
<li><code>BUFFER_THREAD_SAFE</code>  define thread safe functions (default),</li>
<li><code>BUFFER_THREAD_UNSAFE</code>  define thread unsafe functions (exclusive with <code>BUFFER_THREAD_SAFE</code>),</li>
<li><code>BUFFER_PUSH_INIT_POP_MOVE</code>  change the behavior of <code>PUSH</code> to push a new initialized object, and <code>POP</code> as moving this new object into the new emplacement (this is mostly used for performance reasons or to handle properly a shared_ptr semantic). In practice, it works as if <code>POP</code> performs the initialization of the object.</li>
<li><code>BUFFER_PUSH_OVERWRITE</code>  <code>PUSH</code> overwrites the last entry if the queue is full instead of blocking,</li>
<li><code>BUFFER_DEFERRED_POP</code>  do not consider the object to be fully popped from the buffer by calling the pop method until the call to <code>pop_deferred</code> ; this enables to handle object that are in-progress of being consumed by the thread.</li>
</ul>
<p>This container is designed to be used for synchronization inter-threads of data (and the buffer variable should be a global shared one). A function tagged "thread safe" is thread safe only if the container has been generated with the <code>THREAD_SAFE</code> option.</p>
<p>The oplist shall have at least the following operators (<code>INIT_SET</code>, <code>SET</code> and <code>CLEAR</code>), otherwise it won't generate compilable code.</p>
<p>The <code>PUSH</code> and <code>POP</code> methods operate like <code>push_blocking</code> and <code>pop_blocking</code> when the blocking parameter is true.</p>
<p><code>BUFFER_DEF_AS</code> is the same as <code>BUFFER_DEF</code> except the name of the type <code>name_t</code> is provided.</p>
<p>Example:</p>
<div class="fragment"><div class="line">BUFFER_DEF(buffer_uint, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, 10, BUFFER_QUEUE|BUFFER_BLOCKING)</div>
<div class="line"> </div>
<div class="line">buffer_uint_t g_buff;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i) {</div>
<div class="line">        buffer_uint_init(g_buff, 10);</div>
<div class="line">        buffer_uint_push(g_buff, i);</div>
<div class="line">        buffer_uint_pop(&amp;i, g_buff);</div>
<div class="line">        buffer_uint_clear(g_buff);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md330"></a>
Created types</h3>
<p>The following types are automatically defined by the previous definition macro if not provided by the user:</p>
<h4><a class="anchor" id="autotoc_md331"></a>
&lt;tt&gt;name_t&lt;/tt&gt;</h4>
<p>Type of the buffer.</p>
<h3><a class="anchor" id="autotoc_md332"></a>
Generic methods</h3>
<p>The following methods of the generic interface are defined (See generic interface for details):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> name_clear(buffer_t buffer)                  <span class="comment">/* Not thread safe */</span></div>
<div class="line"><span class="keywordtype">void</span> name_reset(buffer_t buffer)                  <span class="comment">/* Thread safe */</span></div>
<div class="line"><span class="keywordtype">bool</span> name_empty_p(<span class="keyword">const</span> buffer_t buffer)          <span class="comment">/* Thread safe */</span></div>
<div class="line"><span class="keywordtype">size_t</span> name_size(<span class="keyword">const</span> buffer_t buffer)           <span class="comment">/* Thread safe */</span></div>
<div class="line"><span class="keywordtype">size_t</span> name_capacity(<span class="keyword">const</span> buffer_t buffer)       <span class="comment">/* Thread safe */</span></div>
<div class="line"><span class="keywordtype">bool</span> name_push(buffer_t buffer, <span class="keyword">const</span> type data)</div>
<div class="line"><span class="keywordtype">bool</span> name_pop(type *data, buffer_t buffer)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md333"></a>
Specialized methods</h3>
<p>The following specialized methods are automatically created by the previous definition macro:</p>
<h4><a class="anchor" id="autotoc_md334"></a>
&lt;tt&gt;void name_init(buffer_t buffer, size_t size)&lt;/tt&gt;</h4>
<p>Initialize the buffer <code>buffer</code> for <code>size</code> elements. The <code>size</code> argument shall be the same as the one used to create the buffer or the one used to create the buffer was <code>0</code>. The size of the buffer shall be lower or equal than <code>UINT_MAX</code>. This function <b>is not</b> thread safe.</p>
<h4><a class="anchor" id="autotoc_md335"></a>
&lt;tt&gt;bool name_full_p(const buffer_t buffer)&lt;/tt&gt;</h4>
<p>Return true if the buffer is full, false otherwise. This function is thread safe if the buffer was built thread safe.</p>
<h4><a class="anchor" id="autotoc_md336"></a>
&lt;tt&gt;size_t name_overwrite(const buffer_t buffer)&lt;/tt&gt;</h4>
<p>If the buffer is built with the <code>BUFFER_PUSH_OVERWRITE</code> option, this function returns the number of elements that have been overwritten and thus discarded. If the buffer was not built with the <code>BUFFER_PUSH_OVERWRITE</code> option, it returns 0.</p>
<h4><a class="anchor" id="autotoc_md337"></a>
&lt;tt&gt;bool name_push_blocking(buffer_t buffer, const type data, bool blocking)&lt;/tt&gt;</h4>
<p>Push the object <code>data</code> in the buffer <code>buffer</code>, waiting for an empty room if <code>blocking</code> is true (performing a blocking wait) Returns true if the data was pushed, false otherwise. Always return true if the buffer is blocking. This function is thread safe if the buffer was built thread safe.</p>
<h4><a class="anchor" id="autotoc_md338"></a>
&lt;tt&gt;bool name_pop_blocking(type *data, buffer_t buffer, bool blocking)&lt;/tt&gt;</h4>
<p>Pop from the buffer <code>buffer</code> into the object <code>*data</code>, waiting for a data if <code>blocking</code> is true.</p>
<p>If the buffer is built with the <code>BUFFER_PUSH_INIT_POP_MOVE</code> option, the object pointed by <code>data</code> shall be <em><b>uninitialized</b></em> as the pop function will perform a quick initialization of the object (using an <code>INIT_MOVE</code> operator) , otherwise it shall be an initialized object (the pop function will perform a <code>SET</code> operator).</p>
<p>If the buffer is built with the <code>BUFFER_DEFERRED_POP</code> option, the object is still considered being present in the queue until a call to name_pop_release.</p>
<p>Returns true if a data was popped, false otherwise. Always return true if the buffer is blocking. This function is thread safe if the buffer was built thread safe.</p>
<h4><a class="anchor" id="autotoc_md339"></a>
&lt;tt&gt;bool name_pop_release(buffer_t buffer)&lt;/tt&gt;</h4>
<p>If the buffer is built with the <code>BUFFER_DEFERRED_POP</code> option, the object being popped is considered fully release (freeing a space in the queue). Otherwise it does nothing.</p>
<h3><a class="anchor" id="autotoc_md340"></a>
&lt;tt&gt;QUEUE_MPMC_DEF(name, type, policy[, oplist])&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md341"></a>
&lt;tt&gt;QUEUE_MPMC_DEF_AS(name, name_t, type, policy[, oplist])&lt;/tt&gt;</h3>
<p>Define the MPMC queue <code>name_t</code> and its associated methods as <code>static inline</code> functions. A MPMC queue is a fixed circular queue implementing a queue (or stack) interface. It can be used to transfer message from Multiple Producer threads to Multiple Consumer threads. This queue is not strictly lock free but <a href="https://stackoverflow.com/questions/45907210/lock-free-progress-guarantees">has</a> a lot of the properties of such algorithms.</p>
<p>The size is specified only at run-time and shall be a power of 2.</p>
<p><code>name</code> shall be a C identifier that will be used to identify the queue. It will be used to create all the types (including the iterator) and functions to handle the container. This definition shall be done once per name and per compilation unit.</p>
<p>An additional policy can be applied to the buffer by performing a logical or of the following properties:</p>
<ul>
<li><code>BUFFER_QUEUE</code>  define a FIFO queue (default),</li>
<li><code>BUFFER_PUSH_INIT_POP_MOVE</code>  change the behavior of <code>PUSH</code> to push a new initialized object, and <code>POP</code> as moving this new object into the new emplacement (this is mostly used for performance reasons or to handle properly a shared_ptr semantic). In practice, it works as if <code>POP</code> performs the initialization of the object.</li>
</ul>
<p>This container is designed to be used for easy synchronization inter-threads in a context of very fast communication (the variable should be a global shared one). There should not have much more threads using this queue than they are available hardware cores due to the only partial protection on Context-switch Immunity of this structure (This can happen only if you abuse <b>massively</b> the number of threads vs the number of cores).</p>
<p>The oplist shall have at least the following operators (<code>INIT_SET</code>, <code>SET</code> and <code>CLEAR</code>), otherwise it won't generate compilable code.</p>
<p>The <code>size</code> method is thread safe but may return a size greater than the size of the queue in some race condition.</p>
<p><code>QUEUE_MPMC_DEF_AS</code> is the same as <code>QUEUE_MPMC_DEF</code> except the name of the type <code>name_t</code> is provided.</p>
<h3><a class="anchor" id="autotoc_md342"></a>
Created types</h3>
<p>The following types are automatically defined by the previous definition macro if not provided by the user:</p>
<h4><a class="anchor" id="autotoc_md343"></a>
&lt;tt&gt;name_t&lt;/tt&gt;</h4>
<p>Type of the circular queue.</p>
<h3><a class="anchor" id="autotoc_md344"></a>
Generic methods</h3>
<p>The following methods of the generic interface are defined (See generic interface for details):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> name_clear(buffer_t buffer)</div>
<div class="line"><span class="keywordtype">bool</span> name_empty_p(<span class="keyword">const</span> buffer_t buffer)    <span class="comment">/* Thread safe */</span></div>
<div class="line"><span class="keywordtype">size_t</span> name_size(<span class="keyword">const</span> buffer_t buffer)     <span class="comment">/* Thread safe */</span></div>
<div class="line"><span class="keywordtype">size_t</span> name_capacity(<span class="keyword">const</span> buffer_t buffer) <span class="comment">/* Thread safe */</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md345"></a>
Specialized methods</h3>
<p>The following specialized methods are automatically created by the previous definition macro:</p>
<h4><a class="anchor" id="autotoc_md346"></a>
&lt;tt&gt;void name_init(buffer_t buffer, size_t size)&lt;/tt&gt;</h4>
<p>Initialize the buffer <code>buffer</code> with <code>size</code> elements. The <code>size</code> argument shall be a power of two greater than 0, and less than <code>UINT_MAX</code>. This function is not thread safe.</p>
<h4><a class="anchor" id="autotoc_md347"></a>
&lt;tt&gt;bool name_full_p(const buffer_t buffer)&lt;/tt&gt;</h4>
<p>Return true if the buffer is full, false otherwise. This function is thread safe.</p>
<h4><a class="anchor" id="autotoc_md348"></a>
&lt;tt&gt;bool name_push(buffer_t buffer, const type data)&lt;/tt&gt;</h4>
<p>Push the object <code>data</code> in the buffer <code>buffer</code> if possible. Returns true if the data was pushed, false otherwise (buffer full or unlikely data race). This function is thread safe.</p>
<h4><a class="anchor" id="autotoc_md349"></a>
&lt;tt&gt;bool name_pop(type *data, buffer_t buffer)&lt;/tt&gt;</h4>
<p>Pop from the buffer <code>buffer</code> into the object <code>*data</code> if possible.</p>
<p>If the buffer is built with the <code>BUFFER_PUSH_INIT_POP_MOVE</code> option, the object pointed by <code>data</code> shall be <em><b>uninitialized</b></em> as the pop function will perform a quick initialization of the object (using an <code>INIT_MOVE</code> operator) , otherwise it shall be an initialized object (the pop function will perform a <code>SET</code> operator).</p>
<p>Returns true if a data was popped, false otherwise (buffer empty or unlikely data race). This function is thread safe.</p>
<h3><a class="anchor" id="autotoc_md350"></a>
&lt;tt&gt;QUEUE_SPSC_DEF(name, type, policy[, oplist])&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md351"></a>
&lt;tt&gt;QUEUE_SPSC_DEF_AS(name, name_t, type, policy[, oplist])&lt;/tt&gt;</h3>
<p>Define the SPSC queue <code>name_t</code> and its associated methods as <code>static inline</code> functions. A SPSC queue is a fixed circular queue implementing a queue (or stack) interface. It can be used to transfer message from a Single Producer thread to a Single Consumer thread. This is done internally using lock-free objects. It is more specialized than <code>QUEUE_MPMC_DEF</code> and as such, is faster.</p>
<p>The <code>size</code> is specified only at run-time and shall be a power of 2.</p>
<p><code>name</code> shall be a C identifier that will be used to identify the queue. It will be used to create all the types (including the iterator) and functions to handle the container. This definition shall be done once per name and per compilation unit.</p>
<p>An additional policy can be applied to the buffer by performing a logical or of the following properties:</p>
<ul>
<li><code>BUFFER_QUEUE</code>  define a FIFO queue (default),</li>
<li><code>BUFFER_PUSH_INIT_POP_MOVE</code>  change the behavior of <code>PUSH</code> to push a new initialized object, and <code>POP</code> as moving this new object into the new emplacement (this is mostly used for performance reasons or to handle properly a shared_ptr semantic). In practice, it works as if <code>POP</code> performs the initialization of the object.</li>
</ul>
<p>This container is designed to be used for easy synchronization inter-threads in a context of very fast communication (the variable should be a global shared one).</p>
<p>The oplist shall have at least the following operators (<code>INIT</code>, <code>INIT_SET</code>, <code>SET</code> and <code>CLEAR</code>), otherwise it won't generate compilable code.</p>
<p><code>QUEUE_SPSC_DEF_AS</code> is the same as <code>QUEUE_MPMC_DEF</code> except the name of the type <code>name_t</code> is provided.</p>
<h3><a class="anchor" id="autotoc_md352"></a>
Created types</h3>
<p>The following types are automatically defined by the previous definition macro if not provided by the user:</p>
<h4><a class="anchor" id="autotoc_md353"></a>
&lt;tt&gt;name_t&lt;/tt&gt;</h4>
<p>Type of the circular queue.</p>
<h3><a class="anchor" id="autotoc_md354"></a>
Generic methods</h3>
<p>The following methods of the generic interface are defined (See generic interface for details):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> name_clear(buffer_t buffer)</div>
<div class="line"><span class="keywordtype">bool</span> name_empty_p(<span class="keyword">const</span> buffer_t buffer)    <span class="comment">/* Thread safe */</span></div>
<div class="line"><span class="keywordtype">size_t</span> name_size(<span class="keyword">const</span> buffer_t buffer)     <span class="comment">/* Thread safe */</span></div>
<div class="line"><span class="keywordtype">size_t</span> name_capacity(<span class="keyword">const</span> buffer_t buffer) <span class="comment">/* Thread safe */</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md355"></a>
Specialized methods</h3>
<p>The following specialized methods are automatically created by the previous definition macro:</p>
<h4><a class="anchor" id="autotoc_md356"></a>
&lt;tt&gt;void name_init(buffer_t buffer, size_t size)&lt;/tt&gt;</h4>
<p>Initialize the buffer <code>buffer</code> with <code>size</code> elements. The <code>size</code> argument shall be a power of two greater than 0, and less than <code>UINT_MAX</code>. This function is not thread safe.</p>
<h4><a class="anchor" id="autotoc_md357"></a>
&lt;tt&gt;bool name_full_p(const buffer_t buffer)&lt;/tt&gt;</h4>
<p>Return true if the buffer is full, false otherwise. This function is thread safe.</p>
<h4><a class="anchor" id="autotoc_md358"></a>
&lt;tt&gt;bool name_push(buffer_t buffer, const type data)&lt;/tt&gt;</h4>
<p>Push the object <code>data</code> in the buffer <code>buffer</code> if possible. Returns true if the data was pushed, false otherwise (buffer full). This function is thread safe.</p>
<h4><a class="anchor" id="autotoc_md359"></a>
&lt;tt&gt;bool name_push_move(buffer_t buffer, type *data)&lt;/tt&gt;</h4>
<p>Push &amp; move the object <code>*data</code> in the buffer <code>buffer</code> if possible. Returns true if the data was pushed, false otherwise (buffer full). Afterwards <code>*data</code> is cleared (destructor) if true is returned. This function is thread safe.</p>
<h4><a class="anchor" id="autotoc_md360"></a>
&lt;tt&gt;bool name_push_force(buffer_t buffer, const type data)&lt;/tt&gt;</h4>
<p>Push the object <code>data</code> in the buffer <code>buffer</code> discarding the oldest data if needed. This function is thread safe.</p>
<h4><a class="anchor" id="autotoc_md361"></a>
&lt;tt&gt;bool name_push_bulk(buffer_t buffer, unsigned n, const type data[])&lt;/tt&gt;</h4>
<p>Push as much objects from the array <code>data</code> in the buffer <code>buffer</code> as possible, starting from the object at index 0 to the object at index <code>n-1</code>. Returns the number of objects effectively pushed (it depends on the free size of the queue) This function is thread safe.</p>
<h4><a class="anchor" id="autotoc_md362"></a>
&lt;tt&gt;bool name_pop(type *data, buffer_t buffer)&lt;/tt&gt;</h4>
<p>Pop from the buffer <code>buffer</code> into the object <code>*data</code> if possible.</p>
<p>If the buffer is built with the <code>BUFFER_PUSH_INIT_POP_MOVE</code> option, the object pointed by <code>data</code> shall be <em><b>uninitialized</b></em> as the pop function will perform a quick initialization of the object (using an <code>INIT_MOVE</code> operator) , otherwise it shall be an initialized object (the pop function will perform a <code>SET</code> operator).</p>
<p>Returns true if a data was popped, false otherwise (buffer empty or unlikely data race). This function is thread safe.</p>
<h4><a class="anchor" id="autotoc_md363"></a>
&lt;tt&gt;unsigned name_pop_bulk(unsigned n, type tab[n], buffer_t buffer)&lt;/tt&gt;</h4>
<p>Pop from the buffer <code>buffer</code> as many objects as possible to fill in <code>tab</code> and at most <code>n</code>.</p>
<p>If the buffer is built with the <code>BUFFER_PUSH_INIT_POP_MOVE</code> option, the object pointed by <code>data</code> shall be <em><b>uninitialized</b></em> as the pop function will perform a quick initialization of the object (using an <code>INIT_MOVE</code> operator) , otherwise it shall be an initialized object (the pop function will perform a <code>SET</code> operator).</p>
<p>It returns the number of objects popped. This function is thread safe.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md364"></a>
M-SNAPSHOT</h2>
<p>This header is for created snapshots.</p>
<p>A snapshot is a mechanism enabling a reader thread and a writer thread, <b>working at different speeds</b>, to exchange messages in a fast, reliable and thread safe way (the message is always passed atomically from a thread point of view) without waiting for synchronization. The consumer thread always accesses to the latest published data of the producer thread.</p>
<p>It is implemented in a fast way as the writer directly writes the message in the buffer that will be passed to the reader (avoiding copy of the buffer) and a simple exchange of index is sufficient to handle the switch.</p>
<p>This container is designed to be used for easy synchronization inter-threads.</p>
<p>This is linked to <a href="https://en.wikipedia.org/wiki/Shared_register">shared atomic register</a> in the literature and <a href="https://en.wikipedia.org/wiki/Shared_snapshot_objects">snapshot</a> names vector of such registers where each element of the vector can be updated separately. They can be classified according to the number of producers/consumers:</p>
<ul>
<li>SPSC (Single Producer, Single Consumer),</li>
<li>MPSC (Multiple Producer, Single Consumer),</li>
<li>SPMC (Single Producer, Multiple Consumer),</li>
<li>MPMC (Multiple Producer, Multiple Consumer),</li>
</ul>
<p>The provided containers by the library are designed to handle huge structure efficiently and as such deal with the memory reclamation needed to handle them. If the data you are sharing are supported by the atomic header (like bool or integer), using <code>atomic_load</code> and <code>atomic_store</code> is a much more efficient and simple way to do even in the case of MPMC.</p>
<h3><a class="anchor" id="autotoc_md365"></a>
&lt;tt&gt;SNAPSHOT_SPSC_DEF(name, type[, oplist])&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md366"></a>
&lt;tt&gt;SNAPSHOT_SPSC_DEF_AS(name, name_t, type[, oplist])&lt;/tt&gt;</h3>
<p>Define the snapshot <code>name ## _t</code> (or <code>name_t</code>) and its associated methods as <code>static inline</code> functions. Only a single reader thread and a single writer thread are supported. It is a SPSC atomic shared register. In practice, it is implemented using a triple buffer (lock-free).</p>
<p><code>name</code> shall be a C identifier that will be used to identify the snapshot. It will be used to create all the types (including the iterator) and functions to handle the container. This definition shall be done once per name and per compilation unit.</p>
<p>The oplist shall have at least the following operators (<code>INIT_SET</code>, <code>SET</code> and <code>CLEAR</code>), otherwise it won't generate compilable code.</p>
<p>Example:</p>
<div class="fragment"><div class="line">SNAPSHOT_DEF(snapshot_uint, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)</div>
<div class="line">snapshot_uint_t message;</div>
<div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i) {</div>
<div class="line">        <span class="keywordtype">unsigned</span> *p = snapshot_uint_get_write_buffer(message);</div>
<div class="line">        *p = i;</div>
<div class="line">        snapshot_uint_write(message);</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> g(<span class="keywordtype">void</span>) {</div>
<div class="line">        <span class="keywordtype">unsigned</span> *p = snapshot_uint_read(message);</div>
<div class="line">        <span class="keywordflow">return</span> *p;</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>SNAPSHOT_SPSC_DEF_AS</code> is the same as <code>SNAPSHOT_SPSC_DEF</code> except the name of the type <code>name_t</code> is provided.</p>
<h3><a class="anchor" id="autotoc_md367"></a>
Created types</h3>
<p>The following types are automatically defined by the previous definition macro if not provided by the user:</p>
<h4><a class="anchor" id="autotoc_md368"></a>
&lt;tt&gt;name_t&lt;/tt&gt;</h4>
<p>Type of the circular queue.</p>
<h3><a class="anchor" id="autotoc_md369"></a>
Generic methods</h3>
<p>The following methods of the generic interface are defined (See generic interface for details) but none is thread safe:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> name_init(snapshot_t snapshot)</div>
<div class="line"><span class="keywordtype">void</span> name_clear(snapshot_t snapshot)</div>
<div class="line"><span class="keywordtype">void</span> name_init_set(snapshot_t snapshot, <span class="keyword">const</span> snapshot_t org)</div>
<div class="line"><span class="keywordtype">void</span> name_set(snapshot_t snapshot, <span class="keyword">const</span> snapshot_t org)</div>
<div class="line"><span class="keywordtype">void</span> name_init_move(snapshot_t snapshot, snapshot_t org)</div>
<div class="line"><span class="keywordtype">void</span> name_move(snapshot_t snapshot, snapshot_t org)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md370"></a>
Specialized methods</h3>
<p>The following specialized methods are automatically created by the previous definition macro:</p>
<h4><a class="anchor" id="autotoc_md371"></a>
&lt;tt&gt;type *name_write(snapshot_t snap)&lt;/tt&gt;</h4>
<p>Publish the "in-progress" data of the snapshot <code>snap</code> so that the read thread can have access to the data. It returns the pointer to the new "in-progress" data buffer of the snapshot (which is not yet published but will be published for the next call of name_write). This function is thread-safe and performs atomic operation on the snapshot.</p>
<h4><a class="anchor" id="autotoc_md372"></a>
&lt;tt&gt;type *name_read(snapshot_t snap)&lt;/tt&gt;</h4>
<p>Get access to the last published data of the snapshot <code>snap</code>. It returns the pointer to the data. If a publication has been performed since the last call to name_read a new pointer to the data is returned. Otherwise the previous pointer is returned. This function is thread-safe and performs atomic operation on the snapshot.</p>
<h4><a class="anchor" id="autotoc_md373"></a>
&lt;tt&gt;bool name_updated_p(snapshot_t snap)&lt;/tt&gt;</h4>
<p>Return true if a new publication is available since the last time it was read. This function is thread-safe and performs atomic operation on the snapshot.</p>
<h4><a class="anchor" id="autotoc_md374"></a>
&lt;tt&gt;type *name_get_write_buffer(snapshot_t snap)&lt;/tt&gt;</h4>
<p>Return a pointer to the active "in-progress" data of the snapshot <code>snap</code>. It is the same as the last return from name_write. This function is thread-safe and performs atomic operation on the snapshot.</p>
<h4><a class="anchor" id="autotoc_md375"></a>
&lt;tt&gt;type *name_get_read_buffer(snapshot_t snap)&lt;/tt&gt;</h4>
<p>Return a pointer to the last already read published data of the snapshot <code>snap</code>. It is the same as the last return from name_read. It doesn't perform any switch of the data that has to be read. This function is thread-safe and performs atomic operation on the snapshot.</p>
<h3><a class="anchor" id="autotoc_md376"></a>
&lt;tt&gt;SNAPSHOT_SPMC_DEF(name, type[, oplist])&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md377"></a>
&lt;tt&gt;SNAPSHOT_SPMC_DEF_AS(name, name_t, type[, oplist])&lt;/tt&gt;</h3>
<p>Define the snapshot <code>name ## _t</code> (or <code>name_t</code>) and its associated methods as <code>static inline</code> functions. A snapshot is an atomic shared register where only the latest state is important and accessible: it is like a global variable of type <code>type</code> but ensuring integrity and coherency of the data across multiple threads. One single writer and multiple (<code>=N</code>) readers are supported. In practice, it is implemented using a <code>N+2</code> buffer (lock-free).</p>
<p><code>name</code> shall be a C identifier that will be used to identify the snapshot. It will be used to create all the types (including the iterator) and functions to handle the container. This definition shall be done once per name and per compilation unit.</p>
<p>The oplist shall have at least the following operators (<code>INIT</code>, <code>INIT_SET</code>, <code>SET</code> and <code>CLEAR</code>), otherwise it won't generate compilable code.</p>
<p><code>SNAPSHOT_SPMC_DEF_AS</code> is the same as <code>SNAPSHOT_SPMC_DEF</code> except the name of the type name_t is provided.</p>
<h3><a class="anchor" id="autotoc_md378"></a>
Created types</h3>
<p>The following types are automatically defined by the previous definition macro if not provided by the user:</p>
<h4><a class="anchor" id="autotoc_md379"></a>
&lt;tt&gt;name_t&lt;/tt&gt;</h4>
<p>Type of the circular queue.</p>
<h3><a class="anchor" id="autotoc_md380"></a>
Generic methods</h3>
<p>The following methods of the generic interface are defined (See generic interface for details):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> name_clear(snapshot_t snapshot)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md381"></a>
Specialized methods</h3>
<p>The following specialized methods are automatically created by the previous definition macro:</p>
<h4><a class="anchor" id="autotoc_md382"></a>
&lt;tt&gt;void name_init(snapshot_t snapshot, size_t numReaders)&lt;/tt&gt;</h4>
<p>Initialize the communication snapshot <code>snapshot</code> with <code>numReaders</code> reader threads. <code>numReaders</code> shall be less than <code>2046</code>. This function is not thread safe.</p>
<h4><a class="anchor" id="autotoc_md383"></a>
&lt;tt&gt;type *name_write(snapshot_t snap)&lt;/tt&gt;</h4>
<p>Publish the "in-progress" data of the snapshot <code>snap</code> so that the read threads can have access to the data. It returns the pointer to the new "in-progress" data buffer of the snapshot (which is not yet published but will be published for the next call of name_write). This function is thread-safe and performs atomic operation on the snapshot.</p>
<h4><a class="anchor" id="autotoc_md384"></a>
&lt;tt&gt;type *name_read_start(snapshot_t snap)&lt;/tt&gt;</h4>
<p>Get access to the last published data of the snapshot <code>snap</code>. It returns the pointer to the data. If a publication has been performed since the last call to <code>name_read_start</code> a new pointer to the data is returned. Otherwise the previous pointer is returned.</p>
<p>It marks the data has being reserved by the thread, so afterwards, using the pointer is safe until the end of the reservation. This function is thread-safe and performs atomic operation on the snapshot.</p>
<p>For each call to <code>name_read_start</code> a matching call to <code>name_read_end</code> shall be performed by the same thread before any new call to name_read_start.</p>
<h4><a class="anchor" id="autotoc_md385"></a>
&lt;tt&gt;type *name_read_end(snapshot_t snap, type *old)&lt;/tt&gt;</h4>
<p>End the reservation of the data <code>old</code>. This function is thread-safe and performs atomic operation on the snapshot.</p>
<h4><a class="anchor" id="autotoc_md386"></a>
&lt;tt&gt;type *name_get_write_buffer(snapshot_t snap)&lt;/tt&gt;</h4>
<p>Return a pointer to the active "in-progress" data of the snapshot <code>snap</code>. It is the same as the last return from name_write. This function is thread-safe and performs atomic operation on the snapshot.</p>
<h3><a class="anchor" id="autotoc_md387"></a>
&lt;tt&gt;SNAPSHOT_MPMC_DEF(name, type[, oplist])&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md388"></a>
&lt;tt&gt;SNAPSHOT_MPMC_DEF_AS(name, name_t, type[, oplist])&lt;/tt&gt;</h3>
<p>Define the snapshot <code>name ## _t</code> (or <code>name_t</code>) and its associated methods as <code>static inline</code> functions. A snapshot is an atomic shared register where only the latest state is important and accessible: it is like a global variable of type <code>type</code> but ensuring integrity and coherency of the data across multiple threads. Multiple (<code>=M</code>) writers and multiple (<code>=N</code>) readers are supported. In practice, it is implemented using a <code>M+N+2</code> buffer (lock-free) by avoiding copying the data.</p>
<p><code>name</code> shall be a C identifier that will be used to identify the snapshot. It will be used to create all the types (including the iterator) and functions to handle the container. This definition shall be done once per name and per compilation unit.</p>
<p>The oplist shall have at least the following operators (<code>INIT</code>, <code>INIT_SET</code>, <code>SET</code> and <code>CLEAR</code>), otherwise it won't generate compilable code.</p>
<p><code>SNAPSHOT_MPMC_DEF_AS</code> is the same as <code>SNAPSHOT_MPMC_DEF</code> except the name of the type name_t is provided.</p>
<h3><a class="anchor" id="autotoc_md389"></a>
Created types</h3>
<p>The following types are automatically defined by the previous definition macro if not provided by the user:</p>
<h4><a class="anchor" id="autotoc_md390"></a>
&lt;tt&gt;name_t&lt;/tt&gt;</h4>
<p>Type of the circular queue.</p>
<h3><a class="anchor" id="autotoc_md391"></a>
Generic methods</h3>
<p>The following methods of the generic interface are defined (See generic interface for details):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> name_clear(snapshot_t snapshot)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md392"></a>
Specialized methods</h3>
<h4><a class="anchor" id="autotoc_md393"></a>
&lt;tt&gt;void name_init(snapshot_t snapshot, size_t numReaders, size_t numWriters)&lt;/tt&gt;</h4>
<p>Initialize the communication snapshot <code>snapshot</code> with <code>numReaders</code> reader threads and <code>numWriters</code> writer threads. The sum of <code>numReaders</code> and <code>numWriters</code> shall be less than <code>2046</code>. This function is not thread safe.</p>
<h4><a class="anchor" id="autotoc_md394"></a>
&lt;tt&gt;type *name_write_start(snapshot_t snap)&lt;/tt&gt;</h4>
<p>Return the current "in-progress" data of the snapshot <code>snap</code> so that the writer thread can update this data. This function is thread-safe and performs atomic operation on the snapshot.</p>
<h4><a class="anchor" id="autotoc_md395"></a>
&lt;tt&gt;type *name_write_end(snapshot_t snap, type *data)&lt;/tt&gt;</h4>
<p>Mark the provided "in-progress" <code>data</code> of the snapshot <code>snap</code> as available for the reader threads: this will be the new seen data. This function is thread-safe and performs atomic operation on the snapshot.</p>
<h4><a class="anchor" id="autotoc_md396"></a>
&lt;tt&gt;type *name_read_start(snapshot_t snap)&lt;/tt&gt;</h4>
<p>Get access to the last published data of the snapshot <code>snap</code>. It returns the pointer to the data. If a publication has been performed since the last call to <code>name_read_start</code> a new pointer to the data is returned. Otherwise, the previous pointer is returned.</p>
<p>It marks the data has being reserved by the thread, so afterwards, using the pointer is safe until the end of the reservation. This function is thread-safe and performs atomic operation on the snapshot.</p>
<p>For each call to <code>name_read_start</code> a matching call to <code>name_read_end</code> shall be performed by the same thread before any new call to <code>name_read_start</code>.</p>
<h4><a class="anchor" id="autotoc_md397"></a>
&lt;tt&gt;type *name_read_end(snapshot_t snap, type *old)&lt;/tt&gt;</h4>
<p>End the reservation of the data <code>old</code>. This function is thread-safe and performs atomic operation on the snapshot.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md398"></a>
M-SHARED</h2>
<p>This header is for creating shared pointer. A <a href="https://en.wikipedia.org/wiki/Smart_pointer">shared pointer</a> is a smart pointer that retains shared ownership of an object. Several shared pointers may own the same object, sharing ownership of an object.</p>
<h3><a class="anchor" id="autotoc_md399"></a>
&lt;tt&gt;SHARED_PTR_DEF(name, type[, oplist])&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md400"></a>
&lt;tt&gt;SHARED_PTR_DEF_AS(name, name_t, type[, oplist])&lt;/tt&gt;</h3>
<p>Define the shared pointer <code>name_t</code> and its associated methods as <code>static inline</code> functions. A shared pointer is a mechanism to keep tracks of all registered users of an object and performs an automatic destruction of the object only when all users release their need on this object.</p>
<p><code>name</code> shall be a C identifier that will be used to identify the shared pointer. It will be used to create all the types (including the iterator) and functions to handle the container. This definition shall be done once per name and per compilation unit.</p>
<p>The tracking of ownership is atomic and the destruction of the object is thread safe.</p>
<p>The object oplist is expected to have at least the following operators (<code>CLEAR</code> to clear the object and <code>DEL</code> to free the allocated memory).</p>
<p>There are designed to work with buffers with policy <code>BUFFER_PUSH_INIT_POP_MOVE</code> to send a shared pointer across multiple threads.</p>
<p><code>SHARED_PTR_DEF_AS</code> is the same as <code>SHARED_PTR_DEF</code> except the name of the type <code>name_t</code> is provided.</p>
<p>Example:</p>
<div class="fragment"><div class="line">SHARED_PTR_DEF(shared_mpz, mpz_t, (CLEAR(mpz_clear)))</div>
<div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">void</span>) {</div>
<div class="line">        shared_mpz_t p;</div>
<div class="line">        mpz_t z;</div>
<div class="line">        mpz_init(z);</div>
<div class="line">        shared_mpz_init2 (p, z);</div>
<div class="line">        buffer_uint_push(g_buff1, p);</div>
<div class="line">        buffer_uint_push(g_buff2, p);</div>
<div class="line">        shared_mpz_clear(p);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md401"></a>
&lt;tt&gt;SHARED_PTR_RELAXES_DEF(name, type[, oplist])&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md402"></a>
&lt;tt&gt;SHARED_PTR_RELAXES_DEF_AS(name, name_t, type[, oplist])&lt;/tt&gt;</h3>
<p>Theses are the same as <code>SHARED_PTR_DEF</code> / <code>SHARED_PTR_DEF_AS</code> except that they are not thread safe. See <code>SHARED_PTR_DEF</code> for other details.</p>
<h3><a class="anchor" id="autotoc_md403"></a>
Created types</h3>
<p>The following types are automatically defined by the previous definition macro if not provided by the user:</p>
<h4><a class="anchor" id="autotoc_md404"></a>
&lt;tt&gt;name_t&lt;/tt&gt;</h4>
<p>Type of the shared pointer.</p>
<h3><a class="anchor" id="autotoc_md405"></a>
Specialized methods</h3>
<p>The following specialized methods are automatically created by the previous definition macro:</p>
<h4><a class="anchor" id="autotoc_md406"></a>
&lt;tt&gt;void name_init(shared_t shared)&lt;/tt&gt;</h4>
<p>Initialize the shared pointer <code>shared</code> to represent the NULL pointer (no object is therefore referenced).</p>
<h4><a class="anchor" id="autotoc_md407"></a>
&lt;tt&gt;void name_init2(shared_t shared, type *data)&lt;/tt&gt;</h4>
<p>Initialize the shared pointer <code>shared</code> to reference the object <code>*data</code> and takes ownership of this object. User code shall not use <code>*data</code> (or any pointer to it) anymore as the shared pointer gets the exclusive ownership of the object.</p>
<h4><a class="anchor" id="autotoc_md408"></a>
&lt;tt&gt;void name_init_new(shared_t shared)&lt;/tt&gt;</h4>
<p>Initialize the shared pointer <code>shared</code> to a new object of type <code>type</code>. The default constructor of type is used to initialize the object. This method is only created if the <code>INIT</code> method is provided.</p>
<h4><a class="anchor" id="autotoc_md409"></a>
&lt;tt&gt;void name_init_set(shared_t shared, const shared_t src)&lt;/tt&gt;</h4>
<p>Initialize the shared pointer <code>shared</code> to the same object than the one pointed by <code>src</code> (sharing ownership). This function is thread safe from <code>src</code> point of view.</p>
<h4><a class="anchor" id="autotoc_md410"></a>
&lt;tt&gt;void name_init_with[suffix](shared_t shared, args...)&lt;/tt&gt;</h4>
<p>Initialize the shared pointer <code>shared</code> to the new object initialized with args. The provided arguments shall therefore match one of the constructor provided by the <code>EMPLACE_TYPE</code> operator. There is one generated method per suffix defined in the <code>EMPLACE_TYPE</code> operator, and the <code>suffix</code> in the generated method name corresponds to the suffix defined in the <code>EMPLACE_TYPE</code> operator (it can be empty). This method is created only if the <code>EMPLACE_TYPE</code> operator is provided. See emplace chapter for more details. It is equivalent to the C++ make_shared.</p>
<h4><a class="anchor" id="autotoc_md411"></a>
&lt;tt&gt;bool name_NULL_p(const shared_t shared)&lt;/tt&gt;</h4>
<p>Return true if shared doesn't reference any object (i.e. is the NULL pointer).</p>
<h4><a class="anchor" id="autotoc_md412"></a>
&lt;tt&gt;void name_clear(shared_t shared)&lt;/tt&gt;</h4>
<p>Clear the shared pointer (destructor): the shared pointer loses its ownership of the object and it destroys the shared object if no longer any other shared pointers own it. This function is thread safe.</p>
<h4><a class="anchor" id="autotoc_md413"></a>
&lt;tt&gt;void name_reset(shared_t shared)&lt;/tt&gt;</h4>
<p><code>shared</code> loses ownership of its shared object and destroys it if no longer any other shared pointers own it. Then it makes the shared pointer <code>shared</code> references no object (NULL) (it doesn't reference its object any-longer and loses its ownership of it). This function is thread safe.</p>
<h4><a class="anchor" id="autotoc_md414"></a>
&lt;tt&gt;void name_set(shared_t shared, const shared_t src)&lt;/tt&gt;</h4>
<p><code>shared</code> loses ownership of its object and destroy it if no longer any other shared pointers own it. Then it sets the shared pointer <code>shared</code> to the same object than the one pointed by <code>src</code> (sharing ownership). This function is thread safe.</p>
<h4><a class="anchor" id="autotoc_md415"></a>
&lt;tt&gt;void name_init_move(shared_t shared, shared_t src)&lt;/tt&gt;</h4>
<p>Move the shared pointer from the initialized <code>src</code> to <code>shared</code>.</p>
<h4><a class="anchor" id="autotoc_md416"></a>
&lt;tt&gt;void name_move(shared_t shared, shared_t src)&lt;/tt&gt;</h4>
<p><code>shared</code> loses ownership of its object and destroy it if no longer any other shared pointers own it. Then it moves the shared pointer from the initialized <code>src</code> to <code>shared</code>.</p>
<h4><a class="anchor" id="autotoc_md417"></a>
&lt;tt&gt;void name_swap(shared_t shared1, shared_t shared2)&lt;/tt&gt;</h4>
<p>Swap the references of the objects owned by the shared pointers <code>shared1</code> and <code>shared2</code>.</p>
<h4><a class="anchor" id="autotoc_md418"></a>
&lt;tt&gt;bool name_equal_p(const shared_t shared1, const shared_t shared2)&lt;/tt&gt;</h4>
<p>Return true if both shared pointers own the same object.</p>
<h4><a class="anchor" id="autotoc_md419"></a>
&lt;tt&gt;const type *name_cref(const shared_t shared)&lt;/tt&gt;</h4>
<p>Return a constant pointer to the shared object owned by the shared pointer. The pointer shall be kept only until another use of shared pointer method. Keeping the pointer otherwise is undefined behavior.</p>
<h4><a class="anchor" id="autotoc_md420"></a>
&lt;tt&gt;type *name_ref(const shared_t shared)&lt;/tt&gt;</h4>
<p>Return a pointer to the shared object pointed by the shared pointer. The pointer shall be kept only until another use of shared pointer method. Keeping the pointer otherwise is undefined behavior.</p>
<p>TODO: Document shared resource</p>
<hr  />
<h2><a class="anchor" id="autotoc_md421"></a>
M-I-SHARED</h2>
<p>This header is for creating intrusive shared pointer.</p>
<h3><a class="anchor" id="autotoc_md422"></a>
&lt;tt&gt;ISHARED_PTR_INTERFACE(name, type)&lt;/tt&gt;</h3>
<p>Extend the definition of the structure of an object of type <code>type</code> by adding the necessary interface to handle it as a shared pointer named <code>name</code>. It shall be put within the structure definition of the object (See example).</p>
<h3><a class="anchor" id="autotoc_md423"></a>
&lt;tt&gt;ISHARED_PTR_STATIC_INIT(name, type)&lt;/tt&gt;</h3>
<p>Provide the static initialization value of an object defined with a <code>ISHARED_PTR_INTERFACE</code> extra fields. It shall be used only for global variables with the _init_once function.</p>
<p>Usage (provided that the interface is used as the first element of the structure):</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>mystruct variable = { ISHARED_PTR_STATIC_INIT(ishared_double, <span class="keyword">struct</span> mystruct) };</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md424"></a>
&lt;tt&gt;ISHARED_PTR_STATIC_DESIGNATED_INIT(name, type)&lt;/tt&gt;</h3>
<p>Provide the static initialization value of an object defined with a <code>ISHARED_PTR_INTERFACE</code> extra fields. It shall be used only for global variables with the _init_once function.</p>
<p>It uses designated initializers to set the right fields.</p>
<p>Usage:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>mystruct variable = {ISHARED_PTR_STATIC_DESIGNATED_INIT(ishared_double, <span class="keyword">struct</span> mystruct) };</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md425"></a>
&lt;tt&gt;ISHARED_PTR_DEF(name, type[, oplist])&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md426"></a>
&lt;tt&gt;ISHARED_PTR_DEF_AS(name, name_t, type[, oplist])&lt;/tt&gt;</h3>
<p>Define the associated methods to handle the shared pointer named <code>name</code> as <code>static inline</code> functions. A shared pointer is a mechanism to keep tracks of all <code>users</code> of an object and performs an automatic destruction of the object whenever all users release their need on this object.</p>
<p>The destruction of the object is thread safe and occurs when the last user of the object releases it. The destruction of the object implies:</p>
<ul>
<li>calling the <code>CLEAR</code> operator to clear the object,</li>
<li>calling the <code>DEL</code> operator to release the memory used by the object (if the method has not been disabled).</li>
</ul>
<p>The object oplist is expected to have the following operators (<code>CLEAR</code> and <code>DEL</code>), otherwise default methods are used. If there is no given oplist, the default operators are also used. The created methods will use the operators to init, set and clear the contained object.</p>
<p>There are designed to work with buffers with policy <code>BUFFER_PUSH_INIT_POP_MOVE</code> to send a shared pointer across multiple threads.</p>
<p>It is recommended to use the intrusive shared pointer over the standard one if possible. They are faster and cleaner.</p>
<p>The default is to use heap allocated entities, which are allocated by <code>NEW</code> and freed by <code>DEL</code>.</p>
<p>It can be used for statically allocated entities. However, in this case, you shall disable the operator <code>NEW</code> and <code>DEL</code> when expanding the oplist so that the destruction doesn't try to free the objects, like this:</p>
<div class="fragment"><div class="line">(NEW(0), DEL(0))</div>
</div><!-- fragment --><p><code>NEW</code> and <code>DEL</code> operators shall be either both defined, or both disabled.</p>
<p><code>ISHARED_PTR_DEF_AS</code> is the same as <code>ISHARED_PTR_DEF</code> except the name of the type <code>name_t</code> is provided.</p>
<p>Example (dynamic):</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>mystruct_s {</div>
<div class="line">        ISHARED_PTR_INTERFACE(ishared_mystruct, <span class="keyword">struct</span> mystruct_s);</div>
<div class="line">        <span class="keywordtype">char</span> *message;</div>
<div class="line">} mystruct_t;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> mystruct_init(mystruct_t *p) { p-&gt;message = NULL; }</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> mystruct_clear(mystruct_t *p) { free(p-&gt;message); }</div>
<div class="line"> </div>
<div class="line">ISHARED_PTR_DEF(ishared_mystruct, mystruct_t, (INIT(mystruct_init), CLEAR(mystruct_clear M_IPTR)))</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">void</span>) {</div>
<div class="line">        mystruct_t *p = ishared_mystruct_init_new();</div>
<div class="line">        p-&gt;message = strdup (<span class="stringliteral">&quot;Hello&quot;</span>);</div>
<div class="line">        buffer_mystruct_push(g_buff1, p);</div>
<div class="line">        buffer_mystruct_push(g_buff2, p);</div>
<div class="line">        ishared_mystruct_clear(p);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md427"></a>
Created types</h3>
<p>The following types are automatically defined by the previous definition macro if not provided by the user:</p>
<h4><a class="anchor" id="autotoc_md428"></a>
&lt;tt&gt;name_t&lt;/tt&gt;</h4>
<p>It will define name_t as a pointer to shared counted object. This is a synonymous to a pointer to the object.</p>
<h3><a class="anchor" id="autotoc_md429"></a>
Specialized methods</h3>
<p>The following specialized methods are automatically created by the previous definition macro:</p>
<h4><a class="anchor" id="autotoc_md430"></a>
&lt;tt&gt;name_t name_init(type *object)&lt;/tt&gt;</h4>
<p>Return a shared pointer to <code>object</code> which owns <code>object</code>. It initializes the private fields of <code>object</code> handling the shared pointer, returning the same pointer to the object from a value point of view, but with the shared pointer field initialized.</p>
<p>As a consequence, the shared pointer part of <code>object</code> shall not have been initialized yet. The other part of <code>object</code> may or may not be initialized before calling this method.</p>
<h4><a class="anchor" id="autotoc_md431"></a>
&lt;tt&gt;name_t name_init_set(name_t shared)&lt;/tt&gt;</h4>
<p>Return a new shared pointer to the same object than the one pointed by <code>shared</code>, incrementing the ownership of the object. This function is thread safe.</p>
<h4><a class="anchor" id="autotoc_md432"></a>
&lt;tt&gt;name_t name_init_new(void)&lt;/tt&gt;</h4>
<p>Allocate a new object, initialize it and return an initialized shared pointer to it. The used allocation function is the <code>NEW</code> operator.</p>
<p>This method is only created if the <code>INIT</code> and <code>NEW</code> methods are provided and not disabled.</p>
<h4><a class="anchor" id="autotoc_md433"></a>
&lt;tt&gt;name_t name_init_once(type *object)&lt;/tt&gt;</h4>
<p>Initialize the new object <code>object</code> and return an initialized shared pointer to it. The <code>INIT</code> operator of <code>object</code> is ensured to be called only once, even if multiple threads try to initialize it at the same time. Once the object is fully cleared, the initialization function may occur once again.</p>
<p><code>object</code> shall be a global variable initialized with the <code>ISHARED_PTR_STATIC_INIT</code> macro.</p>
<p>This method is only created if the <code>INIT</code> and <code>NEW</code> methods are provided and not disabled.</p>
<h4><a class="anchor" id="autotoc_md434"></a>
&lt;tt&gt;void name_clear(name_t shared)&lt;/tt&gt;</h4>
<p>Clear the <code>shared</code> pointer, releasing ownership of the object and destroying the shared object if no longer any other <code>shared</code> pointers own it. This function is thread safe.</p>
<h4><a class="anchor" id="autotoc_md435"></a>
&lt;tt&gt;void name_clear_ptr(name_t *shared)&lt;/tt&gt;</h4>
<p>Clear the shared pointer <code>*shared</code>, releasing ownership of the object and destroying the shared object if no longer any other <code>shared</code> pointers own it. This function is thread safe. Afterwards, <code>*shared</code> is set to NULL.</p>
<h4><a class="anchor" id="autotoc_md436"></a>
&lt;tt&gt;void name_set(name_t *shared1, name_t shared2)&lt;/tt&gt;</h4>
<p>Update the shared pointer <code>*shared1</code> to point to the same object than the shared pointer <code>shared2</code>. Destroy the shared object pointed by <code>*shared1</code> if no longer any other shared pointers own it, set the shared pointer <code>shared</code> to the same object than the one pointed by <code>src</code>. This function is thread safe.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md437"></a>
M-I-LIST</h2>
<p>This header is for creating intrusive doubly-linked list.</p>
<h3><a class="anchor" id="autotoc_md438"></a>
&lt;tt&gt;ILIST_INTERFACE(name, type)&lt;/tt&gt;</h3>
<p>Extend an object by adding the necessary interface to handle it within an intrusive doubly-linked list. This is the intrusive part. It shall be put within the structure of the object to link, at the top level of the structure. See example of <code>ILIST_DEF</code>.</p>
<h3><a class="anchor" id="autotoc_md439"></a>
&lt;tt&gt;ILIST_DEF(name, type[, oplist])&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md440"></a>
&lt;tt&gt;ILIST_DEF_AS(name, name_t, name_it_t, type[, oplist])&lt;/tt&gt;</h3>
<p>Define the intrusive doubly-linked list and define the associated methods to handle it as <code>static inline</code> functions.</p>
<p><code>name</code> shall be a C identifier that will be used to identify the list. It will be used to create all the types (including the iterator) and functions to handle the container. This definition shall be done once per name and per compilation unit.</p>
<p>The oplist shall have at least the following operators (<code>CLEAR</code>), otherwise it won't generate compilable code.</p>
<p>An object is expected to be part of only one list of a kind in the entire program at a time. An intrusive list enables to move from an object to the next object without needing to go through the entire list, or to remove an object from a list in <code>O(1)</code>. It may, or may not, be better than standard list. It depends on the context.</p>
<p>The given interface won't allocate anything to handle the objects as all allocations and initialization are let to the user. However, the objects within the list can be automatically be cleared (by calling the <code>CLEAR</code> method to destruct the object) on list destruction. Then the memory allocation, performed by the user program, can also be reclaimed by defining a <code>DEL</code> operator to free the used memory in the object oplist. If there is no <code>DEL</code> operator, it is up to the user to free the used memory.</p>
<p>The list iterates from back to front.</p>
<p><code>ILIST_DEF_AS</code> is the same as <code>ILIST_DEF</code> except the name of the types <code>name_t</code>, <code>name_it_t</code> are provided.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="structtest__s.html">test_s</a> {</div>
<div class="line">  <span class="keywordtype">int</span> n;</div>
<div class="line">  ILIST_INTERFACE (ilist_tname, <span class="keyword">struct</span> <a class="code hl_struct" href="structtest__s.html">test_s</a>);</div>
<div class="line">} <a class="code hl_struct" href="structtest__s.html">test_t</a>;</div>
<div class="line"> </div>
<div class="line">ILIST_DEF(ilist_tname, <a class="code hl_struct" href="structtest__s.html">test_t</a>)</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">void</span>) {</div>
<div class="line">        <a class="code hl_struct" href="structtest__s.html">test_t</a> x1, x2, x3;</div>
<div class="line">        ilist_tname_t list;</div>
<div class="line"> </div>
<div class="line">        x1.n = 1;</div>
<div class="line">        x2.n = 2;</div>
<div class="line">        x3.n = 3;</div>
<div class="line"> </div>
<div class="line">        ilist_tname_init(list);</div>
<div class="line">        ilist_tname_push_back (list, &amp;x3);</div>
<div class="line">        ilist_tname_push_front (list, &amp;x1);</div>
<div class="line">        ilist_tname_push_after (&amp;x1, &amp;x2);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">int</span> n = 1;</div>
<div class="line">        <span class="keywordflow">for</span> M_EACH(item, list, ILIST_OPLIST(ilist_tname)) {</div>
<div class="line">                assert (n == item-&gt;n);</div>
<div class="line">                n++;</div>
<div class="line">        }</div>
<div class="line">        ilist_tname_clear(list);</div>
<div class="line">}</div>
<div class="ttc" id="astructtest__s_html"><div class="ttname"><a href="structtest__s.html">test_s</a></div><div class="ttdef"><b>Definition</b> test-mbuffer.c:302</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md441"></a>
Created types</h3>
<p>The following types are automatically defined by the previous definition macro if not provided by the user:</p>
<h3><a class="anchor" id="autotoc_md442"></a>
&lt;tt&gt;name_t&lt;/tt&gt;</h3>
<p>Type of the list of <code>type</code>.</p>
<h3><a class="anchor" id="autotoc_md443"></a>
&lt;tt&gt;name_it_t&lt;/tt&gt;</h3>
<p>Type of an iterator over this list.</p>
<h3><a class="anchor" id="autotoc_md444"></a>
Generic methods</h3>
<p>The following methods of the generic interface are defined (See generic interface for details):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> name_init(name_t list)</div>
<div class="line"><span class="keywordtype">void</span> name_clear(name_t list)</div>
<div class="line"><span class="keywordtype">void</span> name_reset(name_t list)</div>
<div class="line">type *name_back(<span class="keyword">const</span> name_t list)</div>
<div class="line">type *name_front(<span class="keyword">const</span> name_t list)</div>
<div class="line"><span class="keywordtype">bool</span> name_empty_p(<span class="keyword">const</span> name_t list)</div>
<div class="line"><span class="keywordtype">void</span> name_swap(name_t list1, name_t list2)</div>
<div class="line"><span class="keywordtype">void</span> name_it(name_it_t it, name_t list)</div>
<div class="line"><span class="keywordtype">void</span> name_it_set(name_it_t it, <span class="keyword">const</span> name_it_t ref)</div>
<div class="line"><span class="keywordtype">void</span> name_it_last(name_it_t it, name_t list)</div>
<div class="line"><span class="keywordtype">void</span> name_it_end(name_it_t it, name_t list)</div>
<div class="line"><span class="keywordtype">bool</span> name_end_p(<span class="keyword">const</span> name_it_t it)</div>
<div class="line"><span class="keywordtype">bool</span> name_last_p(<span class="keyword">const</span> name_it_t it)</div>
<div class="line"><span class="keywordtype">bool</span> name_it_equal_p(<span class="keyword">const</span> name_it_t it1, <span class="keyword">const</span> name_it_t it2)</div>
<div class="line"><span class="keywordtype">void</span> name_next(name_it_t it)</div>
<div class="line"><span class="keywordtype">void</span> name_previous(name_it_t it)</div>
<div class="line">type *name_ref(name_it_t it)</div>
<div class="line"><span class="keyword">const</span> type *name_cref(<span class="keyword">const</span> name_it_t it)</div>
<div class="line"><span class="keywordtype">size_t</span> name_size(<span class="keyword">const</span> name_t list)</div>
<div class="line"><span class="keywordtype">void</span> name_remove(name_t list, name_it_t it)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md445"></a>
Specialized methods</h3>
<p>The following specialized methods are automatically created by the previous definition macro:</p>
<h4><a class="anchor" id="autotoc_md446"></a>
&lt;tt&gt;void name_init_field(type *obj)&lt;/tt&gt;</h4>
<p>Initialize the additional fields of the object <code>*obj</code> handling the list. This function shall be used in the object constructor.</p>
<h4><a class="anchor" id="autotoc_md447"></a>
&lt;tt&gt;void name_push_back(name_t list, type *obj)&lt;/tt&gt;</h4>
<p>Push the object <code>*obj</code> itself (and not a copy) at the back of the list <code>list</code>.</p>
<h4><a class="anchor" id="autotoc_md448"></a>
&lt;tt&gt;void name_push_front(name_t list, type *obj)&lt;/tt&gt;</h4>
<p>Push the object <code>*obj</code> itself (and not a copy) at the front of the list <code>list</code>.</p>
<h4><a class="anchor" id="autotoc_md449"></a>
&lt;tt&gt;void name_push_after(type *position, type *obj)&lt;/tt&gt;</h4>
<p>Push the object <code>*obj</code> itself (and not a copy) after the object <code>*position</code>.</p>
<h4><a class="anchor" id="autotoc_md450"></a>
&lt;tt&gt;type *name_pop_back(name_t list)&lt;/tt&gt;</h4>
<p>Pop the object from the back of the list <code>list</code> and return a pointer to the popped object, given back the ownership of the object to the caller program (which becomes responsible to calling the destructor of this object).</p>
<h4><a class="anchor" id="autotoc_md451"></a>
&lt;tt&gt;type *name_pop_front(name_t list)&lt;/tt&gt;</h4>
<p>Pop the object from the front of the list <code>list</code> and return a pointer to the popped object, given back the ownership of the object to the caller program (which becomes responsible to calling the destructor of this object).</p>
<h4><a class="anchor" id="autotoc_md452"></a>
&lt;tt&gt;void name_unlink(type *obj)&lt;/tt&gt;</h4>
<p>Remove the object <code>*obj</code> from the list. It gives back the ownership of the object to the caller program which becomes responsible to calling the destructor of this object.</p>
<h4><a class="anchor" id="autotoc_md453"></a>
&lt;tt&gt;type *name_next_obj(const name_t list, const type *obj)&lt;/tt&gt;</h4>
<p>Return the object that is after the object <code>*obj</code> in the list or NULL if there is no more object.</p>
<h4><a class="anchor" id="autotoc_md454"></a>
&lt;tt&gt;type *name_previous_obj(const name_t list, const type *obj)&lt;/tt&gt;</h4>
<p>Return the object that is before the object <code>*obj</code> in the list or NULL if there is no more object.</p>
<h4><a class="anchor" id="autotoc_md455"></a>
&lt;tt&gt;void name_insert(name_t list, name_it_t it, type x)&lt;/tt&gt;</h4>
<p>This method is the same as the generic one, except it is only created if the <code>NEW</code> and <code>INIT_SET</code> methods are provided.</p>
<h4><a class="anchor" id="autotoc_md456"></a>
&lt;tt&gt;void name_splice_back(name_t list1, name_t list2, name_it_t it)&lt;/tt&gt;</h4>
<p>Move the element pointed by <code>it</code> from the list <code>list2</code> to the back position of <code>list1</code>. <code>it</code> shall be an iterator of <code>list2</code>. Afterwards, <code>it</code> points to the next element of <code>list2</code>.</p>
<h4><a class="anchor" id="autotoc_md457"></a>
&lt;tt&gt;void name_splice(name_t list1, name_t list2)&lt;/tt&gt;</h4>
<p>Move all the element of <code>list2</code> into <code>list1</code>, moving the last element of <code>list2</code> after the first element of <code>list1</code>. Afterwards, <code>list2</code> is emptied.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md458"></a>
M-CONCURRENT</h2>
<p>This header is for transforming a standard container (<code>LIST</code>, <code>ARRAY</code>, <code>DICT</code>, <code>DEQUE</code>, ...) into an equivalent container but compatible with concurrent access by different threads. In practice, it puts a mutex lock to access the container.</p>
<p>As such it is quite generic. However, it is less efficient than containers specially tuned for multiple threads. There is also no iterators.</p>
<h3><a class="anchor" id="autotoc_md459"></a>
&lt;tt&gt;CONCURRENT_DEF(name, type[, oplist])&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md460"></a>
&lt;tt&gt;CONCURRENT_DEF_AS(name, name_t, type[, oplist])&lt;/tt&gt;</h3>
<p>Define the concurrent container <code>name</code> based on container <code>type</code> of oplist <code>oplist</code>, and define the associated methods to handle it as <code>static inline</code> functions.</p>
<p><code>name</code> shall be a C identifier that will be used to identify the concurrent container. It will be used to create all the types (including the iterator) and functions to handle the container. This definition shall be done once per name and per compilation unit.</p>
<p>It scans the <code>oplist</code> of the type to create equivalent function, so the exact generated methods depend on explicitly the exported methods in the oplist. The init method is only defined if the base container exports the <code>INIT</code> operator, same for the clear method and the <code>CLEAR</code> operator, and so on for all created methods.</p>
<p>In the description below, <code>subtype_t</code> is the type of the element within the given container <code>type</code> (if it exists), <code>key_t</code> is the key type of the element within the given container <code>type</code> (if it exists), <code>value_t</code> is the value type of the element within the given container <code>type</code> (if it exists).</p>
<p><code>CONCURRENT_DEF_AS</code> is the same as <code>CONCURRENT_DEF</code> except the name of the type <code>name_t</code> is provided.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="comment">/* Define a stack container (STACK)*/</span></div>
<div class="line">ARRAY_DEF(array1, <span class="keywordtype">int</span>)</div>
<div class="line">CONCURRENT_DEF(parray1, array1_t, ARRAY_OPLIST(array1))</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Define a queue container (FIFO) */</span></div>
<div class="line">DEQUE_DEF(deque_uint, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)</div>
<div class="line">CONCURRENT_DEF(cdeque_uint, deque_uint_t, M_OPEXTEND(DEQUE_OPLIST(deque_uint, M_BASIC_OPLIST), PUSH(deque_uint_push_front)))</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> parray1_t x1;</div>
<div class="line"><span class="keyword">extern</span> cdeque_uint_t x2;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">void</span>) {</div>
<div class="line">     parray1_push (x1, 17);</div>
<div class="line">     cdeque_uint_push (x2, 17);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md461"></a>
Created types</h3>
<p>The following types are automatically defined by the previous definition macro if not provided by the user:</p>
<h4><a class="anchor" id="autotoc_md462"></a>
&lt;tt&gt;name_t&lt;/tt&gt;</h4>
<p>Type of the concurrent container of <code>type</code>.</p>
<h3><a class="anchor" id="autotoc_md463"></a>
Generic methods</h3>
<p>The following methods of the generic interface are defined (See generic interface for details):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> name_init(name_t concurrent)</div>
<div class="line"><span class="keywordtype">void</span> name_init_set(name_t concurrent, <span class="keyword">const</span> name_t src)</div>
<div class="line"><span class="keywordtype">void</span> name_init_move(name_t concurrent, name_t src)</div>
<div class="line"><span class="keywordtype">void</span> name_set(name_t concurrent, <span class="keyword">const</span> name_t src)</div>
<div class="line"><span class="keywordtype">void</span> name_move(name_t concurrent, name_t src)</div>
<div class="line"><span class="keywordtype">void</span> name_reset(name_t concurrent)</div>
<div class="line"><span class="keywordtype">void</span> name_clear(name_t concurrent)</div>
<div class="line"><span class="keywordtype">void</span> name_swap(name_t concurrent1, name_t concurrent2)</div>
<div class="line"><span class="keywordtype">bool</span> name_empty_p(<span class="keyword">const</span> name_t concurrent)</div>
<div class="line"><span class="keywordtype">void</span> name_set_at(name_t concurrent, key_t key, value_t value)</div>
<div class="line"><span class="keywordtype">bool</span> name_erase(name_t concurrent, <span class="keyword">const</span> key_t key)</div>
<div class="line"><span class="keywordtype">void</span> name_push(name_t concurrent, <span class="keyword">const</span> subtype_t data)</div>
<div class="line"><span class="keywordtype">void</span> name_push_move(name_t concurrent, subtype_t *data)</div>
<div class="line"><span class="keywordtype">void</span> name_pop_move(subtype_t *data, name_t concurrent)</div>
<div class="line"><span class="keywordtype">void</span> name_get_str(string_t str, name_t concurrent, <span class="keywordtype">bool</span> append)</div>
<div class="line"><span class="keywordtype">void</span> name_out_str(FILE *file, name_t concurrent)</div>
<div class="line"><span class="keywordtype">bool</span> name_parse_str(name_t concurrent, <span class="keyword">const</span> <span class="keywordtype">char</span> str[], <span class="keyword">const</span> <span class="keywordtype">char</span> **end)</div>
<div class="line"><span class="keywordtype">bool</span> name_in_str(name_t concurrent, FILE *file)</div>
<div class="line">m_serial_return_code_t name_out_serial(m_serial_write_t serial, <span class="keyword">const</span> name_t container)</div>
<div class="line">m_serial_return_code_t name_in_str(name_t container, m_serial_read_t serial)</div>
<div class="line"><span class="keywordtype">bool</span> name_equal_p(name_t concurrent1, name_t concurrent2)</div>
<div class="line"><span class="keywordtype">size_t</span> name_hash(name_t concurrent)</div>
</div><!-- fragment --><p>Returns true in case of success, false otherwise.</p>
<h3><a class="anchor" id="autotoc_md464"></a>
Specialized methods</h3>
<p>The following specialized methods are automatically created by the previous definition macro:</p>
<h4><a class="anchor" id="autotoc_md465"></a>
&lt;tt&gt;bool name_get_copy(value_t *value, name_t concurrent, key_t key)&lt;/tt&gt;</h4>
<p>Read the value associated to the key <code>key</code>. If it exists, it sets <code>*value</code> to it and returns true. Otherwise it returns false (<code>*value</code> is unchanged). This method is only defined if the base container exports the <code>GET_KEY</code> operator.</p>
<h4><a class="anchor" id="autotoc_md466"></a>
&lt;tt&gt;void name_safe_get_copy(value_t *value, name_t concurrent, key_t key)&lt;/tt&gt;</h4>
<p>Read the value associated to the key <code>key</code>. If it exists, it sets <code>*value</code> to it. Otherwise, it creates a new value (default constructor) and sets <code>*value</code> to it. This method is only defined if the base container exports the <code>SAFE_GET_KEY</code> operator.</p>
<h4><a class="anchor" id="autotoc_md467"></a>
&lt;tt&gt;void name_pop(subtype_t *data, name_t concurrent)&lt;/tt&gt;</h4>
<p>Pop data from the container and set it in <code>*data</code>. There shall be at least one data to pop. Testing with the operator <code>EMPTY_P</code> before calling this function is not enough as there can be some concurrent scenario where another thread pop the last value. <code>name_pop_blocking</code> should be used instead. This method is only defined if the base container exports the <code>POP</code> operator.</p>
<h4><a class="anchor" id="autotoc_md468"></a>
&lt;tt&gt;bool name_get_blocking(value_t *value, name_t concurrent, key_t key, bool blocking)&lt;/tt&gt;</h4>
<p>Read the value associated to the key <code>key</code>. If it exists, it sets <code>*value</code> to it and returns true. Otherwise, if blocking is true, it waits for the data to be filled. After the wait, it sets <code>*value</code> to it and returns true. Otherwise, if blocking is false, it returns false. This method is only defined if the base container exports the <code>GET_KEY</code> operator.</p>
<h4><a class="anchor" id="autotoc_md469"></a>
&lt;tt&gt;bool name_pop_blocking(type_t *data, name_t concurrent, bool blocking)&lt;/tt&gt;</h4>
<p>Pop a value from the container and set <code>*data</code> with it. If the container is not empty, it sets <code>*data</code> and return true. Otherwise, if blocking is true, it waits for the data to be pushed. After the wait, it sets <code>*data</code> to it and returns true. Otherwise, if blocking is false, it returns false. This method is only defined if the base container exports the <code>POP</code> and <code>EMPTY_P</code> operators.</p>
<h4><a class="anchor" id="autotoc_md470"></a>
&lt;tt&gt;bool name_pop_move_blocking(type_t *data, name_t concurrent, bool blocking)&lt;/tt&gt;</h4>
<p>Pop a value from the container and initialize and set <code>*data</code> with it. If the container is not empty, it initializes and sets <code>*data</code> and return true. Otherwise if blocking is true, it waits for the data to be pushed. After the wait, it initializes and sets <code>*data</code> to it and returns true. Otherwise, if blocking is false, it returns false.</p>
<blockquote class="doxtable">
<p>&zwj;[!WARNING] <code>*data</code> remains uninitialized! </p>
</blockquote>
<p>This method is only defined if the base container exports the <code>POP_MOVE</code> and <code>EMPTY_P</code> operators.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md471"></a>
M-BITSET</h2>
<p>This header is for using bitset.</p>
<p>A <a href="https://en.wikipedia.org/wiki/Bit_array">bitset</a> can be seen as a specialized version of an array of bool, where each item takes only 1 bit. It enables for compact representation of such array.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">void</span>) {</div>
<div class="line">        bitset_t set;</div>
<div class="line">        bitset_init(set);</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 100; i ++)</div>
<div class="line">                bitset_push_back(set, i%2);</div>
<div class="line">        bitset_clear(set);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md472"></a>
Methods, types &amp; constants</h3>
<p>The following methods are available:</p>
<h4><a class="anchor" id="autotoc_md473"></a>
&lt;tt&gt;bitset_t&lt;/tt&gt;</h4>
<p>This type defines a dynamic array of bit and is the primary type of the module.</p>
<h4><a class="anchor" id="autotoc_md474"></a>
&lt;tt&gt;bitset_it_t&lt;/tt&gt;</h4>
<p>This type defines an iterator over the bitset.</p>
<h4><a class="anchor" id="autotoc_md475"></a>
&lt;tt&gt;void bitset_init(bitset_t array)&lt;/tt&gt;</h4>
<p>Initialize the bitset <code>array</code> (aka constructor) to an empty array.</p>
<h4><a class="anchor" id="autotoc_md476"></a>
&lt;tt&gt;void bitset_init_set(bitset_t array, const bitset_t ref)&lt;/tt&gt;</h4>
<p>Initialize the bitset <code>array</code> (aka constructor) and set it to the value of <code>ref</code>.</p>
<h4><a class="anchor" id="autotoc_md477"></a>
&lt;tt&gt;void bitset_set(bitset_t array, const bitset_t ref)&lt;/tt&gt;</h4>
<p>Set the bitset <code>array</code> to the value of <code>ref</code>.</p>
<h4><a class="anchor" id="autotoc_md478"></a>
&lt;tt&gt;void bitset_init_move(bitset_t array, bitset_t ref)&lt;/tt&gt;</h4>
<p>Initialize the bitset <code>array</code> (aka constructor) by stealing as many resources from <code>ref</code> as possible. Afterwards <code>ref</code> is cleared.</p>
<h4><a class="anchor" id="autotoc_md479"></a>
&lt;tt&gt;void bitset_move(bitset_t array, bitset_t ref)&lt;/tt&gt;</h4>
<p>Set the bitset <code>array</code> by stealing as many resources from <code>ref</code> as possible. Afterwards <code>ref</code> is cleared.</p>
<h4><a class="anchor" id="autotoc_md480"></a>
&lt;tt&gt;void bitset_clear(bitset_t array)&lt;/tt&gt;</h4>
<p>Clear the bitset <code>array</code> (aka destructor).</p>
<h4><a class="anchor" id="autotoc_md481"></a>
&lt;tt&gt;void bitset_reset(bitset_t array)&lt;/tt&gt;</h4>
<p>Reset the bitset. The bitset becomes empty but remains initialized.</p>
<h4><a class="anchor" id="autotoc_md482"></a>
&lt;tt&gt;void bitset_push_back(bitset_t array, const bool value)&lt;/tt&gt;</h4>
<p>Push a new element into the back of the bitset <code>array</code> with the value <code>value</code>.</p>
<h4><a class="anchor" id="autotoc_md483"></a>
&lt;tt&gt;void bitset_push_at(bitset_t array, size_t key, const bool value)&lt;/tt&gt;</h4>
<p>Push a new element into the position <code>key</code> of the bitset <code>array</code> with the value <code>value</code>. <code>key</code> shall be a valid position of the array: from 0 to the size of array (included).</p>
<h4><a class="anchor" id="autotoc_md484"></a>
&lt;tt&gt;void bitset_pop_back(bool *data, bitset_t array)&lt;/tt&gt;</h4>
<p>Pop a element from the back of the bitset <code>array</code> and set <code>*data</code> to this value if data is not NULL (if data is NULL, the popped data is cleared).</p>
<h4><a class="anchor" id="autotoc_md485"></a>
&lt;tt&gt;void bitset_pop_at(bool *dest, bitset_t array, size_t key)&lt;/tt&gt;</h4>
<p>Set <code>*dest</code> to the value the element <code>key</code> if dest is not NULL, then remove the element <code>key</code> from the bitset. <code>key</code> shall be within the size of the bitset.</p>
<h4><a class="anchor" id="autotoc_md486"></a>
&lt;tt&gt;bool bitset_front(const bitset_t array)&lt;/tt&gt;</h4>
<p>Return the first element of the bitset. The bitset shall have at least one element.</p>
<h4><a class="anchor" id="autotoc_md487"></a>
&lt;tt&gt;bool bitset_back(const bitset_t array)&lt;/tt&gt;</h4>
<p>Return the last element of the bitset. The bitset shall have at least one element.</p>
<h4><a class="anchor" id="autotoc_md488"></a>
&lt;tt&gt;void bitset_set_at(bitset_t array, size_t i, bool value)&lt;/tt&gt;</h4>
<p>Set the element <code>i</code> of bitset <code>array</code> to <code>value</code>. <code>i</code> shall be within 0 to the size of the array (excluded).</p>
<h4><a class="anchor" id="autotoc_md489"></a>
&lt;tt&gt;void bitset_flip_at(bitset_t array, size_t i)&lt;/tt&gt;</h4>
<p>Flip the element <code>i</code> of bitset <code>array</code>'. <code>i</code> shall be within 0 to the size of the array (excluded).</p>
<h4><a class="anchor" id="autotoc_md490"></a>
&lt;tt&gt;bool bitset_get(bitset_t array, size_t i)&lt;/tt&gt;</h4>
<p>Return the element <code>i</code> of the bitset. <code>i</code> shall be within 0 to the size of the array (excluded).</p>
<h4><a class="anchor" id="autotoc_md491"></a>
&lt;tt&gt;bool bitset_empty_p(const bitset_t array)&lt;/tt&gt;</h4>
<p>Return true if the bitset is empty, false otherwise.</p>
<h4><a class="anchor" id="autotoc_md492"></a>
&lt;tt&gt;size_t bitset_size(const bitset_t array)&lt;/tt&gt;</h4>
<p>Return the size of the bitset.</p>
<h4><a class="anchor" id="autotoc_md493"></a>
&lt;tt&gt;size_t bitset_capacity(const bitset_t array)&lt;/tt&gt;</h4>
<p>Return the capacity of the bitset.</p>
<h4><a class="anchor" id="autotoc_md494"></a>
&lt;tt&gt;void bitset_resize(bitset_t array, size_t size)&lt;/tt&gt;</h4>
<p>Resize the bitset <code>array</code> to the size <code>size</code> (initializing or clearing elements).</p>
<h4><a class="anchor" id="autotoc_md495"></a>
&lt;tt&gt;void bitset_reserve(bitset_t array, size_t capacity)&lt;/tt&gt;</h4>
<p>Extend or reduce the capacity of the <code>array</code> to a rounded value based on <code>capacity</code>. If the given capacity is below the current size of the bitset, the capacity is set to the size of the bitset.</p>
<h4><a class="anchor" id="autotoc_md496"></a>
&lt;tt&gt;void bitset_swap(bitset_t array1, bitset_t array2)&lt;/tt&gt;</h4>
<p>Swap the bitsets <code>array1</code> and <code>array2</code>.</p>
<h4><a class="anchor" id="autotoc_md497"></a>
&lt;tt&gt;void bitset_swap_at(bitset_t array, size_t i, size_t j)&lt;/tt&gt;</h4>
<p>Swap the elements <code>i</code> and <code>j</code> of the bitset <code>array</code>. <code>i</code> and <code>j</code> shall reference valid elements of the array.</p>
<h4><a class="anchor" id="autotoc_md498"></a>
&lt;tt&gt;void bitset_it(bitset_it_t it, bitset_t array)&lt;/tt&gt;</h4>
<p>Set the iterator <code>it</code> to the first element of <code>array</code>.</p>
<h4><a class="anchor" id="autotoc_md499"></a>
&lt;tt&gt;void bitset_it_last(bitset_it_t it, bitset_t array)&lt;/tt&gt;</h4>
<p>Set the iterator <code>it</code> to the last element of <code>array</code>.</p>
<h4><a class="anchor" id="autotoc_md500"></a>
&lt;tt&gt;void bitset_it_end(bitset_it_t it, bitset_t array)&lt;/tt&gt;</h4>
<p>Set the iterator <code>it</code> to the end of <code>array</code>.</p>
<h4><a class="anchor" id="autotoc_md501"></a>
&lt;tt&gt;void bitset_it_set(bitset_it_t it1, bitset_it_t it2)&lt;/tt&gt;</h4>
<p>Set the iterator <code>it1</code> to <code>it2</code>.</p>
<h4><a class="anchor" id="autotoc_md502"></a>
&lt;tt&gt;bool bitset_end_p(bitset_it_t it)&lt;/tt&gt;</h4>
<p>Return true if the iterator doesn't reference a valid element anymore.</p>
<h4><a class="anchor" id="autotoc_md503"></a>
&lt;tt&gt;bool bitset_last_p(bitset_it_t it)&lt;/tt&gt;</h4>
<p>Return true if the iterator references the last element of the array, or doesn't reference a valid element.</p>
<h4><a class="anchor" id="autotoc_md504"></a>
&lt;tt&gt;bool bitset_it_equal_p(const bitset_it_t it1, const bitset_it_t it2)&lt;/tt&gt;</h4>
<p>Return true if both iterators reference the same element.</p>
<h4><a class="anchor" id="autotoc_md505"></a>
&lt;tt&gt;void bitset_next(bitset_it_t it)&lt;/tt&gt;</h4>
<p>Move the iterator <code>it</code> to the next element of the array.</p>
<h4><a class="anchor" id="autotoc_md506"></a>
&lt;tt&gt;void bitset_previous(bitset_it_t it)&lt;/tt&gt;</h4>
<p>Move the iterator <code>it</code> to the previous element of the array.</p>
<h4><a class="anchor" id="autotoc_md507"></a>
&lt;tt&gt;const bool *bitset_cref(const bitset_it_t it)&lt;/tt&gt;</h4>
<p>Return a constant pointer to the element pointed by the iterator. This pointer remains valid until the array or the iterator is modified by another method.</p>
<h4><a class="anchor" id="autotoc_md508"></a>
&lt;tt&gt;void bitset_get_str(string_t str, const bitset_t array, bool append)&lt;/tt&gt;</h4>
<p>Generate a formatted string representation of the bitset <code>array</code> and set <code>str</code> to this representation (if <code>append</code> is false) or append <code>str</code> with this representation (if <code>append</code> is true). This method is only defined if the header m-string.h was included before including m-bitset.h</p>
<h4><a class="anchor" id="autotoc_md509"></a>
&lt;tt&gt;bool bitset_parse_str(bitset_t array, const char str[], const char **endp)&lt;/tt&gt;</h4>
<p>Parse the formatted string <code>str</code> that is assumed to be a string representation of a bitset and set <code>array</code> to this representation. It returns true if success, false otherwise. If <code>endp</code> is not NULL, it sets <code>*endp</code> to the pointer of the first character not decoded by the function.</p>
<h4><a class="anchor" id="autotoc_md510"></a>
&lt;tt&gt;void bitset_out_str(FILE *file, const bitset_t array)&lt;/tt&gt;</h4>
<p>Generate a formatted string representation of the bitset <code>array</code> and outputs it into the FILE <code>file</code>.</p>
<h4><a class="anchor" id="autotoc_md511"></a>
&lt;tt&gt;void bitset_in_str(bitset_t array, FILE *file)&lt;/tt&gt;</h4>
<p>Read from the file <code>file</code> a formatted string representation of a bitset and set <code>array</code> to this representation.</p>
<h4><a class="anchor" id="autotoc_md512"></a>
&lt;tt&gt;bool bitset_equal_p(const bitset_t array1, const bitset_t array2)&lt;/tt&gt;</h4>
<p>Return true if both bitsets <code>array1</code> and <code>array2</code> are equal.</p>
<h4><a class="anchor" id="autotoc_md513"></a>
&lt;tt&gt;size_t bitset_hash(const bitset_t array)&lt;/tt&gt;</h4>
<p>Return a hash value of <code>array</code>.</p>
<h4><a class="anchor" id="autotoc_md514"></a>
&lt;tt&gt;void bitset_and(bitset_t dst, const bitset_t src)&lt;/tt&gt;</h4>
<p>Perform a <code>bitwise AND</code> operation in <code>dst</code> between <code>dst</code> and <code>src</code> (effectively performing an intersection of the sets).</p>
<h4><a class="anchor" id="autotoc_md515"></a>
&lt;tt&gt;void bitset_or(bitset_t dst, const bitset_t src)&lt;/tt&gt;</h4>
<p>Perform a <code>bitwise OR</code> operation in <code>dst</code> between <code>dst</code> and <code>src</code> (effectively performing an union of the sets).</p>
<h4><a class="anchor" id="autotoc_md516"></a>
&lt;tt&gt;void bitset_xor(bitset_t dst, const bitset_t src)&lt;/tt&gt;</h4>
<p>Perform a <code>bitwise XOR</code> operation in <code>dst</code> between <code>dst</code> and <code>src</code>.</p>
<h4><a class="anchor" id="autotoc_md517"></a>
&lt;tt&gt;void bitset_not(bitset_t dst)&lt;/tt&gt;</h4>
<p>Perform a <code>bitwise NOT</code> operation for <code>dst</code>.</p>
<h4><a class="anchor" id="autotoc_md518"></a>
&lt;tt&gt;size_t bitset_clz(const bitset_t src)&lt;/tt&gt;</h4>
<p>Return the <code>leading zero</code> position in <code>src</code> (Count Leading Zero).</p>
<h4><a class="anchor" id="autotoc_md519"></a>
&lt;tt&gt;size_t bitset_popcount(const bitset_t src)&lt;/tt&gt;</h4>
<p>Count the number of <code>1</code> in <code>src</code>.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md520"></a>
M-STRING</h2>
<p>This header is for using dynamic <a href="https://en.wikipedia.org/wiki/String_(computer_science)">string</a>. The size of the string is automatically updated in function of the needs.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">void</span>) {</div>
<div class="line">        string_t s1;</div>
<div class="line">        string_init (s1);</div>
<div class="line">        string_set_str (s1, <span class="stringliteral">&quot;Hello, world!&quot;</span>);</div>
<div class="line">        string_clear(s1);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The basic usage is a string of ASCII byte-character. However, the functions supports also UTF-8 encoded string (except said otherwise). It supports encoding/decoding of UTF8 code point.</p>
<h3><a class="anchor" id="autotoc_md521"></a>
Methods, types &amp; constants</h3>
<p>The following methods are available:</p>
<h4><a class="anchor" id="autotoc_md522"></a>
&lt;tt&gt;string_t&lt;/tt&gt;</h4>
<p>This type defines a dynamic string and is the primary type of the module. The provided methods are just handy wrappers to the C library, providing few algorithms on its own.</p>
<h4><a class="anchor" id="autotoc_md523"></a>
&lt;tt&gt;STRING_FAILURE&lt;/tt&gt;</h4>
<p>Constant Macro defined as the index value returned in case of error. (equal as <code>-1U</code>).</p>
<h4><a class="anchor" id="autotoc_md524"></a>
&lt;tt&gt;string_fgets_t&lt;/tt&gt;</h4>
<p>This type defines the different enumerate value for the <code>string_fgets</code> function:</p>
<ul>
<li><code>STRING_READ_LINE</code>  read a full line until the <code>EOL</code> character (included),</li>
<li><code>STRING_READ_PURE_LINE</code>  read a full line until the <code>EOL</code> character (excluded),</li>
<li><code>STRING_READ_FILE</code>  read the full file.</li>
</ul>
<h4><a class="anchor" id="autotoc_md525"></a>
&lt;tt&gt;void string_init(string_t str)&lt;/tt&gt;</h4>
<p>Init the string <code>str</code> to an empty string.</p>
<h4><a class="anchor" id="autotoc_md526"></a>
&lt;tt&gt;void string_clear(string_t str)&lt;/tt&gt;</h4>
<p>Clear the string <code>str</code> and frees any allocated memory.</p>
<h4><a class="anchor" id="autotoc_md527"></a>
&lt;tt&gt;char *string_clear_get_str(string_t v)&lt;/tt&gt;</h4>
<p>Clear the string <code>str</code> and returns the allocated array of char, representing a C string, giving back ownership of this array to the caller. This array will have to be freed. It can return NULL if no array was allocated by the string.</p>
<h4><a class="anchor" id="autotoc_md528"></a>
&lt;tt&gt;void string_reset(string_t str)&lt;/tt&gt;</h4>
<p>Reset the string <code>str</code> to an empty string.</p>
<h4><a class="anchor" id="autotoc_md529"></a>
&lt;tt&gt;size_t string_size(const string_t str)&lt;/tt&gt;</h4>
<p>Return the size in bytes of the string. It can be also the number of characters of the string if the encoding type is one character per byte. If the characters are encoded as UTF8, the function <code>string_length_u</code> is preferred.</p>
<h4><a class="anchor" id="autotoc_md530"></a>
&lt;tt&gt;size_t string_capacity(const string_t str)&lt;/tt&gt;</h4>
<p>Return the capacity in bytes of the string. The capacity is the number of bytes the string accept before a reallocation of the underlying array of char has to be performed.</p>
<h4><a class="anchor" id="autotoc_md531"></a>
&lt;tt&gt;char string_get_char(const string_t v, size_t index)&lt;/tt&gt;</h4>
<p>Return the byte at position <code>index</code> of the string <code>v</code>. <code>index</code> shall be within the allowed range of bytes of the string.</p>
<h4><a class="anchor" id="autotoc_md532"></a>
&lt;tt&gt;void string_set_char(string_t v, size_t index, const char c)&lt;/tt&gt;</h4>
<p>Set the byte at position <code>index</code> of the string <code>v</code> to <code>c</code>. <code>index</code> shall be within the allowed range of bytes of the string.</p>
<h4><a class="anchor" id="autotoc_md533"></a>
&lt;tt&gt;bool string_empty_p(const string_t v)&lt;/tt&gt;</h4>
<p>Return true if the string is empty, false otherwise.</p>
<h4><a class="anchor" id="autotoc_md534"></a>
&lt;tt&gt;void string_reserve(string_t v, size_t alloc)&lt;/tt&gt;</h4>
<p>Update the capacity of the string to be able to receive at least <code>alloc</code> bytes. Calling with <code>alloc</code> lower or equal than the size of the string enables the function to perform a shrink of the string to its exact needs. If the string is empty, it will free the memory.</p>
<h4><a class="anchor" id="autotoc_md535"></a>
&lt;tt&gt;void string_set_str(string_t v, const char str[])&lt;/tt&gt;</h4>
<p>Set the string to the array of char <code>str</code>. <code>str</code> is supposed to be <code>\0</code> terminated as any C string.</p>
<h4><a class="anchor" id="autotoc_md536"></a>
&lt;tt&gt;void string_set_strn(string_t v, const char str[], size_t n)&lt;/tt&gt;</h4>
<p>Set the string to the array of char <code>str</code> by copying at most <code>n</code> char from the array. <code>str</code> is supposed to be <code>\0</code> terminated as any C string.</p>
<h4><a class="anchor" id="autotoc_md537"></a>
&lt;tt&gt;const char *string_get_cstr(const string_t v)&lt;/tt&gt;</h4>
<p>Return a constant pointer to the underlying array of char of the string. This array of char is terminated by <code>\0</code>, enabling the pointer to be passed to standard C function. The pointer remains valid until the string itself remains valid and the next call to a function that updates the string.</p>
<h4><a class="anchor" id="autotoc_md538"></a>
&lt;tt&gt;void string_set (string_t v1, const string_t v2)&lt;/tt&gt;</h4>
<p>Set the string <code>v1</code> to the value of the string <code>v2</code>.</p>
<h4><a class="anchor" id="autotoc_md539"></a>
&lt;tt&gt;void string_set_n(string_t v, const string_t ref, size_t offset, size_t length)&lt;/tt&gt;</h4>
<p>Set the string to the value of the string <code>ref</code> by skipping the first <code>offset</code> char of the array of char of <code>ref</code> and copying at most <code>length</code> char in the remaining array of characters of <code>ref</code>. <code>offset</code> shall be within the range of index of the string <code>ref</code>. <code>ref</code> and <code>v</code> cannot be the same string.</p>
<h4><a class="anchor" id="autotoc_md540"></a>
&lt;tt&gt;void string_set_si (string_t v1, const int n)&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md541"></a>
&lt;tt&gt;void string_set_ui (string_t v1, const unsigned n)&lt;/tt&gt;</h4>
<p>Set the string <code>v1</code> to the character representation of the integer <code>n</code>.</p>
<h4><a class="anchor" id="autotoc_md542"></a>
&lt;tt&gt;void string_init_set(string_t v1, const string_t v2)&lt;/tt&gt;</h4>
<p>Initialize <code>v1</code> to the value of the string <code>v2</code>.</p>
<h4><a class="anchor" id="autotoc_md543"></a>
&lt;tt&gt;void string_init_set_str(string_t v1, const char str[])&lt;/tt&gt;</h4>
<p>Initialize <code>v1</code> to the value of the array of char <code>str</code>. The array of char shall be terminated with <code>\0</code>.</p>
<h4><a class="anchor" id="autotoc_md544"></a>
&lt;tt&gt;void string_init_move(string_t v1, string_t v2)&lt;/tt&gt;</h4>
<p>Initialize <code>v1</code> by stealing as most resource from <code>v2</code> as possible and clear <code>v2</code> afterward.</p>
<h4><a class="anchor" id="autotoc_md545"></a>
&lt;tt&gt;void string_move(string_t v1, string_t v2)&lt;/tt&gt;</h4>
<p>Set <code>v1</code> by stealing as most resource from <code>v2</code> as possible and clear <code>v2</code> afterward.</p>
<h4><a class="anchor" id="autotoc_md546"></a>
&lt;tt&gt;void string_swap(string_t v1, string_t v2)&lt;/tt&gt;</h4>
<p>Swap the content of both strings.</p>
<h4><a class="anchor" id="autotoc_md547"></a>
&lt;tt&gt;void string_push_back (string_t v, char c)&lt;/tt&gt;</h4>
<p>Append the character <code>c</code> to the string <code>v</code></p>
<h4><a class="anchor" id="autotoc_md548"></a>
&lt;tt&gt;void string_cat_str(string_t v, const char str[])&lt;/tt&gt;</h4>
<p>Append the array of char <code>str</code> to the string <code>v</code>. The array of char shall be terminated with <code>\0</code>.</p>
<h4><a class="anchor" id="autotoc_md549"></a>
&lt;tt&gt;void string_cat(string_t v, const string_t v2)&lt;/tt&gt;</h4>
<p>Append the string <code>v2</code> to the string <code>v</code>. </p><blockquote class="doxtable">
<p>&zwj;[!NOTE] <code>v2</code> can also be a <code>const char*</code> in C11. </p>
</blockquote>
<h4><a class="anchor" id="autotoc_md550"></a>
&lt;tt&gt;void string_cats(string_t v, const string_t v2[, ...] )&lt;/tt&gt;</h4>
<p>Append all the strings <code>v2</code>, <code>...</code> to the string <code>v</code>. </p><blockquote class="doxtable">
<p>&zwj;[!NOTE] <code>v2</code> can also be a <code>const char*</code> in C11. </p>
</blockquote>
<h4><a class="anchor" id="autotoc_md551"></a>
&lt;tt&gt;void string_sets(string_t v, const string_t v2[, ...] )&lt;/tt&gt;</h4>
<p>Set the string <code>v</code> to the concatenation of all the strings <code>v2</code></p>
<blockquote class="doxtable">
<p>&zwj;[!NOTE] <code>v2</code> can also be a <code>const char*</code> in C11. </p>
</blockquote>
<h4><a class="anchor" id="autotoc_md552"></a>
&lt;tt&gt;int string_cmp_str(const string_t v1, const char str[])&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md553"></a>
&lt;tt&gt;int string_cmp(const string_t v1, const string_t str)&lt;/tt&gt;</h4>
<p>Perform a byte comparison of both string by using the strcmp function and return the result of this comparison.</p>
<h4><a class="anchor" id="autotoc_md554"></a>
&lt;tt&gt;bool string_equal_str_p(const string_t v1, const char str[])&lt;/tt&gt;</h4>
<p>Return true if the string is equal to the array of char, false otherwise.</p>
<h4><a class="anchor" id="autotoc_md555"></a>
&lt;tt&gt;bool string_equal_p(const string_t v1, const string_t v2)&lt;/tt&gt;</h4>
<p>Return true if both strings are equal, false otherwise.</p>
<h4><a class="anchor" id="autotoc_md556"></a>
&lt;tt&gt;int string_cmpi_str(const string_t v, const char str[])&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md557"></a>
&lt;tt&gt;int string_cmpi(const string_t v, const string_t str)&lt;/tt&gt;</h4>
<p>This function compares both strings by ignoring the difference due to the case. This function doesn't work with UTF-8 strings. It returns a negative integer if the string is before the array, 0 if there are equal, a positive integer if the string is after the array.</p>
<h4><a class="anchor" id="autotoc_md558"></a>
&lt;tt&gt;size_t string_search_char (const string_t v, char c [, size_t start])&lt;/tt&gt;</h4>
<p>Search for the character <code>c</code> in the string from the offset <code>start</code>. <code>start</code> shall be within the valid ranges of offset of the string. <code>start</code> is an optional argument. If it is not present, the default value 0 is used instead. This doesn't work if the function is used as function pointer. Return the offset of the string where the character is first found, or <code>STRING_FAILURE</code> otherwise.</p>
<h4><a class="anchor" id="autotoc_md559"></a>
&lt;tt&gt;size_t string_search_rchar (const string_t v, char c [, size_t start])&lt;/tt&gt;</h4>
<p>Search backwards for the character <code>c</code> in the string from the offset <code>start</code>. <code>start</code> shall be within the valid ranges of offset of the string. <code>start</code> is an optional argument. If it is not present, the default value 0 is used instead. This doesn't work if the function is used as function pointer. Return the offset of the string where the character is last found, or <code>STRING_FAILURE</code> otherwise.</p>
<h4><a class="anchor" id="autotoc_md560"></a>
&lt;tt&gt;size_t string_search_str (const string_t v, char str[] [, size_t start])&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md561"></a>
&lt;tt&gt;size_t string_search (const string_t v, string_t str [, size_t start])&lt;/tt&gt;</h4>
<p>Search for the string <code>str</code> in the string from the offset <code>start</code>. <code>start</code> shall be within the valid ranges of offset of the string. <code>start</code> is an optional argument. If it is not present, the default value 0 is used instead. This doesn't work if the function is used as function pointer. Return the offset of the string where <code>str</code> is first found, or <code>STRING_FAILURE</code> otherwise.</p>
<h4><a class="anchor" id="autotoc_md562"></a>
&lt;tt&gt;size_t string_pbrk(const string_t v, const char first_of[] [, size_t start])&lt;/tt&gt;</h4>
<p>Search for the first occurrence in the string <code>v</code> from the offset <code>start</code> of any the bytes in the string <code>first_of</code>. <code>start</code> shall be within the valid ranges of offset of the string. <code>start</code> is an optional argument. If it is not present, the default value 0 is used instead. This doesn't work if the function is used as function pointer. Return the offset of the string where <code>str</code> is first found, or <code>STRING_FAILURE</code> otherwise.</p>
<h4><a class="anchor" id="autotoc_md563"></a>
&lt;tt&gt;int string_strcoll_str(const string_t str1, const char str2[])&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md564"></a>
&lt;tt&gt;int string_strcoll(const string_t str1, const string_t str2[])&lt;/tt&gt;</h4>
<p>Compare the two strings <code>str1</code> and <code>str2</code>. It returns an integer less than, equal to, or greater than zero if <code>s1</code> is found, respectively, to be less than, to match, or be greater than <code>s2</code>. The comparison is based on strings interpreted as appropriate for the program's current locale.</p>
<h4><a class="anchor" id="autotoc_md565"></a>
&lt;tt&gt;size_t string_spn(const string_t v1, const char accept[])&lt;/tt&gt;</h4>
<p>Calculate the length (in bytes) of the initial segment of the string that consists entirely of bytes in accept.</p>
<h4><a class="anchor" id="autotoc_md566"></a>
&lt;tt&gt;size_t string_cspn(const string_t v1, const char reject[])&lt;/tt&gt;</h4>
<p>Calculate the length (in bytes) of the initial segment of the string that consists entirely of bytes not in reject.</p>
<h4><a class="anchor" id="autotoc_md567"></a>
&lt;tt&gt;void string_left(string_t v, size_t index)&lt;/tt&gt;</h4>
<p>Keep at most the <code>index</code> left bytes of the string, terminating the string at the given index. <code>index</code> can be out of range.</p>
<h4><a class="anchor" id="autotoc_md568"></a>
&lt;tt&gt;void string_right(string_t v, size_t index)&lt;/tt&gt;</h4>
<p>Keep the right part of the string, after the index <code>index</code>.</p>
<h4><a class="anchor" id="autotoc_md569"></a>
&lt;tt&gt;void string_mid (string_t v, size_t index, size_t size)&lt;/tt&gt;</h4>
<p>Extract the medium string from offset <code>index</code> and up to <code>size</code> bytes.</p>
<h4><a class="anchor" id="autotoc_md570"></a>
&lt;tt&gt;size_t string_replace_str (string_t v, const char str1[], const char str2[] [, size_t start])&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md571"></a>
&lt;tt&gt;size_t string_replace (string_t v, const string_t str1, const string_t str2 [ , size_t start])&lt;/tt&gt;</h4>
<p>Replace in the string <code>v</code> from the offset <code>start</code> the string <code>str1</code> by the string <code>str2</code> once. Returns the offset of the replacement or <code>STRING_FAILURE</code> if no replacement was performed. <code>str1</code> shall be a non-empty string.</p>
<h4><a class="anchor" id="autotoc_md572"></a>
&lt;tt&gt;size_t string_replace_all_str (string_t v, const char str1[], const char str2[])&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md573"></a>
&lt;tt&gt;size_t string_replace_all (string_t v, const string_t str1, const string_t str2)&lt;/tt&gt;</h4>
<p>Replace in the string <code>v</code> all the occurrences of the string <code>str1</code> by the string <code>str2</code>. <code>str1</code> shall be a non-empty string.</p>
<h4><a class="anchor" id="autotoc_md574"></a>
&lt;tt&gt;void string_replace_at (string_t v, size_t pos, size_t len, const char str2[])&lt;/tt&gt;</h4>
<p>Replace in the string <code>v</code> the sub-string defined as starting from <code>pos</code> and of size <code>len</code> by the string <code>str2</code>. It assumes that <code>pos + len</code> is before the end of the string of <code>v</code>.</p>
<h4><a class="anchor" id="autotoc_md575"></a>
&lt;tt&gt;void string_init_printf(string_t v, const char format[], ...)&lt;/tt&gt;</h4>
<p>Initialize <code>v</code> to the formatted string <code>format</code> with the given variable argument lists. <code>format</code> is like the printf function family.</p>
<h4><a class="anchor" id="autotoc_md576"></a>
&lt;tt&gt;void string_init_vprintf(string_t v, const char format[], va_list args)&lt;/tt&gt;</h4>
<p>Initialize <code>v</code> to the formatted string <code>format</code> with the given variable argument lists <code>args</code>. <code>format</code> is like the <code>printf</code> function family.</p>
<h4><a class="anchor" id="autotoc_md577"></a>
&lt;tt&gt;int string_printf (string_t v, const char format[], ...)&lt;/tt&gt;</h4>
<p>Set the string <code>v</code> to the formatted string <code>format</code>. <code>format</code> is like the <code>printf</code> function family with the given variable argument list. Return the number of characters printed (excluding the final <code>\0</code> char), or a negative value in case of error.</p>
<h4><a class="anchor" id="autotoc_md578"></a>
&lt;tt&gt;int string_vprintf (string_t v, const char format[], va_list args)&lt;/tt&gt;</h4>
<p>Set the string <code>v</code> to the formatted string <code>format</code>. <code>format</code> is like the <code>vprintf</code> function family with the variable argument list <code>args</code>. Return the number of characters printed (excluding the final <code>\0</code> char), or a negative value in case of error.</p>
<h4><a class="anchor" id="autotoc_md579"></a>
&lt;tt&gt;int string_cat_printf (string_t v, const char format[], ...)&lt;/tt&gt;</h4>
<p>Appends to the string <code>v</code> the formatted string <code>format</code>. <code>format</code> is like the <code>printf</code> function family.</p>
<h4><a class="anchor" id="autotoc_md580"></a>
&lt;tt&gt;bool string_fgets(string_t v, FILE *f, string_fgets_t arg)&lt;/tt&gt;</h4>
<p>Read from the opened file <code>f</code> a stream of characters and set <code>v</code> with this stream. It stops after the character end of line if arg is <code>STRING_READ_PURE_LINE</code> or <code>STRING_READ_LINE</code>, and until the end of the file if arg is <code>STRING_READ_FILE</code>. If arg is <code>STRING_READ_PURE_LINE</code>, the character end of line is removed from the string. Return true if something has been read, false otherwise.</p>
<h4><a class="anchor" id="autotoc_md581"></a>
&lt;tt&gt;bool string_fget_word (string_t v, const char separator[], FILE *f)&lt;/tt&gt;</h4>
<p>Read a word from the file <code>f</code> and set <code>v</code> with this word. A word is separated from another by the list of characters in the array <code>separator</code>. (Example: <code>^ \t.\n</code>). It is highly recommended for separator to be a constant string. <code>separator</code> shall be at most composed of <code>100</code> bytes. It works with UTF8 stream with the restriction that the separator character shall only be ASCII character.</p>
<h4><a class="anchor" id="autotoc_md582"></a>
&lt;tt&gt;void string_fputs(FILE *f, const string_t v)&lt;/tt&gt;</h4>
<p>Put the string in the file.</p>
<h4><a class="anchor" id="autotoc_md583"></a>
&lt;tt&gt;bool string_start_with_str_p(const string_t v, const char str[])&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md584"></a>
&lt;tt&gt;bool string_start_with_string_p(const string_t v, const string_t str)&lt;/tt&gt;</h4>
<p>Return true if the string starts with the same characters than <code>str</code>, false otherwise.</p>
<h4><a class="anchor" id="autotoc_md585"></a>
&lt;tt&gt;bool string_end_with_str_p(const string_t v, const char str[])&lt;/tt&gt;</h4>
<h4><a class="anchor" id="autotoc_md586"></a>
&lt;tt&gt;bool string_end_with_string_p(const string_t v, const string_t str)&lt;/tt&gt;</h4>
<p>Return true if the string ends with the same characters than <code>str</code>, false otherwise.</p>
<h4><a class="anchor" id="autotoc_md587"></a>
&lt;tt&gt;size_t string_hash(const string_t v)&lt;/tt&gt;</h4>
<p>Return a hash of the string.</p>
<h4><a class="anchor" id="autotoc_md588"></a>
&lt;tt&gt;void string_strim(string_t v [, const char charTab[]])&lt;/tt&gt;</h4>
<p>Remove from the string any leading or trailing space-like characters (space or tabulation or end of line). If <code>charTab</code> is given, it get the list of characters to remove from this argument.</p>
<h4><a class="anchor" id="autotoc_md589"></a>
&lt;tt&gt;bool string_oor_equal_p(const string_t v, unsigned char n)&lt;/tt&gt;</h4>
<p>Provide the <code>OOR_EQUAL_P</code> method of a string.</p>
<h4><a class="anchor" id="autotoc_md590"></a>
&lt;tt&gt;void string_oor_set(string_t v, unsigned char n)&lt;/tt&gt;</h4>
<p>Provide the <code>OOR_SET</code> method of a string.</p>
<h4><a class="anchor" id="autotoc_md591"></a>
&lt;tt&gt;void string_get_str(string_t v, const string_t v2, bool append)&lt;/tt&gt;</h4>
<p>Convert a string into a formatted string usable for I/O: Outputs the input string with quote around, replacing any <code>"&lt;/tt&gt; by &lt;tt&gt;\\"&lt;/tt&gt; within the string
into the output string.

@paragraph autotoc_md592 &lt;tt&gt;bool string_parse_str(string_t v, const char str[], const char **endp)&lt;/tt&gt;

Parse the formatted string &lt;tt&gt;str&lt;/tt&gt; that is assumed to be a string representation of a string
and set &lt;tt&gt;v&lt;/tt&gt; to this representation.
This method is only defined if the type of the element defines a &lt;tt&gt;PARSE_STR&lt;/tt&gt; method itself.
It returns true if success, false otherwise.
If &lt;tt&gt;endp&lt;/tt&gt; is not NULL, it sets &lt;tt&gt;*endp&lt;/tt&gt; to the pointer of the first character not
decoded by the function.

@paragraph autotoc_md593 &lt;tt&gt;void string_out_str(FILE *f, const string_t v)&lt;/tt&gt;

Write a string into a &lt;tt&gt;FILE*&lt;/tt&gt; as a formatted string:
Outputs the input string while quoting around,
replacing any &lt;tt&gt;"</code> by <code>\"&lt;/tt&gt; within the string,
and quote special characters.

@paragraph autotoc_md594 &lt;tt&gt;bool string_in_str(string_t v, FILE *f)&lt;/tt&gt;

Read a formatted string from a &lt;tt&gt;FILE*&lt;/tt&gt;. The string shall follow the formatting rules of &lt;tt&gt;string_out_str&lt;/tt&gt;.
It returns true if it has successfully parsed the string,
false otherwise. In this case, the position within the &lt;tt&gt;FILE*&lt;/tt&gt;
is undefined.

@paragraph autotoc_md595 &lt;tt&gt;string_unicode_t&lt;/tt&gt;

Define a type suitable to store an unicode code point as an integer.

@paragraph autotoc_md596 &lt;tt&gt;string_it_t&lt;/tt&gt;

Define an iterator over the string, enabling to
iterate the string over UTF8 encoded code point.

The basic element of the string is a byte.
An UTF-8 code point is composed of one to four bytes, encoded in a variable way.
However, a Unicode character can be also composed of one or more code point.
(See &lt;a href="<a href="https://en.wikipedia.org/wiki/UTF-8">https://en.wikipedia.org/wiki/UTF-8</a>" &gt;UTF-8&lt;/a&gt; )

This library doesn't provide any treatment over code points.

@paragraph autotoc_md597 &lt;tt&gt;void string_it(string_it_t it, const string_t str)&lt;/tt&gt;

Initialize the iterator &lt;tt&gt;it&lt;/tt&gt; to iterate over the UTF-8 code points of
string &lt;tt&gt;str&lt;/tt&gt;.

@paragraph autotoc_md598 &lt;tt&gt;void string_it_end(string_it_t it, const string_t str)&lt;/tt&gt;

Initialize the iterator &lt;tt&gt;it&lt;/tt&gt; to the end iteration of the string &lt;tt&gt;str&lt;/tt&gt;.

@paragraph autotoc_md599 &lt;tt&gt;void string_it_set(string_it_t it1, const string_it_t it2)&lt;/tt&gt;

Initialize the iterator &lt;tt&gt;it1&lt;/tt&gt; to the same position than &lt;tt&gt;it2&lt;/tt&gt;.

@paragraph autotoc_md600 &lt;tt&gt;void string_it_pos(string_it_t it, const string_t str, size_t pos)&lt;/tt&gt;

Initialize the iterator &lt;tt&gt;it&lt;/tt&gt; to iterate over the UTF-8 code points
of string &lt;tt&gt;str&lt;/tt&gt;, starting from position &lt;tt&gt;pos&lt;/tt&gt;.
&lt;tt&gt;pos&lt;/tt&gt; shall be within the size of the string.
&lt;tt&gt;pos&lt;/tt&gt; shall reference the starting point of an UTF-8 code point.

@paragraph autotoc_md601 &lt;tt&gt;bool string_end_p (string_it_t it)&lt;/tt&gt;

Return true if the iterator has reached the end of the string,
false otherwise.

@paragraph autotoc_md602 &lt;tt&gt;void string_next (string_it_t it)&lt;/tt&gt;

Move the iterator to the next UTF8 encoded code point.

@paragraph autotoc_md603 &lt;tt&gt;void string_previous (string_it_t it)&lt;/tt&gt;

Move the iterator to the previous UTF8 encoded code point.

@paragraph autotoc_md604 &lt;tt&gt;string_unicode_t string_get_cref (const string_it_t it)&lt;/tt&gt;

Return the unicode code point associated to the iterator.
It returns &lt;tt&gt;-1&lt;/tt&gt; in case of error in decoding the UTF8 string.

@paragraph autotoc_md605 &lt;tt&gt;size_t string_it_get_pos (const string_it_t it)&lt;/tt&gt;

Return the position in the stream of the iterator &lt;tt&gt;it&lt;/tt&gt;.

@paragraph autotoc_md606 &lt;tt&gt;void string_it_set_ref(string_it_t it, string_t str, string_unicode_t u)&lt;/tt&gt;

Replace the unicode code point referenced by &lt;tt&gt;it&lt;/tt&gt; to the unicode code point &lt;tt&gt;u&lt;/tt&gt;
in the string &lt;tt&gt;str&lt;/tt&gt;.
If &lt;tt&gt;u&lt;/tt&gt; is &lt;tt&gt;0&lt;/tt&gt;, then it will resize the string to the size of the referenced iterator
only keeping the unicode code points before the iterator.
&lt;tt&gt;it&lt;/tt&gt; shall be a valid iterator of &lt;tt&gt;str&lt;/tt&gt;.

@paragraph autotoc_md607 &lt;tt&gt;bool string_it_equal_p (const string_it_t it1, const string_it_t it2)&lt;/tt&gt;

Return true if both iterators reference the same position, false otherwise.

@paragraph autotoc_md608 &lt;tt&gt;void string_push_u (string_t str, string_unicode_t u)&lt;/tt&gt;

Push the unicode code point &lt;tt&gt;u&lt;/tt&gt; into the string &lt;tt&gt;str&lt;/tt&gt;
encoding it as a variable UTF8 encoded code point.

@paragraph autotoc_md609 &lt;tt&gt;bool string_pop_u (string_unicode_t *u, string_t str)&lt;/tt&gt;

Pop the last unicode code point from the string &lt;tt&gt;str&lt;/tt&gt;
encoded as a variable UTF8 encoded code point
and store in &lt;tt&gt;*u&lt;/tt&gt; the popped unicode code point if &lt;tt&gt;u&lt;/tt&gt; is not NULL.
It returns true in case of success or false otherwise (no character to pop or no valid UTF8).

@paragraph autotoc_md610 &lt;tt&gt;size_t string_length_u(string_t str)&lt;/tt&gt;

Return the number of UTF8 encoded code point in the string.

@paragraph autotoc_md611 &lt;tt&gt;bool string_utf8_p(string_t str)&lt;/tt&gt;

Return true if the string is a valid UTF8, false otherwise.
It doesn't check for unique canonical form for UTF8 string.

@paragraph autotoc_md612 &lt;tt&gt;STRING_CTE(string)&lt;/tt&gt;

Macro to convert a constant C string into a temporary &lt;tt&gt;string_t&lt;/tt&gt; variable
suitable only for being called within a function.

@paragraph autotoc_md613 &lt;tt&gt;STRING_OPLIST&lt;/tt&gt;

The oplist of a &lt;tt&gt;string_t&lt;/tt&gt;

@paragraph autotoc_md614 &lt;tt&gt;BOUNDED_STRING_DEF(name, size)&lt;/tt&gt;

Define a bounded string of size &lt;tt&gt;size&lt;/tt&gt;, aka &lt;tt&gt;char[ size + 1 ]&lt;/tt&gt; (including the final &lt;tt&gt;\\0&lt;/tt&gt; char).

&lt;h5&gt;Created types&lt;/h5&gt;

The following types are automatically defined by the previous definition macro if not provided by the user:

&lt;h5&gt;&lt;tt&gt;name_t&lt;/tt&gt;&lt;/h5&gt;

Type of the concurrent container of &lt;tt&gt;type&lt;/tt&gt;.

&lt;h5&gt;Generic methods&lt;/h5&gt;

The following methods of the generic interface are defined (See @ref "Generic-API-Interface-Adaptation" "generic interface" for details):

@icode{C} 
void name_init(name_t bounded_string)
void name_init_set(name_t bounded_string, const name_t src)
void name_set(name_t bounded_string, const name_t src)
void name_reset(name_t bounded_string)
void name_clear(name_t bounded_string)
size_t name_size(const name_t bounded_string)
size_t name_capacity(const name_t bounded_string)
bool name_empty_p(const name_t bounded_string)
void name_get_str(string_t str, name_t bounded_string, bool append)
void name_out_str(FILE *file, name_t bounded_string)
bool name_parse_str(name_t bounded_string, const char str[], const char **end)
bool name_in_str(name_t bounded_string, FILE *file)
m_serial_return_code_t name_out_serial(m_serial_write_t serial, const name_t bounded_string)
m_serial_return_code_t name_in_str(name_t bounded_string, m_serial_read_t serial)
bool name_equal_p(name_t bounded_string1, name_t bounded_string2)
int name_cmp(const name_t bounded_string1, const name_t bounded_string2)
size_t name_hash(name_t bounded_string)
@endicode 

&lt;h5&gt;Specialized methods&lt;/h5&gt;

The following specialized methods are automatically created by the previous definition macro:

&lt;h5&gt;&lt;tt&gt;void name_init_set_cstr(bounded_t string, const char str[])&lt;/tt&gt;&lt;/h5&gt;

Initialize the bounded string to the given C string &lt;tt&gt;str&lt;/tt&gt;, truncating if needed.

&lt;h5&gt;&lt;tt&gt;void name_set_cstr(bounded_t string, const char str[])&lt;/tt&gt;&lt;/h5&gt;

Set the bounded string &lt;tt&gt;string&lt;/tt&gt; to the given C string &lt;tt&gt;str&lt;/tt&gt;, truncating if needed.

&lt;h5&gt;&lt;tt&gt;void name_set_cstrn(bounded_t string, const char str[], size_t n)&lt;/tt&gt;&lt;/h5&gt;

Set the bounded string &lt;tt&gt;string&lt;/tt&gt; to the &lt;tt&gt;n&lt;/tt&gt; first byte characters of the given C string &lt;tt&gt;str&lt;/tt&gt;, truncating if needed.

&lt;h5&gt;&lt;tt&gt;void name_set_n(bounded_t string, const bounded_t string, size_t offset, size_t length)&lt;/tt&gt;&lt;/h5&gt;

Set the bounded string &lt;tt&gt;string&lt;/tt&gt; to the &lt;tt&gt;length&lt;/tt&gt; first byte characters from the offset &lt;tt&gt;offset&lt;/tt&gt;
of the bounded given C string &lt;tt&gt;str&lt;/tt&gt;, truncating if needed.

&lt;h5&gt;&lt;tt&gt;const char *name_get_cstr(const bounded_t string)&lt;/tt&gt;&lt;/h5&gt;

Return the C string representation of the bounded string.

&lt;h5&gt;&lt;tt&gt;char name_get_char(const bounded_t string, size_t index)&lt;/tt&gt;&lt;/h5&gt;

Return the byte character at the given index of the string.
&lt;tt&gt;index&lt;/tt&gt; shall be within the size of the string.

&lt;h5&gt;&lt;tt&gt;void name_cat(bounded_t string, const bounded_t  str)&lt;/tt&gt;&lt;/h5&gt;
&lt;h5&gt;&lt;tt&gt;void name_cat_cstr(bounded_t string, const char str[])&lt;/tt&gt;&lt;/h5&gt;

Concat the given C string to the bounded string.

&lt;h5&gt;&lt;tt&gt;int name_cmp_cstr(const bounded_t string, const char str[])&lt;/tt&gt;&lt;/h5&gt;

Compared the bounded string to the given C string:
return a &lt;tt&gt;negative&lt;/tt&gt; integer if the bounded string is before the C string,
&lt;tt&gt;0&lt;/tt&gt; if there are equals,
a &lt;tt&gt;positive&lt;/tt&gt; integer otherwise.

&lt;h5&gt;&lt;tt&gt;bool name_equal_cstr_p(const bounded_t string, const char str[])&lt;/tt&gt;&lt;/h5&gt;

Return true if the bounded string is equal to the given C string.

&lt;h5&gt;&lt;tt&gt;int name_printf(bounded_t string, const char format[], ...)&lt;/tt&gt;&lt;/h5&gt;

Set the bounded string to the format C string.

&lt;h5&gt;&lt;tt&gt;int name_cat_printf(bounded_t string, const char format[], ...)&lt;/tt&gt;&lt;/h5&gt;

Concat to the bounded string the format C string.

&lt;h5&gt;&lt;tt&gt;bool name_fgets(bounded_t string, FILE *f, string_fgets_t arg)&lt;/tt&gt;&lt;/h5&gt;

Read at most &lt;tt&gt;max_size + 1&lt;/tt&gt; bytes from the file &lt;tt&gt;f&lt;/tt&gt; and set the bounded string to it.

&lt;h5&gt;&lt;tt&gt;bool name_fputs(FILE *f, const bounded_t string)&lt;/tt&gt;&lt;/h5&gt;

Put the bounded string to the file &lt;tt&gt;f&lt;/tt&gt;.

&lt;h5&gt;&lt;tt&gt;bool name_oor_equal_p(const bounded_t string, unsigned char n)&lt;/tt&gt;&lt;/h5&gt;

Provide the &lt;tt&gt;OOR_EQUAL_P&lt;/tt&gt; method of a string.

&lt;h5&gt;&lt;tt&gt;void name_oor_set(bounded_t string, unsigned char n)&lt;/tt&gt;&lt;/h5&gt;

Provide the &lt;tt&gt;OOR_SET&lt;/tt&gt; method of a string.

&lt;hr&gt;

@subsection autotoc_md615 M-CORE

This header is the internal core of M*LIB, providing a lot of functionality 
by extending the preprocessing capability.
Working with these macros is not easy and the developer needs to know
how the macro preprocessing works.
It also adds the needed macro for handling the oplist.
As a consequence, it is needed by all other header files.

A few macros are using recursion to work.
This is not an easy feat to do as it needs some tricks to work (see
reference).
This still work well with only one major limitation: it can not be chained.
For example, if &lt;tt&gt;MACRO&lt;/tt&gt; is a macro implementing recursion, then
&lt;tt&gt;MACRO(MACRO())&lt;/tt&gt; won't work.

Example:

@icode{C} 
M_MAP(f, 1, 2, 3, 4)
M_REDUCE(f, g, 1, 2, 3, 4)
M_SEQ(1, 20, f)
@endicode 

@subsubsection autotoc_md616 Compiler Macros

The following compiler macros are available:

@paragraph autotoc_md617 &lt;tt&gt;M_ASSUME(cond)&lt;/tt&gt;

&lt;tt&gt;M_ASSUME&lt;/tt&gt; is equivalent to assert, but gives hints to compiler
about how to optimize the code if NDEBUG is defined.

@paragraph autotoc_md618 &lt;tt&gt;M_LIKELY(cond) / M_UNLIKELY(cond)&lt;/tt&gt;

&lt;tt&gt;M_LIKELY&lt;/tt&gt; / &lt;tt&gt;M_UNLIKELY&lt;/tt&gt; gives hints on the compiler of the likelihood
of the given condition.

@subsubsection autotoc_md619 Preprocessing macro extension

@paragraph autotoc_md620 &lt;tt&gt;M_MAX_NB_ARGUMENT&lt;/tt&gt;

Maximum default number of argument that can be handled by this header.
It is currently 52 (even if some local macros may have increased this limit).

@paragraph autotoc_md621 &lt;tt&gt;M_C(a,b)&lt;/tt&gt;
@paragraph autotoc_md622 &lt;tt&gt;M_C3(a,b,c)&lt;/tt&gt;
@paragraph autotoc_md623 &lt;tt&gt;M_C4(a,b,c,d)&lt;/tt&gt;

Return a symbol corresponding to the concatenation of the input arguments.

@paragraph autotoc_md624 &lt;tt&gt;M_F(base, suffix)&lt;/tt&gt;

Return a function name corresponding to the concatenation of the input arguments.
In developer mode, it can be overrided before inclusion of any header to support user customization of suffix. 
To do this you need to define &lt;tt&gt;M_F&lt;/tt&gt; as &lt;tt&gt;M_OVERRIDE_F&lt;/tt&gt;, then define as many suffix macros as needed. As suffix macro shall be named &lt;tt&gt;M_OVERRIDE_ \#\# suffix ()&lt;/tt&gt; and each generated suffix shall start with a comma (preliminary interface).

Example:

@icode{C} 
#define M_F(a,b) M_OVERRIDE_F(a,b)
#define M_OVERRIDE__clear() , _cleanup ,
#include "<a class="el" href="m-core_8h_source.html">m-core.h</a>"
@endicode 

@paragraph autotoc_md625 &lt;tt&gt;M_INC(number)&lt;/tt&gt;

Increment the number given as argument and return 
a pre-processing token corresponding to this value (meaning it is evaluated
at macro processing stage, not at compiler stage).
The number shall be within the range &lt;tt&gt;[ 0..M_MAX_NB_ARGUMENT - 1 ]&lt;/tt&gt;.

@paragraph autotoc_md626 &lt;tt&gt;M_DEC(number)&lt;/tt&gt;

Decrement the number given as argument and return 
a pre-processing token corresponding to this value (meaning it is evaluated
at macro processing stage, not at compiler stage).
The number shall be within the range &lt;tt&gt;[ 1..M_MAX_NB_ARGUMENT ]&lt;/tt&gt;.

@paragraph autotoc_md627 &lt;tt&gt;M_ADD(x, y)&lt;/tt&gt;

Return x+y (resolution is performed at preprocessing time).
&lt;tt&gt;x&lt;/tt&gt;, &lt;tt&gt;y&lt;/tt&gt; shall be within &lt;tt&gt;[ 0..M_MAX_NB_ARGUMENT ]&lt;/tt&gt;.
If the result is not in &lt;tt&gt;[ 0..M_MAX_NB_ARGUMENT + 1 ]&lt;/tt&gt;, it returns &lt;tt&gt;M_OVERFLOW&lt;/tt&gt;.

@paragraph autotoc_md628 &lt;tt&gt;M_SUB(x, y)&lt;/tt&gt;

Return &lt;tt&gt;x&lt;/tt&gt; and &lt;tt&gt;y&lt;/tt&gt; (resolution is performed at preprocessing time).
&lt;tt&gt;x&lt;/tt&gt;, &lt;tt&gt;y&lt;/tt&gt; shall be within &lt;tt&gt;[ 0..M_MAX_NB_ARGUMENT ]&lt;/tt&gt;.
If the result is not in &lt;tt&gt;[ 0..M_MAX_NB_ARGUMENT ]&lt;/tt&gt;, it returns &lt;tt&gt;M_UNDERFLOW&lt;/tt&gt;.

@paragraph autotoc_md629 &lt;tt&gt;M_BOOL(cond)&lt;/tt&gt;

Convert an integer or a symbol into &lt;tt&gt;0&lt;/tt&gt; (if 0) or &lt;tt&gt;1&lt;/tt&gt; (if not 0 or symbol unknown).
Return a pre-processing token corresponding to this value (meaning it is evaluated
at macro processing stage, not at compiler stage).

@paragraph autotoc_md630 &lt;tt&gt;M_INV(cond)&lt;/tt&gt;

Inverse 0 into 1 and 1 into 0. It is undefined if cond is not 0 or 1
(You could use &lt;tt&gt;M_BOOL&lt;/tt&gt; to convert). 
Return a pre-processing token corresponding to this value (meaning it is evaluated
at macro processing stage, not at compiler stage).

@paragraph autotoc_md631 &lt;tt&gt;M_AND(cond1, cond2)&lt;/tt&gt;

Perform a logical &lt;tt&gt;AND&lt;/tt&gt; between &lt;tt&gt;cond1&lt;/tt&gt; and &lt;tt&gt;cond2&lt;/tt&gt;. 
&lt;tt&gt;cond1&lt;/tt&gt; and &lt;tt&gt;cond2&lt;/tt&gt; shall be 0 or 1.
(You could use &lt;tt&gt;M_BOOL&lt;/tt&gt; to convert).
Return a pre-processing token corresponding to this value (meaning it is evaluated
at macro processing stage, not at compiler stage).

@paragraph autotoc_md632 &lt;tt&gt;M_OR(cond1, cond2)&lt;/tt&gt;

Perform a logical &lt;tt&gt;OR&lt;/tt&gt; between cond1 and cond2. 
&lt;tt&gt;cond1&lt;/tt&gt; and &lt;tt&gt;cond2&lt;/tt&gt; shall be 0 or 1.
(You could use &lt;tt&gt;M_BOOL&lt;/tt&gt; to convert).
Return a pre-processing token corresponding to this value (meaning it is evaluated
at macro processing stage, not at compiler stage).

@paragraph autotoc_md633 &lt;tt&gt;M_NOTEQUAL(x, y)&lt;/tt&gt;

Return 1 if &lt;tt&gt;x != y&lt;/tt&gt;, 0 otherwise (resolution is performed at preprocessing time).
&lt;tt&gt;x&lt;/tt&gt; and &lt;tt&gt;y&lt;/tt&gt; shall be within &lt;tt&gt;[ 0..M_MAX_NB_ARGUMENT ]&lt;/tt&gt;.

@paragraph autotoc_md634 &lt;tt&gt;M_EQUAL(x, y)&lt;/tt&gt;

Return 1 if &lt;tt&gt;x == y&lt;/tt&gt;, 0 otherwise (resolution is performed at preprocessing time).
&lt;tt&gt;x&lt;/tt&gt; and &lt;tt&gt;y&lt;/tt&gt; shall be within &lt;tt&gt;[ 0..M_MAX_NB_ARGUMENT ]&lt;/tt&gt;.

@paragraph autotoc_md635 &lt;tt&gt;M_LESS_THAN_P(x, y)&lt;/tt&gt;

Return 1 if &lt;tt&gt;x \&lt; y&lt;/tt&gt;, 0 otherwise (resolution is performed at preprocessing time).
&lt;tt&gt;x&lt;/tt&gt; and &lt;tt&gt;y&lt;/tt&gt; shall be within &lt;tt&gt;[ 0..M_MAX_NB_ARGUMENT ]&lt;/tt&gt;.

@paragraph autotoc_md636 &lt;tt&gt;M_LESS_OR_EQUAL_P(x, y)&lt;/tt&gt;

Return 1 if &lt;tt&gt;x \&lt;= y&lt;/tt&gt;, 0 otherwise (resolution is performed at preprocessing time).
x and y shall be within &lt;tt&gt;[ 0..M_MAX_NB_ARGUMENT ]&lt;/tt&gt;.

@paragraph autotoc_md637 &lt;tt&gt;M_GREATER_OR_EQUAL_P(x, y)&lt;/tt&gt;

Return 1 if &lt;tt&gt;x \&gt;= y&lt;/tt&gt;, 0 otherwise (resolution is performed at preprocessing time).
&lt;tt&gt;x&lt;/tt&gt; and &lt;tt&gt;y&lt;/tt&gt; shall be within &lt;tt&gt;[ 0..M_MAX_NB_ARGUMENT ]&lt;/tt&gt;.

@paragraph autotoc_md638 &lt;tt&gt;M_GREATER_THAN_P(x, y)&lt;/tt&gt;

Return 1 if &lt;tt&gt;x \&gt; y&lt;/tt&gt;, 0 otherwise (resolution is performed at preprocessing time).
&lt;tt&gt;x&lt;/tt&gt; and &lt;tt&gt;y&lt;/tt&gt; shall be within &lt;tt&gt;[ 0..M_MAX_NB_ARGUMENT ]&lt;/tt&gt;.

@paragraph autotoc_md639 &lt;tt&gt;M_COMMA_P(arglist)&lt;/tt&gt;

Return 1 if there is a comma inside the argument list, 0 otherwise.
Return a pre-processing token corresponding to this value (meaning it is evaluated
at macro processing stage, not at compiler stage).

@paragraph autotoc_md640 &lt;tt&gt;M_EMPTY_P(expression)&lt;/tt&gt;

Return 1 if the argument &lt;tt&gt;expression&lt;/tt&gt; is &lt;tt&gt;empty&lt;/tt&gt;, 0 otherwise.
Return a pre-processing token corresponding to this value (meaning it is evaluated
at macro processing stage, not at compiler stage).

&lt;blockquote&gt;&amp;zwj;[!NOTE] 
It should work for a wide range of inputs
except when it is called with a macro function that takes
more than one argument and without its arguments
(in which case it generates a compiler error).
It also won't work for expression starting with &lt;tt&gt;)&lt;/tt&gt;
&lt;/blockquote&gt;
@paragraph autotoc_md641 &lt;tt&gt;M_PARENTHESIS_P(expression)&lt;/tt&gt;

Return 1 if the argument &lt;tt&gt;expression&lt;/tt&gt; starts with a parenthesis and ends with it
(like &lt;tt&gt;(...)&lt;/tt&gt;), 0 otherwise.
Return a pre-processing token corresponding to this value (meaning it is evaluated
at macro processing stage, not at compiler stage).

@paragraph autotoc_md642 &lt;tt&gt;M_KEYWORD_P(reference_keyword, get_keyword)&lt;/tt&gt;

Return 1 if the argument &lt;tt&gt;get_keyword&lt;/tt&gt; is equal to &lt;tt&gt;reference_keyword&lt;/tt&gt;,
0 otherwise.
&lt;tt&gt;reference_keyword&lt;/tt&gt; shall be a keyword in the following list:

* &lt;tt&gt;and&lt;/tt&gt;
* &lt;tt&gt;or&lt;/tt&gt;
* &lt;tt&gt;add&lt;/tt&gt; (or sum, they are considered equivalent) 
* &lt;tt&gt;mul&lt;/tt&gt; (or product, they are considered equivalent)
* &lt;tt&gt;void&lt;/tt&gt;
* &lt;tt&gt;bool&lt;/tt&gt;
* &lt;tt&gt;char&lt;/tt&gt;
* &lt;tt&gt;short&lt;/tt&gt;
* &lt;tt&gt;int&lt;/tt&gt;
* &lt;tt&gt;long&lt;/tt&gt;
* &lt;tt&gt;float&lt;/tt&gt;
* &lt;tt&gt;double&lt;/tt&gt;
* &lt;tt&gt;TYPE&lt;/tt&gt;
* &lt;tt&gt;SUBTYPE&lt;/tt&gt;
* &lt;tt&gt;IT_TYPE&lt;/tt&gt;
* &lt;tt&gt;M_OVERFLOW&lt;/tt&gt;
* &lt;tt&gt;M_UNDERFLOW&lt;/tt&gt;
* &lt;tt&gt;SEQUENCE&lt;/tt&gt;
* &lt;tt&gt;MAP&lt;/tt&gt;
* &lt;tt&gt;KEYVAL&lt;/tt&gt;
* &lt;tt&gt;KEYVAL_PTR&lt;/tt&gt;

@paragraph autotoc_md643 &lt;tt&gt;M_IF(cond)(action_if_true, action_if_false)&lt;/tt&gt;

Return the pre-processing token &lt;tt&gt;action_if_true&lt;/tt&gt; if &lt;tt&gt;cond&lt;/tt&gt; is true,
&lt;tt&gt;action_if_false&lt;/tt&gt; otherwise (meaning it is evaluated
at macro processing stage, not at compiler stage).

&lt;tt&gt;cond&lt;/tt&gt; shall be a 0 or 1 as a preprocessing constant.
(You could use &lt;tt&gt;M_BOOL&lt;/tt&gt; to convert).

@paragraph autotoc_md644 &lt;tt&gt;M_IF_EMPTY(cond)(action_if_true, action_if_false)&lt;/tt&gt;

Return the pre-processing token &lt;tt&gt;action_if_true&lt;/tt&gt; if &lt;tt&gt;cond&lt;/tt&gt; is empty,
&lt;tt&gt;action_if_false&lt;/tt&gt; otherwise (meaning it is evaluated
at macro processing stage, not at compiler stage).

@paragraph autotoc_md645 &lt;tt&gt;M_DELAY1(expr)&lt;/tt&gt;
@paragraph autotoc_md646 &lt;tt&gt;M_DELAY2(expr)&lt;/tt&gt;
@paragraph autotoc_md647 &lt;tt&gt;M_DELAY3(expr)&lt;/tt&gt;
@paragraph autotoc_md648 &lt;tt&gt;M_DELAY4(expr)&lt;/tt&gt;
@paragraph autotoc_md649 &lt;tt&gt;M_ID(...)&lt;/tt&gt;

Delay the evaluation by 1, 2, 3 or 4 steps.
This is necessary to write macros that are recursive.
The argument is a macro-function that has to be deferred.
&lt;tt&gt;M_ID&lt;/tt&gt; is an equivalent of &lt;tt&gt;M_DELAY1&lt;/tt&gt;.

@paragraph autotoc_md650 &lt;tt&gt;M_EVAL(expr)&lt;/tt&gt;

Perform a complete stage evaluation of the given expression,
removing recursive expression within it.
Only &lt;strong&gt;ONE&lt;/strong&gt; &lt;tt&gt;M_EVAL&lt;/tt&gt; expression is expected in the evaluation chain.
Can not be chained.

@paragraph autotoc_md651 &lt;tt&gt;M_APPLY(func, args...)&lt;/tt&gt;

Apply &lt;tt&gt;func&lt;/tt&gt; to &lt;tt&gt;(args...)&lt;/tt&gt; ensuring
that &lt;tt&gt;func()&lt;/tt&gt; isn't evaluated until all &lt;tt&gt;args&lt;/tt&gt; have been also evaluated.
It is used to delay evaluation.

@paragraph autotoc_md652 &lt;tt&gt;M_EAT(...)&lt;/tt&gt;

Clobber the input, whatever it is.

@paragraph autotoc_md653 &amp;lsquo;M_RET_ARG'N&amp;rsquo;(arglist...)`

Return the argument &lt;tt&gt;N&lt;/tt&gt; of the given &lt;tt&gt;arglist&lt;/tt&gt;.
&lt;tt&gt;N&lt;/tt&gt;shall be within &lt;tt&gt;[ 1..76 ]&lt;/tt&gt;.
The argument shall exist in the &lt;tt&gt;arglist&lt;/tt&gt;.
The &lt;tt&gt;arglist&lt;/tt&gt; shall have at least one more argument that &lt;tt&gt;N&lt;/tt&gt;.

@paragraph autotoc_md654 &lt;tt&gt;M_GET_AT(list, index)&lt;/tt&gt;

Return the index &lt;tt&gt;index&lt;/tt&gt; of the list &lt;tt&gt;list&lt;/tt&gt;,
which is a list of arguments encapsulated with parenthesis,
(it is not a true C array).
Return the pre-processing token corresponding to this value (meaning it is evaluated
at macro processing stage, not at compiler stage).

@icode{C} 
M_GET_AT((f_0,f_1,f_2),1)
==&gt;
f_1
@endicode 

@paragraph autotoc_md655 &lt;tt&gt;M_SKIP_ARGS(N,...)&lt;/tt&gt;

Skip the Nth first arguments of the argument list.
&lt;tt&gt;N&lt;/tt&gt; shall be within &lt;tt&gt;[ 0..M_MAX_NB_ARGUMENT ]&lt;/tt&gt;.

@icode{C} 
M_SKIP_ARGS(2, a, b, c, d)
==&gt;
c, d
@endicode 

@paragraph autotoc_md656 &lt;tt&gt;M_KEEP_ARGS(N,...)&lt;/tt&gt;

Keep the &lt;tt&gt;Nth&lt;/tt&gt; first arguments of the argument list.
&lt;tt&gt;N&lt;/tt&gt; shall be within &lt;tt&gt;[ 0..M_MAX_NB_ARGUMENT ]&lt;/tt&gt;.

@icode{C} 
M_KEEP_ARGS(2, a, b, c, d)
==&gt;
a, b
@endicode 

@paragraph autotoc_md657 &lt;tt&gt;M_MID_ARGS(first, len,...)&lt;/tt&gt;

Keep the medium arguments of the argument list,
starting from the 'first'-th one (zero based) and up to &lt;tt&gt;len&lt;/tt&gt; arguments.
first and len shall be within &lt;tt&gt;[ 0..M_MAX_NB_ARGUMENT ]&lt;/tt&gt;.
&lt;tt&gt;first + len&lt;/tt&gt; shall be within the argument of the argument list.

@icode{C} 
M_MID_ARGS(2, 1, a, b, c, d)
==&gt;
c
@endicode 

@paragraph autotoc_md658 &lt;tt&gt;M_REVERSE(args...)&lt;/tt&gt;

Reverse the argument list. 

@icode{C} 
M_REVERSE(a, b, c, d)
==&gt;
d, c, b, a
@endicode 

@paragraph autotoc_md659 &lt;tt&gt;M_MAP(func, args...)&lt;/tt&gt;

Apply &lt;tt&gt;func&lt;/tt&gt; to each argument of the &lt;tt&gt;args...&lt;/tt&gt; list of argument.

@icode{C} 
M_MAP(f, 1, 2, 3)
==&gt;
f(1) f(2) f(3)
@endicode 

@paragraph autotoc_md660 &lt;tt&gt;M_MAP_C(func, args...)&lt;/tt&gt;

Apply &lt;tt&gt;func&lt;/tt&gt; to each argument of the &lt;tt&gt;args...&lt;/tt&gt; list of argument,
putting a comma between each expanded &lt;tt&gt;func(args)&lt;/tt&gt;

@icode{C} 
M_MAP_C(f, 1, 2, 3)
==&gt;
f(1) , f(2) , f(3)
@endicode 

@paragraph autotoc_md661 &lt;tt&gt;M_MAP2(func, data, args...)&lt;/tt&gt;

Apply &lt;tt&gt;func&lt;/tt&gt; to each couple &lt;tt&gt;(data, argument)&lt;/tt&gt; 
with argument an element of the &lt;tt&gt;args...&lt;/tt&gt; list.

@icode{C} 
M_MAP2(f, d, 1, 2, 3)
==&gt;
f(d, 1) f(d, 2) f(d, 3)
@endicode 

@paragraph autotoc_md662 &lt;tt&gt;M_MAP2_C(func, data, args...)&lt;/tt&gt;

Apply &lt;tt&gt;func&lt;/tt&gt; to each couple &lt;tt&gt;(data, argument)&lt;/tt&gt; 
with argument an element of the &lt;tt&gt;args...&lt;/tt&gt; list,
putting a comma between each expanded &lt;tt&gt;func(argc)&lt;/tt&gt;

@icode{C} 
M_MAP2_C(f, d, 1, 2, 3)
==&gt;
f(d, 1) , f(d, 2) , f(d, 3)
@endicode 

@paragraph autotoc_md663 &lt;tt&gt;M_MAP3(func, data, args...)&lt;/tt&gt;

Apply &lt;tt&gt;func&lt;/tt&gt; to each tuple &lt;tt&gt;(data, number, argument)&lt;/tt&gt; 
with argument an element of the &lt;tt&gt;args...&lt;/tt&gt; list
and number from &lt;tt&gt;1&lt;/tt&gt; to &lt;tt&gt;N&lt;/tt&gt; (the index of the list).

@icode{C} 
M_MAP3(f, d, a, b, c)
==&gt;
f(d, 1, a) f(d, 2, b) f(d, 3, c)
@endicode 

@paragraph autotoc_md664 &lt;tt&gt;M_MAP3_C(func, data, args...)&lt;/tt&gt;

Apply &lt;tt&gt;func&lt;/tt&gt; to each tuple &lt;tt&gt;(data, number, argument)&lt;/tt&gt; 
with argument an element of the &lt;tt&gt;args...&lt;/tt&gt; list,
and number from &lt;tt&gt;1&lt;/tt&gt; to &lt;tt&gt;N&lt;/tt&gt; (the index of the list)
putting a comma between each expanded &lt;tt&gt;func(argc)&lt;/tt&gt;

@icode{C} 
M_MAP3_C(f, d, a, b, c)
==&gt;
f(d, 1, a) , f(d, 2, b) , f(d, 3, c)
@endicode 

@paragraph autotoc_md665 &lt;tt&gt;M_CROSS_MAP(func, arglist1, arglist2)&lt;/tt&gt;

Apply &lt;tt&gt;func&lt;/tt&gt; to each pair composed of one argument of &lt;tt&gt;arglist1&lt;/tt&gt; and one argument of &lt;tt&gt;arglist2&lt;/tt&gt;,

@icode{C} 
M_CROSS_MAP(f, (1, 3), (2, 4) )
==&gt;
f(1, 2) f(1, 4) f(3, 2) f(3, 4)
@endicode 

@paragraph autotoc_md666 &lt;tt&gt;M_CROSS_MAP2(func, data, arglist1, arglist2)&lt;/tt&gt;

Apply &lt;tt&gt;func&lt;/tt&gt; to each triplet composed of data, one argument of &lt;tt&gt;arglist1&lt;/tt&gt; and one argument of &lt;tt&gt;arglist2&lt;/tt&gt;,

@icode{C} 
M_CROSS_MAP2(f, 5, (1, 3), (2, 4) )
==&gt;
f(5, 1, 2) f(5, 1, 4) f(5, 3, 2) f(5, 3, 4)
@endicode 

@paragraph autotoc_md667 &lt;tt&gt;M_REDUCE(funcMap, funcReduce, args...)&lt;/tt&gt;

Map the macro funcMap to all given arguments &lt;tt&gt;args&lt;/tt&gt;
and reduce all these computation with the macro &lt;tt&gt;funcReduce&lt;/tt&gt;.

@icode{C} 
M_REDUCE(f, g, a, b, c)
==&gt;
g( f(a) , g( f(b) , f(c) ) )
@endicode 

@paragraph autotoc_md668 &lt;tt&gt;M_REDUCE2(funcMap, funcReduce, data, args...)&lt;/tt&gt;

Map the macro &lt;tt&gt;funcMap&lt;/tt&gt; to all pair (&lt;tt&gt;data&lt;/tt&gt;, &lt;tt&gt;arg&lt;/tt&gt;) of the given argument list &lt;tt&gt;args&lt;/tt&gt; 
and reduce all these computation with the macro &lt;tt&gt;funcReduce&lt;/tt&gt;.

@icode{C} 
M_REDUCE2(f, g, d, a, b, c)
==&gt;
g( f(d, a) , g( f(d, b) , f(d, c) ) )
@endicode 

@paragraph autotoc_md669 &lt;tt&gt;M_REDUCE3(funcMap, funcReduce, data, args...)&lt;/tt&gt;

Map the macro &lt;tt&gt;funcMap&lt;/tt&gt; to all tuple (&lt;tt&gt;data&lt;/tt&gt;, number &lt;tt&gt;arg&lt;/tt&gt;) of the given argument list &lt;tt&gt;args&lt;/tt&gt; 
with number from &lt;tt&gt;1&lt;/tt&gt; to &lt;tt&gt;N&lt;/tt&gt; ( the size of args)
and reduce all these computation with the macro &lt;tt&gt;funcReduce&lt;/tt&gt;.

@icode{C} 
M_REDUCE3(f, g, d, a, b, c)
==&gt;
g( f(d, 1, a) , g( f(d, 2, b) , f(d, 3, c) ) )
@endicode 

@paragraph autotoc_md670 &lt;tt&gt;M_SEQ(init, end)&lt;/tt&gt;

Generate a sequence of number from &lt;tt&gt;init&lt;/tt&gt; to &lt;tt&gt;end&lt;/tt&gt; (included)

@icode{C} 
M_SEQ(1, 6)
==&gt;
1,2,3,4,5,6
@endicode 

@paragraph autotoc_md671 &lt;tt&gt;M_REPLICATE(N, value)&lt;/tt&gt;

Replicate the value &lt;tt&gt;value&lt;/tt&gt; &lt;tt&gt;N&lt;/tt&gt; times.

@icode{C} 
M_REPLICATE(5, D)
==&gt;
D D D D D
@endicode 

@paragraph autotoc_md672 &lt;tt&gt;M_REPLICATE_C(N, value)&lt;/tt&gt;

Replicate the value &lt;tt&gt;value&lt;/tt&gt; &lt;tt&gt;N&lt;/tt&gt; times, separating then by commas.

@icode{C} 
M_REPLICATE_C(5, D)
==&gt;
D , D , D , D , D
@endicode 

@paragraph autotoc_md673 &lt;tt&gt;M_FILTER(func, data, ...)&lt;/tt&gt;

Filter the arglists by keeping only the element that match the function &lt;tt&gt;func(data, element)&lt;/tt&gt;

@icode{C} 
M_FILTER(M_NOTEQUAL, 8, 1, 3, 4, 8, 9, 8, 10)
==&gt;
1 3 4 9 10
@endicode 

@paragraph autotoc_md674 &lt;tt&gt;M_FILTER_C(func, data, ...)&lt;/tt&gt;

Filter the &lt;tt&gt;arglists&lt;/tt&gt; by keeping only the element that match the function &lt;tt&gt;func(data, element)&lt;/tt&gt;
separated by commas.

@icode{C} 
M_FILTER(M_NOTEQUAL, 8, 1, 3, 4, 8, 9, 8, 10)
==&gt;
1 , 3 , 4 , 9 , 10
@endicode 

@paragraph autotoc_md675 &lt;tt&gt;M_NARGS(args...)&lt;/tt&gt;

Return the number of argument of the given list.
args shall not be an empty argument.

@paragraph autotoc_md676 &lt;tt&gt;M_IF_NARGS_EQ1(argslist)(action_if_one_arg, action_otherwise)&lt;/tt&gt;

Return the pre-processing token &lt;tt&gt;action_if_one_arg&lt;/tt&gt; if &lt;tt&gt;argslist&lt;/tt&gt; has only one argument, &lt;tt&gt;action_otherwise&lt;/tt&gt; otherwise
(meaning it is evaluated at macro processing stage, not at compiler stage).

@paragraph autotoc_md677 &lt;tt&gt;M_IF_NARGS_EQ2(argslist)(action_if_two_arg, action_otherwise)&lt;/tt&gt;

Return the pre-processing token &lt;tt&gt;action_if_two_arg&lt;/tt&gt; if &lt;tt&gt;argslist&lt;/tt&gt; has two arguments, &lt;tt&gt;action_otherwise&lt;/tt&gt; otherwise
(meaning it is evaluated at macro processing stage, not at compiler stage).

@paragraph autotoc_md678 &lt;tt&gt;M_IF_DEBUG(action)&lt;/tt&gt;

Return the pre-processing token &lt;tt&gt;action&lt;/tt&gt; if the build is compiled in debug mode
(i.e. &lt;tt&gt;NDEBUG&lt;/tt&gt; is undefined).

@paragraph autotoc_md679 &lt;tt&gt;M_DEFAULT_ARGS(nbExpectedArg, (defaultArgumentlist), argumentList )&lt;/tt&gt;

Helper macro to redefine a function with one or more default values.
&lt;tt&gt;defaultArgumentlist&lt;/tt&gt; is a list of the default value to complete the
list argumentList to reach the number &lt;tt&gt;nbExpectedArg&lt;/tt&gt; arguments.

Example:

@icode{C} 
int f(int a, int b, long p, void *q);
#define f(...) f(M_DEFAULT_ARGS(4, (0, 1, NULL), __VA_ARGS__))
@endicode 

The last 3 arguments have their default value as &lt;tt&gt;0&lt;/tt&gt; (for &lt;tt&gt;b&lt;/tt&gt;),
&lt;tt&gt;1&lt;/tt&gt; (for &lt;tt&gt;p&lt;/tt&gt;) and &lt;tt&gt;NULL&lt;/tt&gt; (for &lt;tt&gt;q&lt;/tt&gt;).

Experimental macro. It may disappear or change in a broken way.

@paragraph autotoc_md680 &lt;tt&gt;M_DEFERRED_COMMA&lt;/tt&gt;

Return a comma &lt;tt&gt;,&lt;/tt&gt; at a later phase of the macro processing steps
(delay evaluation).

@paragraph autotoc_md681 &lt;tt&gt;M_AS_STR(expression)&lt;/tt&gt;

Return the string representation of the evaluated expression.

@subsubsection autotoc_md682 C11 Macro

These macros are only valid if the program is built in C11 mode:

@paragraph autotoc_md683 &lt;tt&gt;M_PRINTF_FORMAT(x)&lt;/tt&gt;

Return the &lt;tt&gt;printf&lt;/tt&gt; format associated to the type of &lt;tt&gt;x&lt;/tt&gt;.
&lt;tt&gt;x&lt;/tt&gt; shall be a basic C variable, printable with &lt;tt&gt;printf&lt;/tt&gt;.

@paragraph autotoc_md684 &lt;tt&gt;M_FPRINT_ARG(file, x)&lt;/tt&gt;

Print into a file &lt;tt&gt;file&lt;/tt&gt; using &lt;tt&gt;fprintf&lt;/tt&gt; the variable &lt;tt&gt;x&lt;/tt&gt;.

The format of &lt;tt&gt;x&lt;/tt&gt; is deduced provided that it is a standard numerical C type.
If @ref "m-string" "<a class="el" href="m-string_8h_source.html">m-string.h</a>" is included, it supports also the type &lt;tt&gt;string_t&lt;/tt&gt; natively.
If the argument is extended (i.e. in the format &lt;tt&gt;(var, optype)&lt;/tt&gt; with optype being either an oplist or a type
with a globally registered oplist), then it will call the &lt;tt&gt;OUT_STR&lt;/tt&gt; method of the oplist on the variable &lt;tt&gt;var&lt;/tt&gt;.

@paragraph autotoc_md685 &lt;tt&gt;M_GET_STRING_ARG(string,x,append)&lt;/tt&gt;

Print into the &lt;tt&gt;string_t&lt;/tt&gt; string the variable &lt;tt&gt;x&lt;/tt&gt;. 
The format of &lt;tt&gt;x&lt;/tt&gt; is deduced provided that it is a standard numerical C type.
It needs the header @ref "m-string" "<a class="el" href="m-string_8h_source.html">m-string.h</a>" for working (this macro is only a 
wrapper around it).
It supports also the type &lt;tt&gt;string_t&lt;/tt&gt;.

@paragraph autotoc_md686 &lt;tt&gt;M_PRINT(args...)&lt;/tt&gt;

Print using &lt;tt&gt;printf&lt;/tt&gt; all the variable in &lt;tt&gt;args&lt;/tt&gt;. 
See &lt;tt&gt;M_PRINT_ARG&lt;/tt&gt; for details on the supported variable.

@paragraph autotoc_md687 &lt;tt&gt;M_FPRINT(file, args...)&lt;/tt&gt;

Print into a file &lt;tt&gt;file&lt;/tt&gt; using &lt;tt&gt;fprintf&lt;/tt&gt; all the variables in &lt;tt&gt;args&lt;/tt&gt;. 
See &lt;tt&gt;M_PRINT_ARG&lt;/tt&gt; for details on the supported variable.

@paragraph autotoc_md688 &lt;tt&gt;M_AS_TYPE(type, x)&lt;/tt&gt;

Within a C11 &lt;tt&gt;_Generic&lt;/tt&gt; statement, all expressions must be valid C
expression even if the case is always false, and is not executed.
This can seriously limit the &lt;tt&gt;_Generic&lt;/tt&gt; statement.

This macro overcomes this limitation by returning:

* either the input &lt;tt&gt;x&lt;/tt&gt; if it is of type &lt;tt&gt;type&lt;/tt&gt;
* or the value &lt;tt&gt;0&lt;/tt&gt; view as a type &lt;tt&gt;type&lt;/tt&gt;

So the returned value is &lt;strong&gt;always&lt;/strong&gt; of type &lt;tt&gt;type&lt;/tt&gt; and is safe in a &lt;tt&gt;_Generic&lt;/tt&gt; statement.

@subsubsection autotoc_md689 C Macro

These macros expand their code at compilation level:

@paragraph autotoc_md690 &lt;tt&gt;M_MIN(x, y)&lt;/tt&gt;

Return the minimum of &lt;tt&gt;x&lt;/tt&gt; and &lt;tt&gt;y&lt;/tt&gt;. &lt;tt&gt;x&lt;/tt&gt; and &lt;tt&gt;y&lt;/tt&gt; shall not have any side effect.

@paragraph autotoc_md691 &lt;tt&gt;M_MAX(x, y)&lt;/tt&gt;

Return the maximum of &lt;tt&gt;x&lt;/tt&gt; and &lt;tt&gt;y&lt;/tt&gt;. &lt;tt&gt;x&lt;/tt&gt; and &lt;tt&gt;y&lt;/tt&gt; shall not have any side effect.

@paragraph autotoc_md692 &lt;tt&gt;M_POWEROF2_P(n)&lt;/tt&gt;

Return true if &lt;tt&gt;n&lt;/tt&gt; is a power of &lt;tt&gt;2&lt;/tt&gt;. n shall not have any side effect.

@paragraph autotoc_md693 &lt;tt&gt;M_SWAP(type, a, b)&lt;/tt&gt;

Swap the values of &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;. &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt; are of type &lt;tt&gt;type&lt;/tt&gt;. &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt; shall not have any side effect.

@paragraph autotoc_md694 &lt;tt&gt;M_ASSIGN_CAST(type, a)&lt;/tt&gt;

Check if &lt;tt&gt;a&lt;/tt&gt; can be assigned to a temporary of type &lt;tt&gt;type&lt;/tt&gt; and returns this temporary.
If it cannot, the compilation failed.

@paragraph autotoc_md695 &lt;tt&gt;M_CONST_CAST(type, a)&lt;/tt&gt;

Check if &lt;tt&gt;a&lt;/tt&gt; can be properly casted to (&lt;tt&gt;const type*&lt;/tt&gt;) and returns this casted pointer if possible.
If it cannot, the compilation failed.

@paragraph autotoc_md696 &lt;tt&gt;M_TYPE_FROM_FIELD(type, ptr, fieldType, field)&lt;/tt&gt;

Assuming &lt;tt&gt;ptr&lt;/tt&gt; is a pointer to a &lt;tt&gt;fieldType&lt;/tt&gt; object that is stored within a structure of type &lt;tt&gt;type&lt;/tt&gt;
at the position &lt;tt&gt;field&lt;/tt&gt;, it returns a pointer to the structure.

&lt;blockquote&gt;&amp;zwj;[!NOTE] 
It is equivalent to the &lt;tt&gt;container_of&lt;/tt&gt; macro of the Linux kernel.
&lt;/blockquote&gt;
@paragraph autotoc_md697 &lt;tt&gt;M_CSTR(format, ...)&lt;/tt&gt;

Return a constant string constructed based on the &lt;tt&gt;printf&lt;/tt&gt;-liked formatted string
and its arguments.

The string is constructed at run time and uses a temporary space on the stack.
If the constructed string is longer than &lt;tt&gt;M_USE_CSTR_ALLOC-1&lt;/tt&gt;,
the string is truncated. Example:

@icode{C} 
strcmp( M_CSTR("Len=d", 17) , "Len=17" ) == 0
@endicode 

&lt;hr&gt;

@subsubsection autotoc_md698 HASH Functions

@paragraph autotoc_md699 &lt;tt&gt;M_USE_HASH_SEED&lt;/tt&gt;

A User modifiable macro defining the initial random seed (of type &lt;tt&gt;size_t&lt;/tt&gt;).
It shall be defined before including any header of M*LIB,
so that hash functions use this variable
as their initial seed for their hash computation of an object. 
It can be used to generate less predictable hash values at run-time, 
which may protect against 
&lt;a href="<a href="https://events.ccc.de/congress/2011/Fahrplan/attachments/2007_28C3_Effective_DoS_on_web_application_platforms.pdf">https://events.ccc.de/congress/2011/Fahrplan/attachments/2007_28C3_Effective_DoS_on_web_application_platforms.pdf</a>" &gt;DoS dictionary attacks&lt;/a&gt;.
It shall be unique for a running instance of M*LIB.

Note that using a random seed is not enough to protect efficiently against
such attacks. A cryptography secure hash may be also needed.
If it is not defined, the default is to use the value 0,
making all hash computations predictable.

@paragraph autotoc_md700 &lt;tt&gt;M_HASH_DECL(hash)&lt;/tt&gt;

Declare and initialize a new hash computation, named &lt;tt&gt;hash&lt;/tt&gt; that
is an integer.

@paragraph autotoc_md701 &lt;tt&gt;M_HASH_UP(hash, value)&lt;/tt&gt;

Update the &lt;tt&gt;hash&lt;/tt&gt; variable with the given &lt;tt&gt;value&lt;/tt&gt;
by incorporating the &lt;tt&gt;value&lt;/tt&gt; within the &lt;tt&gt;hash&lt;/tt&gt;. 
&lt;tt&gt;value&lt;/tt&gt; can be up to a &lt;tt&gt;size_t&lt;/tt&gt; variable.

@paragraph autotoc_md702 &lt;tt&gt;uint32_t m_core_rotl32a (uint32_t x, uint32_t n)&lt;/tt&gt;
@paragraph autotoc_md703 &lt;tt&gt;uint64_t m_core_rotl64a (uint64_t x, uint32_t n)&lt;/tt&gt;

Perform a rotation of &lt;tt&gt;n&lt;/tt&gt; bits of the input &lt;tt&gt;x&lt;/tt&gt;.
&lt;tt&gt;n&lt;/tt&gt; shall be within &lt;tt&gt;1&lt;/tt&gt; and the number of bits of the type &lt;tt&gt;minus 1&lt;/tt&gt;.

@paragraph autotoc_md704 &lt;tt&gt;uint64_t m_core_roundpow2(uint64_t v)&lt;/tt&gt;

Round to the next highest power of &lt;tt&gt;2&lt;/tt&gt;.

@paragraph autotoc_md705 &lt;tt&gt;unsigned int m_core_clz32(uint32_t limb)&lt;/tt&gt;
@paragraph autotoc_md706 &lt;tt&gt;unsigned int m_core_clz64(uint64_t limb)&lt;/tt&gt;

Count the number of leading zero and return it.
&lt;tt&gt;limb&lt;/tt&gt; can be 0.

@paragraph autotoc_md707 &lt;tt&gt;size_t m_core_hash (const void *str, size_t length)&lt;/tt&gt;

Compute the hash of the binary representation of the data pointer by &lt;tt&gt;str&lt;/tt&gt;
of length &lt;tt&gt;length&lt;/tt&gt;. &lt;tt&gt;str&lt;/tt&gt; shall have the maximum alignment restriction
of all types that size is less or equal than &lt;tt&gt;length&lt;/tt&gt;.

@subsubsection autotoc_md708 OPERATORS Functions

@icode{C} 
M_GET_INIT oplist
M_GET_INIT_SET oplist
M_GET_INIT_MOVE oplist
M_GET_SET oplist
M_GET_MOVE oplist
M_GET_SWAP oplist
M_GET_CLEAR oplist
M_GET_NEW oplist
M_GET_DEL oplist
M_GET_REALLOC oplist
M_GET_FREE oplist
M_GET_MEMPOOL oplist
M_GET_MEMPOOL_LINKAGE oplist
M_GET_HASH oplist
M_GET_EQUAL oplist
M_GET_CMP oplist
M_GET_TYPE oplist
M_GET_SUBTYPE oplist
M_GET_OPLIST oplist
M_GET_SORT oplist
M_GET_IT_TYPE oplist
M_GET_IT_FIRST oplist
M_GET_IT_LAST oplist
M_GET_IT_END oplist
M_GET_IT_SET oplist
M_GET_IT_END_P oplist
M_GET_IT_LAST_P oplist
M_GET_IT_EQUAL_P oplist
M_GET_IT_NEXT oplist
M_GET_IT_PREVIOUS oplist
M_GET_IT_REF oplist
M_GET_IT_CREF oplist
M_GET_IT_REMOVE oplist
M_GET_IT_INSERT oplist
M_GET_ADD oplist
M_GET_SUB oplist
M_GET_MUL oplist
M_GET_DIV oplist
M_GET_RESET oplist
M_GET_PUSH oplist
M_GET_POP oplist
M_GET_REVERSE oplist
M_GET_GET_STR oplist
M_GET_OUT_STR oplist
M_GET_IN_STR oplist
M_GET_SEPARATOR oplist
M_GET_EXT_ALGO oplist
M_GET_INC_ALLOC oplist
M_GET_OOR_SET oplist
M_GET_OOR_EQUAL oplist
@endicode 

Return the associated method to the given operator within the given oplist.

@paragraph autotoc_md709 &lt;tt&gt;M_BOOL_OPLIST&lt;/tt&gt;

Oplist for C Boolean (_&lt;tt&gt;Bool&lt;/tt&gt; / &lt;tt&gt;bool&lt;/tt&gt;)

@paragraph autotoc_md710 &lt;tt&gt;M_BASIC_OPLIST&lt;/tt&gt;

Oplist for C basic types (&lt;tt&gt;int&lt;/tt&gt; / &lt;tt&gt;float&lt;/tt&gt;)

@paragraph autotoc_md711 &lt;tt&gt;M_ENUM_OPLIST(type, init_value)&lt;/tt&gt;

Oplist for a C standard enumerate of type &lt;tt&gt;type&lt;/tt&gt;,
of initial value &lt;tt&gt;init_value&lt;/tt&gt;.

@paragraph autotoc_md712 &lt;tt&gt;M_CSTR_OPLIST&lt;/tt&gt;

Oplist for the C type &lt;tt&gt;const char*&lt;/tt&gt;, seen as a constant string.
(The string of characters is not copied).

@paragraph autotoc_md713 &lt;tt&gt;M_POD_OPLIST&lt;/tt&gt;

Oplist for a structure C type without any init and clear methods
prerequisites (plain old data).

@paragraph autotoc_md714 &lt;tt&gt;M_A1_OPLIST&lt;/tt&gt;

Oplist for an array of size &lt;tt&gt;1&lt;/tt&gt; of a structure C type without any init and clear
methods prerequisites.

@paragraph autotoc_md715 &lt;tt&gt;M_EMPTY_OPLIST&lt;/tt&gt;

Oplist for a type that shall not be instantiated.
Each method does nothing.

@paragraph autotoc_md716 &lt;tt&gt;M_CLASSIC_OPLIST(name)&lt;/tt&gt;

Create the oplist with the operators using the pattern &lt;tt&gt;name&lt;/tt&gt;, i.e.
&lt;tt&gt;name\#\#_init&lt;/tt&gt;, &lt;tt&gt;name\#\#_init_set&lt;/tt&gt;, &lt;tt&gt;name\#\#_set&lt;/tt&gt;, &lt;tt&gt;name\#\#_clear&lt;/tt&gt;, &lt;tt&gt;name_t&lt;/tt&gt;

@paragraph autotoc_md717 &lt;tt&gt;M_OPFLAT oplist&lt;/tt&gt;

Remove the parenthesis around an oplist.

@paragraph autotoc_md718 &lt;tt&gt;M_OPCAT(oplist1,oplist2)&lt;/tt&gt;

Concat two oplists in one. &lt;tt&gt;oplist1&lt;/tt&gt;'s operators will have higher priority to &lt;tt&gt;oplist2&lt;/tt&gt;

@paragraph autotoc_md719 &lt;tt&gt;M_OPEXTEND(oplist, ...)&lt;/tt&gt;

Extend an &lt;tt&gt;oplist&lt;/tt&gt; with the given list of operators.
Theses new operators will have higher priority than the ones
in the given oplist.

@paragraph autotoc_md720 &lt;tt&gt;M_TEST_METHOD_P(method, oplist)&lt;/tt&gt;
@paragraph autotoc_md721 &lt;tt&gt;M_TEST_METHOD_ALTER_P(method, oplist)&lt;/tt&gt;

Test if a method is present in an &lt;tt&gt;oplist&lt;/tt&gt;. Return 0 or 1.
&lt;tt&gt;M_TEST_METHOD_P&lt;/tt&gt; does not work if the returned method is something within parenthesis (like &lt;tt&gt;OPLIST*&lt;/tt&gt;)
If this case is possible, you shall use the &lt;tt&gt;M_TEST_METHOD_ALTER_P&lt;/tt&gt; macro (safer but slower).

@paragraph autotoc_md722 &lt;tt&gt;M_IF_METHOD(method, oplist)&lt;/tt&gt;

Perform a preprocessing &lt;tt&gt;M_IF&lt;/tt&gt;, if the method is present in the &lt;tt&gt;oplist&lt;/tt&gt;.
Example:

@icode{C} 
M_IF_METHOD(HASH, oplist)(/*define function that uses HASH method*/, )
@endicode 

@paragraph autotoc_md723 &lt;tt&gt;M_IF_METHOD_BOTH(method, oplist1, oplist2)&lt;/tt&gt;

Perform a preprocessing &lt;tt&gt;M_IF&lt;/tt&gt; if the method exists in both &lt;tt&gt;oplist&lt;/tt&gt;.
Example: 

@icode{C} 
M_IF_METHOD_BOTH(HASH, oplist1, oplist2) (/*define function*/, )
@endicode 

@paragraph autotoc_md724 &lt;tt&gt;M_IF_METHOD_ALL(method, ...)&lt;/tt&gt;

Perform a preprocessing M_IF if the method exists for all oplist.
Example: 

@icode{C} 
M_IF_METHOD_ALL(HASH, oplist1, oplist2, oplist3) (/*define function*/, )
@endicode 

@paragraph autotoc_md725 &lt;tt&gt;M_GET_PROPERTY(oplist, propname)&lt;/tt&gt;

Return the content of the property named &lt;tt&gt;propname&lt;/tt&gt; as defined in the &lt;tt&gt;PROPERTIES&lt;/tt&gt; field of the &lt;tt&gt;oplist&lt;/tt&gt;,
or 0 if it is not defined.

@paragraph autotoc_md726 &lt;tt&gt;M_DO_INIT_MOVE(oplist, dest, src)&lt;/tt&gt;
@paragraph autotoc_md727 &lt;tt&gt;M_DO_MOVE(oplist, dest, src)&lt;/tt&gt;

Perform an &lt;tt&gt;INIT_MOVE&lt;/tt&gt;/&lt;tt&gt;MOVE&lt;/tt&gt; if present, or emulate it otherwise (Internal macros).

&lt;blockquote&gt;&amp;zwj;[!NOTE]
Default methods for &lt;tt&gt;INIT_MOVE&lt;/tt&gt;/&lt;tt&gt;MOVE&lt;/tt&gt; are not robust enough yet.
&lt;/blockquote&gt;
@paragraph autotoc_md728 &lt;tt&gt;M_INIT_WITH_THROUGH_EMPLACE_TYPE(oplist, dest, src)&lt;/tt&gt;

Use the provided &lt;tt&gt;EMPLACE_TYPE&lt;/tt&gt; of the &lt;tt&gt;oplist&lt;/tt&gt; to emulate an &lt;tt&gt;INIT_WITH&lt;/tt&gt; operator.
It transforms the different emplace types by a C11 &lt;tt&gt;_Generic&lt;/tt&gt; switch in order to call the
right initialization function in function of the type of argument.

The &lt;tt&gt;EMPLACE_TYPE&lt;/tt&gt; shall use a &lt;tt&gt;LIST&lt;/tt&gt; based format for listing the different emplace types.
This method is compatible with C11 or above.
This method shall be used with &lt;tt&gt;API_1&lt;/tt&gt; adapter.

@paragraph autotoc_md729 &lt;tt&gt;M_SET_THROUGH_INIT_SET(oplist, dest, src)&lt;/tt&gt;

Emulate the &lt;tt&gt;SET&lt;/tt&gt; semantics using a combination of &lt;tt&gt;CLEAR&lt;/tt&gt; and &lt;tt&gt;INIT_SET&lt;/tt&gt; of the given oplist.
This method shall be used with &lt;tt&gt;API_1&lt;/tt&gt; adapter.

@paragraph autotoc_md730 &lt;tt&gt;M_GLOBAL_OPLIST(a)&lt;/tt&gt;

If &lt;tt&gt;a&lt;/tt&gt; is a type that has registered a global oplist, it returns the registered oplist. 
Otherwise, it return &lt;tt&gt;a&lt;/tt&gt;. &lt;tt&gt;a&lt;/tt&gt; shall be a type or an oplist.

&lt;blockquote&gt;&amp;zwj;[!NOTE] 
It tests the existence of the symbol &lt;tt&gt;M_OPL_\#\#a()&lt;/tt&gt;.
See &lt;tt&gt;M_OPL_&lt;/tt&gt; to register an oplist to a type.
Global registered oplists are limited to &lt;tt&gt;typedef&lt;/tt&gt; types.

&lt;/blockquote&gt;##### &lt;tt&gt;M_GLOBAL_OPLIST_OR_DEF(a)&lt;/tt&gt;

If &lt;tt&gt;a&lt;/tt&gt; is a type that has registered a global oplist, it returns the registered oplist,
otherwise it return the oplist &lt;tt&gt;M_BASIC_OPLIST&lt;/tt&gt;.

The return value shall be evaluated once again to get the oplist
(this is needed due to technical reasons) like this:

@icode{C} 
M_GLOBAL_OPLIST_OR_DEF(mpz_t)()
@endicode 

&lt;tt&gt;a&lt;/tt&gt; shall be a type or an oplist.

&lt;blockquote&gt;&amp;zwj;[!NOTE]
It tests the existence of the symbol &lt;tt&gt;M_OPL_\#\#a()&lt;/tt&gt;.
See &lt;tt&gt;M_OPL&lt;/tt&gt;_ to register an oplist to a type.
Global registered oplists are limited to typedef types.
&lt;/blockquote&gt;
&lt;hr&gt;

@subsubsection autotoc_md731 Syntax enhancing

These macros are quite useful to lighten the C style and make full use of the library.

@paragraph autotoc_md732 &lt;tt&gt;M_EACH(item, container, oplist|type)&lt;/tt&gt;

This macro iterates over the given &lt;tt&gt;container&lt;/tt&gt; of oplist &lt;tt&gt;oplist&lt;/tt&gt;
(or of type &lt;tt&gt;type&lt;/tt&gt; with a globally registered oplist) and sets &lt;tt&gt;item&lt;/tt&gt; 
to reference one different element of the container for each iteration of
the loop.

&lt;tt&gt;item&lt;/tt&gt; is a created pointer variable to the contained type
of the container, only available within the &lt;tt&gt;for&lt;/tt&gt; loop.
There can only have one &lt;tt&gt;M_EACH&lt;/tt&gt; per line.
It shall be used after the &lt;tt&gt;for&lt;/tt&gt; C keyword to perform a loop over the container.
The order of the iteration depends on the given container.

Example: 

@icode{C} 
for M_EACH(item, list, LIST_OPLIST) { action; }
@endicode 

@paragraph autotoc_md733 &lt;tt&gt;M_LET(var1[,var2[,...]], oplist|type)&lt;/tt&gt;

This macro defines the variable &lt;tt&gt;var1&lt;/tt&gt;(resp. &lt;tt&gt;var2&lt;/tt&gt;, &lt;tt&gt;...&lt;/tt&gt;) of oplist &lt;tt&gt;oplist&lt;/tt&gt;.
If a type (instead of an oplist) is used, the oplist of the type shall have been registered globally.
It initializes &lt;tt&gt;var1&lt;/tt&gt; (resp. &lt;tt&gt;var2&lt;/tt&gt;, &lt;tt&gt;...&lt;/tt&gt;) by calling the initialization method,
and clears &lt;tt&gt;var1&lt;/tt&gt; (resp. &lt;tt&gt;var2&lt;/tt&gt;, &lt;tt&gt;...&lt;/tt&gt;) by calling the clear method
when the bracket associated to the &lt;tt&gt;M_LET&lt;/tt&gt; go out of scope.

Its formulation is based on the expression &lt;tt&gt;let var1 as type in&lt;/tt&gt;

Several forms are supported for the initialization method:

* If &lt;tt&gt;var1&lt;/tt&gt; (resp. &lt;tt&gt;var2&lt;/tt&gt;, &lt;tt&gt;...&lt;/tt&gt;) has the form (&lt;tt&gt;v1&lt;/tt&gt;, &lt;tt&gt;arguments...&lt;/tt&gt;),
then the variable &lt;tt&gt;v1&lt;/tt&gt; will be initialized with the 
contains of the initializing list &lt;tt&gt;arguments...&lt;/tt&gt;.
* If &lt;tt&gt;arguments&lt;/tt&gt; is single and within parenthesis
or if there is more one argument
or if the property &lt;tt&gt;LET_AS_INIT_WITH&lt;/tt&gt; of the type is defined,
it will use the operator &lt;tt&gt;INIT_WITH&lt;/tt&gt; (if it exists) to emplace the variable
with the given arguments. The arguments are therefore expected to be compatible with
the &lt;tt&gt;INIT_WITH&lt;/tt&gt; operator.
* Otherwise, it will use the operator &lt;tt&gt;INIT_SET&lt;/tt&gt; (argument is expected
to be the same type as the initialized type in such case).
* Otherwise, it will use the empty initializer &lt;tt&gt;INIT&lt;/tt&gt; operator.

&lt;blockquote&gt;&amp;zwj;[!IMPORTANT]
An argument shall not contain any comma or it shall be put
between parenthesis. In particular, if the argument is a compound
literal the full compound literal shall be put between parenthesis
and casted to the right type outside the parenthesis (due to the conflict
with the &lt;tt&gt;INIT_WITH&lt;/tt&gt; detection it is needed to put something outside the 
parenthesis like a cast).
&lt;/blockquote&gt;
An argument shall not have any post effect when it is evaluated.

There shall be at most one &lt;tt&gt;M_LET&lt;/tt&gt; macro per line of source code.

Example:

@icode{C} 
M_LET(a, STRING_OPLIST) { do something with a }  or
M_LET(a, b, c, string_t) { do something with a, b &amp; c }
M_LET( (a, ("Hello")), string_t) { do something with a initialized to "Hello" }
@endicode 

&lt;blockquote&gt;&amp;zwj;[!NOTE]
The user code shall not perform a return or a goto (or &lt;tt&gt;longjmp&lt;/tt&gt;) 
Outside the &lt;tt&gt;{}&lt;/tt&gt; or a call to an exit function
Otherwise the clear code of the object won't be called.
However, you can use the break instruction to quit the block 
(the clear function will be executed).
&lt;/blockquote&gt;
You can chain the &lt;tt&gt;M_LET&lt;/tt&gt; macro to create several different variables.

@paragraph autotoc_md734 &lt;tt&gt;M_LET_IF(init_code, test_code, clear_code [, else_code] )&lt;/tt&gt;

This macro defines the variable(s) in &lt;tt&gt;init_code&lt;/tt&gt;,
executes the next block of instructions where the variable(s) is(are) used
if the initialization succeeds by testing &lt;tt&gt;test_code&lt;/tt&gt;,
then it executes the &lt;tt&gt;clear_code&lt;/tt&gt;.

&lt;tt&gt;test_code&lt;/tt&gt; shall return a boolean indicating if the initialization 
succeeds (true) or not.
If the initialization fails, it won't call the &lt;tt&gt;clear_code&lt;/tt&gt;, but the &lt;tt&gt;else_code&lt;/tt&gt; if it is present.

The syntax of &lt;tt&gt;init_code&lt;/tt&gt; is the same as a one of a for loop.

There shall be at most one &lt;tt&gt;M_LET_IF&lt;/tt&gt; macro per line of source code.

Example:

@icode{C} 
M_LET_IF(int *p = malloc(100), p!=0, free(p)) {
  M_LET_IF( /* nothing */ , mtx_lock(&amp;mut)!=thrd_error, mtx_unlock(&amp;mut)) {
    printf ("OK! Let's use p in a mutex section<br  />
");
  }
}
@endicode 

&lt;blockquote&gt;&amp;zwj;[!NOTE]
The user code shall not perform a return or a goto (or &lt;tt&gt;longjmp&lt;/tt&gt;)
outside the &lt;tt&gt;{}&lt;/tt&gt; or a call to an exit function
otherwise the clear_code won't be called.
You can use the break instruction to quit the block
(the clear_code will be executed) or you can use exception.
You can chain the &lt;tt&gt;M_LET_IF&lt;/tt&gt; macro to create several different variables.
&lt;/blockquote&gt;
@paragraph autotoc_md735 &lt;tt&gt;M_DEFER(clear_code[, ...])&lt;/tt&gt;

This macro registers the execution of &lt;tt&gt;clear_code&lt;/tt&gt; when reaching 
the further closing brace of the next block of instruction.
clear_code shall be a valid expression.

There shall be at most one &lt;tt&gt;M_DEFER&lt;/tt&gt; macro per line of source code.

Example:

@icode{C} 
m_mutex_lock(mut);
M_DEFER(m_mutex_unlock(mut)) {
    // Use of the critical section.
} // Now m_mutex_unlock is called
@endicode 

&lt;blockquote&gt;&amp;zwj;[!NOTE]
The user code shall not perform a return or a goto (or &lt;tt&gt;longjmp&lt;/tt&gt;) 
outside the &lt;tt&gt;{}&lt;/tt&gt; or a call to an exit function
otherwise the clear_code won't be called.
You can use the break instruction to quit the block
(the clear_code will be executed) or you can use exception.
&lt;/blockquote&gt;
@paragraph autotoc_md736 &lt;tt&gt;M_CHAIN_INIT(name, init_code, clear_code)&lt;/tt&gt;

This macro executes &lt;tt&gt;init_code&lt;/tt&gt; then
registers the execution of &lt;tt&gt;clear_code&lt;/tt&gt; if an exception is triggered
until the further closing brace of the next block of instruction.
init_code and &lt;tt&gt;clear_code&lt;/tt&gt; shall be a valid expression.
If exception are not enabled, it simply executes &lt;tt&gt;init_code&lt;/tt&gt;.

&lt;tt&gt;name&lt;/tt&gt; shall a unique identifier in the current block.
It can be chained multiple times to register multiple registrations.

Therefore, it enables support for chaining
initialization at the beginning of a constructor for the fields of the constructed
object so that even if the constructor failed and throw an exception, 
the fields of the constructed object are properly cleared.

This is equivalent to C++ construct: 

@icode{C} 
void type() : field1(), field2() { rest of constructor }
@endicode 

&lt;tt&gt;M_CHAIN_INIT&lt;/tt&gt; / &lt;tt&gt;M_CHAIN_OBJ&lt;/tt&gt; shall be the first instructions of the constructor function.

Example:

@icode{C} 
void struct_init_set(struct_t d, struct_t s)
{
  M_CHAIN_INIT(s1, string_init_set(d-&gt;s1, s-&gt;s1), string_clear(d-&gt;s1) )
  M_CHAIN_INIT(s2, string_init_set(d-&gt;s2, s-&gt;s2), string_clear(d-&gt;s2) ) {
    d-&gt;num = s-&gt;num;
  }
}
@endicode 

@paragraph autotoc_md737 &lt;tt&gt;M_CHAIN_OBJ(name, oplist, var [, value])&lt;/tt&gt;

This macro executes the initialization method if &lt;tt&gt;var&lt;/tt&gt; to initialize it then
registers the execution of its &lt;tt&gt;CLEAR&lt;/tt&gt; method if an exception is triggered
(and if the property &lt;tt&gt;NOCLEAR&lt;/tt&gt; of the oplist is not defined)
until the further closing brace of the next block of instruction.
If exception are not enabled, it simply executes the initialization method.

The initialization method being used is:

* &lt;tt&gt;INIT&lt;/tt&gt; method if there is no value
* &lt;tt&gt;INIT_SET&lt;/tt&gt; method if there is a value which is not between parenthesis
* &lt;tt&gt;INIT_WITH&lt;/tt&gt; method if there is a value which is between parenthesis.

&lt;tt&gt;name&lt;/tt&gt; shall a unique identifier in the current block.
It can be chained multiple times to register multiple registrations.

Therefore, it enables support for chaining
initialization at the beginning of a constructor for the fields of the constructed
object so that even if the constructor failed and throw an exception,
the fields of the constructed object are properly cleared.

This is equivalent to C++ construct:

@icode{C} 
void type() : field1(), field2() { rest of constructor }
@endicode 

&lt;tt&gt;M_CHAIN_INIT&lt;/tt&gt; / &lt;tt&gt;M_CHAIN_OBJ&lt;/tt&gt; shall be the first instructions of the constructor function.

Example:

@icode{C} 
void struct_init_set(struct_t d, struct_t s)
{
  M_CHAIN_OBJ(s1, STRING_OPLIST, d-&gt;s1, s-&gt;s1)
  M_CHAIN_OBJ(s2, STRING_OPLIST, d-&gt;s2, s-&gt;s2)
  M_CHAIN_OBJ(nu, M_BASIC_OPLIST, d-&gt;num, s-&gt;num) {  }
}
@endicode 

@subsubsection autotoc_md738 Memory / Error macros

All these macro can be overridden before including the header @ref "m-core" "<a class="el" href="m-core_8h_source.html">m-core.h</a>" so that they can be adapted to a particular memory pool.

@paragraph autotoc_md739 &lt;tt&gt;type *M_MEMORY_ALLOC (type)&lt;/tt&gt;

Return a pointer to a new allocated non-initialized object of type &lt;tt&gt;type&lt;/tt&gt;.
In case of allocation error, it returns NULL.

The default used function is the &lt;tt&gt;malloc&lt;/tt&gt; function of the LIBC.

@paragraph autotoc_md740 &lt;tt&gt;void M_MEMORY_DEL (type *ptr)&lt;/tt&gt;

Delete the cleared object pointed by the pointer &lt;tt&gt;ptr&lt;/tt&gt;
that was previously allocated by the macro &lt;tt&gt;M_MEMORY_ALLOC&lt;/tt&gt;.
&lt;tt&gt;ptr&lt;/tt&gt; can not be NULL.

The default used function is the &lt;tt&gt;free&lt;/tt&gt; function of the LIBC.

@paragraph autotoc_md741 &lt;tt&gt;type *M_MEMORY_REALLOC (type, ptr, number)&lt;/tt&gt;

Return a pointer to an array of &lt;tt&gt;number&lt;/tt&gt; objects of type &lt;tt&gt;type&lt;/tt&gt;
&lt;tt&gt;ptr&lt;/tt&gt; is either NULL (in which the array is allocated), 
or a pointer returned from a previous call of &lt;tt&gt;M_MEMORY_REALLOC&lt;/tt&gt; 
(in which case the array is reallocated).
The objects are not initialized, nor the state of previous objects changed
(in case of reallocation).
The address of the previous objects may have moved and the &lt;tt&gt;MOVE&lt;/tt&gt; operator
is not used in this case.
In case of allocation error, it returns NULL.

The default used function is the &lt;tt&gt;realloc&lt;/tt&gt; function of the LIBC.

@paragraph autotoc_md742 &lt;tt&gt;void M_MEMORY_FREE (type *ptr)&lt;/tt&gt;

Delete the cleared object pointed by the pointer &lt;tt&gt;ptr&lt;/tt&gt;.
The pointer was previously allocated by the macro &lt;tt&gt;M_MEMORY_REALLOC&lt;/tt&gt;.
&lt;tt&gt;ptr&lt;/tt&gt; can not be NULL.

The default used function is the &lt;tt&gt;free&lt;/tt&gt; function of the LIBC.

@paragraph autotoc_md743 &lt;tt&gt;void M_MEMORY_FULL (size_t size)&lt;/tt&gt;

This macro is called by M*LIB when a memory error has been detected.
The parameter &lt;tt&gt;size&lt;/tt&gt; is what was tried to be allocated (as a hint).
The macro can:

* Abort the execution
* Throw an exception. In this case, the state of the object is unchanged
* Set a global error variable and return

&lt;blockquote&gt;&amp;zwj;[!NOTE] 
The last case is not properly fully supported yet.
&lt;/blockquote&gt;
The default is to raise a fatal error.

@paragraph autotoc_md744 &lt;tt&gt;void M_ASSERT_INIT(expression, object_name)&lt;/tt&gt;

This macro is called when an assertion used in an initialization context
is called to check the good creation of an object (like a thread, a mutex)
that string name is &lt;tt&gt;object_name&lt;/tt&gt;. 
If the given &lt;tt&gt;expression&lt;/tt&gt; is false, the execution shall be aborted.
The assertion is kept in programs built in release mode.

The default is to raise a fatal error.

@paragraph autotoc_md745 &lt;tt&gt;M_RAISE_FATAL(message...)&lt;/tt&gt;

This macro is called by the user code to raise a fatal error and terminate
the program execution. This macro shall not return.

By default, it prints the error message on &lt;tt&gt;stderr&lt;/tt&gt; and calls abort to terminate
program execution.

@paragraph autotoc_md746 &lt;tt&gt;M_ASSERT(expression)&lt;/tt&gt;

This macro defines the generic assert macro used by M*LIB.
See the assert C macro for details.

The default is the assert macro.

@paragraph autotoc_md747 &lt;tt&gt;M_ASSERT_SLOW(expression)&lt;/tt&gt;

This macro defines the specialized assert macro used by M*LIB
which is used on slow assertion properties
(that have a significant impact on program time).
See the assert C macro for details.

The default is the assert macro if M*LIB test suite, nothing otherwise.

@paragraph autotoc_md748 &lt;tt&gt;M_ASSERT_INIT(expression)&lt;/tt&gt;

This macro defines the specialized assert macro used by M*LIB
which shall be kept on release program.
See the assert C macro for details.

The default is to raise a fatal error if the expression is false.

@paragraph autotoc_md749 &lt;tt&gt;M_ASSERT_INDEX(index, maximum)&lt;/tt&gt;

This macro defines the specialized assert macro used by M*LIB
which is used for buffer overflow checking:
it checks if index is in the range &lt;tt&gt;0&lt;/tt&gt; to &lt;tt&gt;maximum - 1&lt;/tt&gt;.

The default is to call &lt;tt&gt;M_ASSERT&lt;/tt&gt; with this property.

&lt;hr&gt;

@subsubsection autotoc_md750 Generic Serialization objects

A &lt;a href="<a href="https://en.wikipedia.org/wiki/Serialization">https://en.wikipedia.org/wiki/Serialization</a>" &gt;serialization&lt;/a&gt; is the process of translating
data structures into a format that can be stored or transmitted.
When the resulting format is reread and translated, 
it creates a semantically identical clone of the original object. 

A generic serialization object is an object that takes a C object (Boolean, integer, float, 
structure, union, pointer, array, list, hash-map, ...) and outputs it into a serialization way through
the following defined interface that defined the format of the serialization and where it is 
physically output. 

The M*LIB containers define the methods &lt;tt&gt;_out_serial&lt;/tt&gt; and &lt;tt&gt;_in_serial&lt;/tt&gt;
if the underlying types define these methods over the operators &lt;tt&gt;OUT_SERIAL&lt;/tt&gt; and &lt;tt&gt;IN_SERIAL&lt;/tt&gt;.
The methods for the basic C types (&lt;tt&gt;int&lt;/tt&gt;, &lt;tt&gt;float&lt;/tt&gt;, &lt;tt&gt;...&lt;/tt&gt;) are also defined (but only
in C11 due to technical limitation).

The methods &lt;tt&gt;_out_serial&lt;/tt&gt; and &lt;tt&gt;_in_serial&lt;/tt&gt; will request the generic serialization object
to serialize their current object:

* calling the interface of the generic serialization object if needed, 
* performing recursive call to serialize the contained-objects.

The final output of this serialization can be a &lt;tt&gt;FILE*&lt;/tt&gt; or a string.
Two kinds of serialization objects exist: one for input and one
for output. The serialization is fully recursive and can be seen as a collection of token.
The only constraint is that what is output by the output serialization object
shall be able to be parsed by the input serialization object.

The serialization input object is named as &lt;tt&gt;m_serial_read_t&lt;/tt&gt;, defined in @ref "m-core" "<a class="el" href="m-core_8h_source.html">m-core.h</a>" as a structure
(of array of size 1) with the following fields:

&lt;table class="markdownTable"&gt;
  &lt;tr class="markdownTableHead"&gt;    &lt;th class="markdownTableHeadCenter"&gt; Field   </code></p>
<p><code> Description    </code></p>
<p><code> </code></p>
<p><code> <code>m_interface</code>   </code></p>
<p><code> a pointer to the constant <code><a class="el" href="structm__serial__read__interface__s.html">m_serial_read_interface_s</a></code> structure that defines all methods that operate on this object to parse it. The instance has to be customized for the needs of the wanted serialization.    </code></p>
<p><code> </code></p>
<p><code> <code>data</code>   </code></p>
<p><code> a table of <code>M_SERIAL_MAX_DATA_SIZE</code> of C types (Boolean, integer, size or pointer). This data is used to store the needed data for the methods.   </code></p>
<p><code></code></p>
<p><code>This data is used to store the needed data for the methods.</code></p>
<p><code>This is pretty much like a pure virtual interface object in C++. The interface has to define the following fields with the following definition:</code></p>
<p><code></p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Method   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>read_boolean</code>   </td><td class="markdownTableBodyLeft">Read from the stream <code>serial</code> a boolean. Set <code>*b</code> with the boolean value if it succeeds. <br  />
Return <code>M_SERIAL_OK_DONE</code> if it succeeds, <code>M_SERIAL_FAIL</code> otherwise    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>read_integer</code>   </td><td class="markdownTableBodyLeft">Read from the stream <code>serial</code> an integer that can be represented with <code>size_of_type</code> bytes. Set <code>*i</code> with the integer value if it succeeds. <br  />
Return <code>M_SERIAL_OK_DONE</code> if it succeeds, <code>M_SERIAL_FAIL</code> otherwise    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>read_float</code>   </td><td class="markdownTableBodyLeft">Read from the stream <code>serial</code> a float that can be represented with <code>size_of_type</code> bytes. Set <code>*r</code> with the float value if it succeeds. <br  />
Return <code>M_SERIAL_OK_DONE</code> if it succeeds, <code>M_SERIAL_FAIL</code> otherwise    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>read_string</code>   </td><td class="markdownTableBodyLeft">Read from the stream <code>serial</code> a string. <br  />
Set <code>s</code> with the string if it succeeds. <br  />
Return <code>M_SERIAL_OK_DONE</code> if it succeeds, <code>M_SERIAL_FAIL</code> otherwise    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>read_array_start</code>   </td><td class="markdownTableBodyLeft">Start reading from the stream <code>serial</code> an array (which is defined as a sequential collection of object). <br  />
Set <code>*num</code> with the number of elements, or <code>(size_t) - 1</code> if it is not known. Initialize the object <code>local</code> so that it can be used by the serialization object to serialize the array. (<code>local</code> is an unique local serialization object of the array). <br  />
Return <code>M_SERIAL_OK_CONTINUE</code> if it succeeds and the parsing of the array can continue (the array is not empty), <code>M_SERIAL_OK_DONE</code> if it succeeds and the array ends (the array is empty), <code>M_SERIAL_FAIL_RETRY</code> if it doesn't support unknown number of elements, <code>M_SERIAL_FAIL</code> otherwise    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>read_array_next</code>   </td><td class="markdownTableBodyLeft">Continue reading from the stream <code>serial</code> an array using <code>local</code> to load / save data if needed. <br  />
Return <code>M_SERIAL_OK_CONTINUE</code> if it succeeds and the array can continue (the array end is still not reached), <code>M_SERIAL_OK_DONE</code> if it succeeds and the array ends, <code>M_SERIAL_FAIL</code> otherwise    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>read_map_start</code>   </td><td class="markdownTableBodyLeft">Start reading from the stream <code>serial</code> a map (an associative array). <br  />
Set <code>*num</code> with the number of elements, or 0 if it is not known. Initialize <code>local</code> so that it can be used to serialize the map. (<code>local</code> is an unique serialization object of the map). <br  />
Return <code>M_SERIAL_OK_CONTINUE</code> if it succeeds and the map continue, <code>M_SERIAL_OK_DONE</code> if it succeeds and the map ends (the map is empty), <code>M_SERIAL_FAIL</code> otherwise    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>read_map_value</code>   </td><td class="markdownTableBodyLeft">Continue reading from the stream <code>serial</code> the value separator token (if needed) using <code>local</code> to load / save data if needed. <br  />
Return <code>M_SERIAL_OK_CONTINUE</code> if it succeeds and the map continue, <code>M_SERIAL_FAIL</code> otherwise    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>read_map_next</code>   </td><td class="markdownTableBodyLeft">Continue reading from the stream <code>serial</code> a map. <br  />
using <code>local</code> to load / save data if needed. <br  />
Return <code>M_SERIAL_OK_CONTINUE</code> if it succeeds and the map continue, <code>M_SERIAL_OK_DONE</code> if it succeeds and the map ends, <code>M_SERIAL_FAIL</code> otherwise    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>read_tuple_start</code>   </td><td class="markdownTableBodyLeft">Start reading a tuple from the stream <code>serial</code>. <br  />
Return <code>M_SERIAL_OK_CONTINUE</code> if it succeeds and the tuple continues, <code>M_SERIAL_FAIL</code> otherwise    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>read_tuple_id</code>   </td><td class="markdownTableBodyLeft">Continue reading a tuple (a structure) from the stream <code>serial</code>. <br  />
using <code>local</code> to load / save data if needed. Set <code>*id</code> with the corresponding index of the table <code>field_name[max]</code> associated to the parsed field in the stream. <br  />
Return <code>M_SERIAL_OK_CONTINUE</code> if it succeeds and the tuple continues, Return <code>M_SERIAL_OK_DONE</code> if it succeeds and the tuple ends, <code>M_SERIAL_FAIL</code> otherwise    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>read_variant_start</code>   </td><td class="markdownTableBodyLeft">Start reading a variant (an union) from the stream <code>serial</code>. Set <code>*id</code> with the corresponding index of the table <code>field_name[max]</code> associated to the parsed field in the stream. <br  />
Return <code>M_SERIAL_OK_CONTINUE</code> if it succeeds and the variant continues, Return <code>M_SERIAL_OK_DONE</code> if it succeeds and the variant ends (variant is empty), <code>M_SERIAL_FAIL</code> otherwise    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>read_variant_end</code>   </td><td class="markdownTableBodyLeft">End reading a variant from the stream <code>serial</code>. <br  />
Return <code>M_SERIAL_OK_DONE</code> if it succeeds and the variant ends, <code>M_SERIAL_FAIL</code> otherwise   </td></tr>
</table>
<p></code></p>
<p><code>The serialization output object is named as <code>m_serial_write_t</code>, defined in m-core.h as a structure (of array of size 1) with the following fields:</code></p>
<p><code></p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>m_interface</code>   </td><td class="markdownTableBodyLeft">A pointer to the constant <code><a class="el" href="structm__serial__write__interface__s.html">m_serial_write_interface_s</a></code> structure that defines all methods that operate on this object to output it. The instance has to be customized for the needs of the wanted serialization.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>data</code>   </td><td class="markdownTableBodyLeft">A table of <code>M_SERIAL_MAX_DATA_SIZE</code> of C types (Boolean, integer, size or pointer). This data is used to store the needed data for the methods.   </td></tr>
</table>
<p></code></p>
<p><code>This data is used to store the needed data for the methods.</code></p>
<p><code>This is pretty much like a pure virtual interface object in C++. The interface has to defines the following fields with the following definition:</code></p>
<p><code></p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Method   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>write_boolean</code>   </td><td class="markdownTableBodyLeft">Write the boolean <code>b</code> into the serial stream <code>serial</code>. <br  />
Return <code>M_SERIAL_OK_DONE</code> if it succeeds, <code>M_SERIAL_FAIL</code> otherwise    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>write_integer</code>   </td><td class="markdownTableBodyLeft">Write the integer <code>data</code> of <code>size_of_type</code> bytes into the serial stream <code>serial</code>. <br  />
Return <code>M_SERIAL_OK_DONE</code> if it succeeds, <code>M_SERIAL_FAIL</code> otherwise    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>write_float</code>   </td><td class="markdownTableBodyLeft">Write the float <code>data</code> of <code>size_of_type</code> bytes into the serial stream <code>serial</code>. <br  />
Return <code>M_SERIAL_OK_DONE</code> if it succeeds, <code>M_SERIAL_FAIL</code> otherwise    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>write_string</code>   </td><td class="markdownTableBodyLeft">Write the null-terminated string <code>data</code> of <code>length</code> characters into the serial stream <code>serial</code>. <br  />
Return <code>M_SERIAL_OK_DONE</code> if it succeeds, <code>M_SERIAL_FAIL</code> otherwise    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>write_array_start</code>   </td><td class="markdownTableBodyLeft">Start writing an array of <code>number_of_elements</code> objects into the serial stream <code>serial</code>. <br  />
If <code>number_of_elements</code> is 0, then either the array has no data, or the <code>number_of_elements</code> of the array is unknown. <br  />
Initialize <code>local</code> so that it can be used to serialize the array (<code>local</code> is an unique serialization object of the array). <br  />
Return <code>M_SERIAL_OK_CONTINUE</code> if it succeeds, <code>M_SERIAL_FAIL</code> otherwise    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>write_array_next</code>   </td><td class="markdownTableBodyLeft">Write an array separator between elements of an array into the serial stream <code>serial</code> if needed. <br  />
Return <code>M_SERIAL_OK_CONTINUE</code> if it succeeds, <code>M_SERIAL_FAIL</code> otherwise    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>write_array_end</code>   </td><td class="markdownTableBodyLeft">End the writing of an array into the serial stream <code>serial</code>. <br  />
Return <code>M_SERIAL_OK_DONE</code> if it succeeds, <code>M_SERIAL_FAIL</code> otherwise    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>write_map_start</code>   </td><td class="markdownTableBodyLeft">Start writing a map of <code>number_of_elements</code> pairs of objects into the serial stream <code>serial</code>. <br  />
If <code>number_of_elements</code> is 0, then either the map has no data, or the number of elements is unknown. <br  />
Initialize <code>local</code> so that it can be used to serialize the map (<code>local</code> is an unique serialization object of the map). <br  />
Return <code>M_SERIAL_OK_CONTINUE</code> if it succeeds, <code>M_SERIAL_FAIL</code> otherwise    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>write_map_value</code>   </td><td class="markdownTableBodyLeft">Write a value separator between element of the same pair of a map into the serial stream <code>serial</code> if needed. <br  />
Return <code>M_SERIAL_OK_CONTINUE</code> if it succeeds, <code>M_SERIAL_FAIL</code> otherwise    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>write_map_next</code>   </td><td class="markdownTableBodyLeft">Write a map separator between elements of a map into the serial stream <code>serial</code> if needed. <br  />
Return <code>M_SERIAL_OK_CONTINUE</code> if it succeeds, <code>M_SERIAL_FAIL</code> otherwise    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>write_map_end</code>   </td><td class="markdownTableBodyLeft">End the writing of a map into the serial stream <code>serial</code>. <br  />
Return <code>M_SERIAL_OK_DONE</code> if it succeeds, <code>M_SERIAL_FAIL</code> otherwise    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>write_tuple_start</code>   </td><td class="markdownTableBodyLeft">Start writing a tuple into the serial stream <code>serial</code>. <br  />
Initialize <code>local</code> so that it can serial the tuple (<code>local</code> is an unique serialization object of the tuple). <br  />
Return <code>M_SERIAL_OK_CONTINUE</code> if it succeeds, <code>M_SERIAL_FAIL</code> otherwise    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>write_tuple_id</code>   </td><td class="markdownTableBodyLeft">Start writing the field named <code>field_name[index]</code> of a tuple into the serial stream <code>serial</code>. <br  />
Return <code>M_SERIAL_OK_CONTINUE</code> if it succeeds, <code>M_SERIAL_FAIL</code> otherwise    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>write_tuple_end</code>   </td><td class="markdownTableBodyLeft">End the write of a tuple into the serial stream <code>serial</code>. <br  />
Return <code>M_SERIAL_OK_DONE</code> if it succeeds, <code>M_SERIAL_FAIL</code> otherwise    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><code>write_variant_start</code>   </td><td class="markdownTableBodyLeft">Start writing a variant into the serial stream <code>serial</code>. <br  />
If <code>index &lt;= 0</code>, the variant is empty. <br  />
Return <code>M_SERIAL_OK_DONE</code> if it succeeds, <code>M_SERIAL_FAIL</code> otherwise <br  />
Otherwise, the field <code>field_name[index]</code> will be filled. <br  />
Return <code>M_SERIAL_OK_CONTINUE</code> if it succeeds, <code>M_SERIAL_FAIL</code> otherwise    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><code>write_variant_end</code>   </td><td class="markdownTableBodyLeft">End Writing a variant into the serial stream <code>serial</code>. <br  />
Return <code>M_SERIAL_OK_DONE</code> if it succeeds, <code>M_SERIAL_FAIL</code> otherwise   </td></tr>
</table>
<p></code></p>
<p><code><code>M_SERIAL_MAX_DATA_SIZE</code> can be overloaded before including any M*LIB header to increase the size of the generic object. The maximum default size is 4 fields.</code></p>
<p><code>The full C definition are:</code></p>
<p><code></p><div class="fragment"><div class="line"><span class="comment">// Serial return code</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> m_serial_return_code_e {</div>
<div class="line"> M_SERIAL_OK_DONE = 0, M_SERIAL_OK_CONTINUE = 1, M_SERIAL_FAIL = 2</div>
<div class="line">} m_serial_return_code_t;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Different types of types that can be stored in a serial object to represent it.</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">union </span><a class="code hl_union" href="unionm__serial__ll__u.html">m_serial_ll_u</a> {</div>
<div class="line">  <span class="keywordtype">bool</span>   b;</div>
<div class="line">  <span class="keywordtype">int</span>    i;</div>
<div class="line">  <span class="keywordtype">size_t</span> s;</div>
<div class="line">  <span class="keywordtype">void</span>  *p;</div>
<div class="line">} m_serial_ll_t;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Object to handle the construction of a serial write/read of an object</span></div>
<div class="line"><span class="comment">   that needs multiple calls (array, map, ...)</span></div>
<div class="line"><span class="comment">   It is common to all calls to the same object */</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="structm__serial__local__s.html">m_serial_local_s</a> {</div>
<div class="line"> m_serial_ll_t data[M_USE_SERIAL_MAX_DATA_SIZE];</div>
<div class="line">} m_serial_local_t[1];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Object to handle the generic serial read of an object.</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="structm__serial__read__s.html">m_serial_read_s</a> {</div>
<div class="line"> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code hl_struct" href="structm__serial__read__interface__s.html">m_serial_read_interface_s</a> *m_interface;</div>
<div class="line"> m_serial_ll_t data[M_USE_SERIAL_MAX_DATA_SIZE];</div>
<div class="line">} m_serial_read_t[1];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Interface exported by the serial read object.</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="structm__serial__read__interface__s.html">m_serial_read_interface_s</a> {</div>
<div class="line">  m_serial_return_code_t (*read_boolean)(m_serial_read_t serial,<span class="keywordtype">bool</span> *b);</div>
<div class="line">  m_serial_return_code_t (*read_integer)(m_serial_read_t serial, <span class="keywordtype">long</span> <span class="keywordtype">long</span> *i, <span class="keyword">const</span> <span class="keywordtype">size_t</span> size_of_type);</div>
<div class="line">  m_serial_return_code_t (*read_float)(m_serial_read_t serial, <span class="keywordtype">long</span> <span class="keywordtype">double</span> *f, <span class="keyword">const</span> <span class="keywordtype">size_t</span> size_of_type);</div>
<div class="line">  m_serial_return_code_t (*read_string)(m_serial_read_t serial, <span class="keyword">struct </span>string_s *s); </div>
<div class="line">  m_serial_return_code_t (*read_array_start)(m_serial_local_t local, m_serial_read_t serial, <span class="keywordtype">size_t</span> *s);</div>
<div class="line">  m_serial_return_code_t (*read_array_next)(m_serial_local_t local, m_serial_read_t serial);</div>
<div class="line">  m_serial_return_code_t (*read_map_start)(m_serial_local_t local, m_serial_read_t serial, <span class="keywordtype">size_t</span> *);</div>
<div class="line">  m_serial_return_code_t (*read_map_value)(m_serial_local_t local, m_serial_read_t serial);</div>
<div class="line">  m_serial_return_code_t (*read_map_next)(m_serial_local_t local, m_serial_read_t serial);</div>
<div class="line">  m_serial_return_code_t (*read_tuple_start)(m_serial_local_t local, m_serial_read_t serial);</div>
<div class="line">  m_serial_return_code_t (*read_tuple_id)(m_serial_local_t local, m_serial_read_t serial, <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> field_name [], <span class="keyword">const</span> <span class="keywordtype">int</span> max, <span class="keywordtype">int</span> *id);</div>
<div class="line">  m_serial_return_code_t (*read_variant_start)(m_serial_local_t local, m_serial_read_t serial, <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> field_name[], <span class="keyword">const</span> <span class="keywordtype">int</span> max, <span class="keywordtype">int</span>*id);</div>
<div class="line">  m_serial_return_code_t (*read_variant_end)(m_serial_local_t local, m_serial_read_t serial);</div>
<div class="line">} <a class="code hl_struct" href="structm__serial__read__interface__s.html">m_serial_read_interface_t</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Object to handle the generic serial write of an object.</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="structm__serial__write__s.html">m_serial_write_s</a> {</div>
<div class="line"> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code hl_struct" href="structm__serial__write__interface__s.html">m_serial_write_interface_s</a> *m_interface;</div>
<div class="line"> m_serial_ll_t data[M_USE_SERIAL_MAX_DATA_SIZE];</div>
<div class="line">} m_serial_write_t[1];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Interface exported by the serial write object.</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="structm__serial__write__interface__s.html">m_serial_write_interface_s</a> {</div>
<div class="line">  m_serial_return_code_t (*write_boolean)(m_serial_write_t serial, <span class="keyword">const</span> <span class="keywordtype">bool</span> b);</div>
<div class="line">  m_serial_return_code_t (*write_integer)(m_serial_write_t serial, <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> i, <span class="keyword">const</span> <span class="keywordtype">size_t</span> size_of_type);</div>
<div class="line">  m_serial_return_code_t (*write_float)(m_serial_write_t serial,  <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">double</span> f, <span class="keyword">const</span> <span class="keywordtype">size_t</span> size_of_type);</div>
<div class="line">  m_serial_return_code_t (*write_string)(m_serial_write_t serial, <span class="keyword">const</span> <span class="keywordtype">char</span> s[], <span class="keywordtype">size_t</span> length); </div>
<div class="line">  m_serial_return_code_t (*write_array_start)(m_serial_local_t local, m_serial_write_t serial, <span class="keyword">const</span> <span class="keywordtype">size_t</span> number_of_elements);</div>
<div class="line">  m_serial_return_code_t (*write_array_next)(m_serial_local_t local, m_serial_write_t serial);</div>
<div class="line">  m_serial_return_code_t (*write_array_end)(m_serial_local_t local, m_serial_write_t serial);</div>
<div class="line">  m_serial_return_code_t (*write_map_start)(m_serial_local_t local, m_serial_write_t serial,  <span class="keyword">const</span> <span class="keywordtype">size_t</span> number_of_elements);</div>
<div class="line">  m_serial_return_code_t (*write_map_value)(m_serial_local_t local, m_serial_write_t serial);</div>
<div class="line">  m_serial_return_code_t (*write_map_next)(m_serial_local_t local, m_serial_write_t serial);</div>
<div class="line">  m_serial_return_code_t (*write_map_end)(m_serial_local_t local, m_serial_write_t serial);</div>
<div class="line">  m_serial_return_code_t (*write_tuple_start)(m_serial_local_t local, m_serial_write_t serial);</div>
<div class="line">  m_serial_return_code_t (*write_tuple_id)(m_serial_local_t local, m_serial_write_t serial, <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> field_name[], <span class="keyword">const</span> <span class="keywordtype">int</span> max, <span class="keyword">const</span> <span class="keywordtype">int</span> index);</div>
<div class="line">  m_serial_return_code_t (*write_tuple_end)(m_serial_local_t local, m_serial_write_t serial);</div>
<div class="line">  m_serial_return_code_t (*write_variant_start)(m_serial_local_t local, m_serial_write_t serial,  <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> field_name[], <span class="keyword">const</span> <span class="keywordtype">int</span> max, <span class="keyword">const</span> <span class="keywordtype">int</span> index);</div>
<div class="line">  m_serial_return_code_t (*write_variant_end)(m_serial_local_t local, m_serial_write_t serial);</div>
<div class="line">} <a class="code hl_struct" href="structm__serial__write__interface__s.html">m_serial_write_interface_t</a>;</div>
<div class="ttc" id="astructm__serial__local__s_html"><div class="ttname"><a href="structm__serial__local__s.html">m_serial_local_s</a></div><div class="ttdef"><b>Definition</b> m-core.h:5215</div></div>
<div class="ttc" id="astructm__serial__read__interface__s_html"><div class="ttname"><a href="structm__serial__read__interface__s.html">m_serial_read_interface_s</a></div><div class="ttdef"><b>Definition</b> m-core.h:5235</div></div>
<div class="ttc" id="astructm__serial__read__s_html"><div class="ttname"><a href="structm__serial__read__s.html">m_serial_read_s</a></div><div class="ttdef"><b>Definition</b> m-core.h:5226</div></div>
<div class="ttc" id="astructm__serial__write__interface__s_html"><div class="ttname"><a href="structm__serial__write__interface__s.html">m_serial_write_interface_s</a></div><div class="ttdef"><b>Definition</b> m-core.h:5268</div></div>
<div class="ttc" id="astructm__serial__write__s_html"><div class="ttname"><a href="structm__serial__write__s.html">m_serial_write_s</a></div><div class="ttdef"><b>Definition</b> m-core.h:5259</div></div>
<div class="ttc" id="aunionm__serial__ll__u_html"><div class="ttname"><a href="unionm__serial__ll__u.html">m_serial_ll_u</a></div><div class="ttdef"><b>Definition</b> m-core.h:5195</div></div>
</div><!-- fragment --><p></code></p>
<p><code>See m-serial-json.h for example of use.</code></p>
<p><code></p><hr  />
<p></code></p>
<p><code></code></p>
<h2><a class="anchor" id="autotoc_md751"></a>
M-THREAD</h2>
<p><code></code></p>
<p><code>This header is for providing very thin layer around OS implementation of threads, conditional variables and mutex. It has back-ends for WIN32, POSIX thread, FreeRTOS tasks or C11 thread.</code></p>
<p><code>It was needed due to the low adoption rate of the C11 equivalent layer.</code></p>
<p><code>It uses the FreeRTOS tasks is it detects FreeRTOS. Otherwise, it uses the C11 threads.h if possible. If the C11 implementation does not respect the C standard (i.e. the compiler targets C11 mode, the <code>__STDC_NO_THREADS__</code> macro is not defined but the header threads.h is not available or not working), then the user shall define manually the <code>M_USE_THREAD_BACKEND</code> macro to select the back end to use:</code></p>
<p><code></p><ol type="1">
<li>For C11</li>
<li>For WINDOWS</li>
<li>For PTHREAD</li>
<li>For FreeRTOS</li>
</ol>
<p></code></p>
<p><code>The FreeRTOS backend uses two additional global configuration constants:</code></p>
<p><code></p><ul>
<li><code>M_USE_TASK_STACK_SIZE</code> to define the stack size of a thread (default is the minimal)</li>
<li><code>M_USE_TASK_PRIORITY</code> to define the priority of a thread (default is lowest).</li>
</ul>
<p></code></p>
<p><code>Example:</code></p>
<p><code></p><div class="fragment"><div class="line">m_thread_t idx_p;</div>
<div class="line">m_thread_t idx_c;</div>
<div class="line"> </div>
<div class="line">m_thread_create (idx_p, conso_function, NULL);</div>
<div class="line">m_thread_create (idx_c, prod_function, NULL);</div>
<div class="line">m_thread_join (idx_p;</div>
<div class="line">m_thread_join (idx_c);</div>
</div><!-- fragment --><p></code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md752"></a>
Attributes</h3>
<p><code></code></p>
<p><code>The following attributes are available:</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md753"></a>
&lt;tt&gt;M_THREAD_ATTR&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>An attribute used for qualifying a variable to be thread specific. It is an alias for <code>__thread</code>, <code>_Thread_local</code> or <code>__declspec( thread )</code> depending on the used backend.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md754"></a>
Methods</h3>
<p><code></code></p>
<p><code>The following methods are available:</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md755"></a>
&lt;tt&gt;m_mutex_t&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>A type representing a mutex.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md756"></a>
&lt;tt&gt;void m_mutex_init(m_mutex_t mutex)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Initialize the variable mutex and sets it to the unlocked position. If the initialization fails, the program aborts. Only one thread shall initialize the mutex.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md757"></a>
&lt;tt&gt;void m_mutex_clear(m_mutex_t mutex)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Clear the variable mutex. Only one thread shall clear the mutex.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md758"></a>
&lt;tt&gt;void m_mutex_lock(m_mutex_t mutex)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Lock the variable mutex for exclusive use. If the mutex is not unlocked, it will wait indefinitely until it is.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md759"></a>
&lt;tt&gt;bool m_mutex_trylock(m_mutex_t mutex)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Try to lock the variable mutex for exclusive use. If the mutex is not unlocked, it will return immediately. Return true in case of success (mutex locked), false otherwise (mutex unlocked).</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md760"></a>
&lt;tt&gt;void m_mutex_unlock(m_mutex_t mutex)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Unlock the variable mutex for exclusive use. The mutex shall be locked.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md761"></a>
&lt;tt&gt;m_cond_t&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>A type representing a conditional variable, which shall be used within a mutex section.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md762"></a>
&lt;tt&gt;void m_cond_init(m_cond_t cond)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Initialize the conditional variable cond. If the initialization failed, the program aborts. Only one thread shall init the conditional variable.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md763"></a>
&lt;tt&gt;void m_cond_clear(m_cond_t cond)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Clear the variable cond. If the variable is not initialized, the behavior is undefined. Only one thread shall clear the conditional variable.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md764"></a>
&lt;tt&gt;void m_cond_signal(m_cond_t cond)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Signal that the event associated to the variable cond has occurred to at least a single thread. All usage of this conditional variable shall be done within the same mutex exclusive section.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md765"></a>
&lt;tt&gt;void m_cond_broadcast(m_cond_t cond)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Signal that the event associated to the variable cond has occurred to all waiting threads. All usage of this conditional variable shall be done within the same mutex exclusive section.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md766"></a>
&lt;tt&gt;void m_cond_wait(m_cond_t cond, m_mutex_t mutex)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Wait indefinitely for the event associated to the variable cond to occur. IF multiple threads wait for the same event, which thread to awoken is not specified. All usage of this conditional variable shall be done within the mutex exclusive section.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md767"></a>
&lt;tt&gt;m_thread_t&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>A type representing an id of a thread.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md768"></a>
&lt;tt&gt;void m_thread_create(m_thread_t thread, void (*function)(void*), void *argument)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Create a new thread and set the it of the thread to <code>thread</code>. The new thread run the code function(argument) with argument a <code>void*</code> and function taking a <code>void*</code> and returning nothing. If the initialization fails, the program aborts.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md769"></a>
&lt;tt&gt;void m_thread_join(m_thread_t thread)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Wait indefinitely for the thread <code>thread</code> to exit.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md770"></a>
&lt;tt&gt;m_once_t&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>A type representing a helper structure for <code>m_once_call</code>. An object of type m_once_t shall be initialized at declaration level with <code>M_ONCE_INIT_VALUE</code></code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md771"></a>
&lt;tt&gt;M_ONCE_INIT_VALUE&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Initial value to set an object of type <code>m_once_t</code> when declaring it.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md772"></a>
&lt;tt&gt;void m_once_call(m_once_t obj, void (*func)(void))&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Executes the function pointer func exactly once, even if called concurrently, from several threads, provided that they share the same object obj.</code></p>
<p><code></p><hr  />
<p></code></p>
<p><code></code></p>
<h2><a class="anchor" id="autotoc_md773"></a>
M-WORKER</h2>
<p><code></code></p>
<p><code>This header is for providing a pool of workers. Each worker run in a separate thread and can handle work orders sent by the main threads. A work order is a computation task. Work orders are organized around synchronization points. Workers can be disabled globally to ease debugging.</code></p>
<p><code>This implements parallelism just like OpenMP or CILK++.</code></p>
<p><code>Example:</code></p>
<p><code></p><div class="fragment"><div class="line">worker_t worker;</div>
<div class="line">worker_init(worker, 0, 0, NULL);</div>
<div class="line">worker_sync_t sync;</div>
<div class="line">worker_start(sync, worker);</div>
<div class="line"><span class="keywordtype">void</span> *data = ...;</div>
<div class="line">worker_spawn (sync, taskFunc, data);</div>
<div class="line">taskFunc(otherData);</div>
<div class="line">worker_sync(sync);</div>
</div><!-- fragment --><p></code></p>
<p><code>Currently, there is no support for:</code></p>
<p><code></p><ul>
<li>Throw exceptions by the worker tasks,</li>
<li>Unbalanced design: the worker tasks shall not lock a mutex without closing it (same for other synchronization structures).</li>
</ul>
<p></code></p>
<p><code>Thread Local Storage variables have to be reinitialized properly with the reset function. This may result in subtle difference between the serial code and the parallel code.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md774"></a>
Methods</h3>
<p><code></code></p>
<p><code>The following methods are available:</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md775"></a>
&lt;tt&gt;worker_t&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>A pool of worker.</code></p>
<p><code>The type is incompatible between C++, C/CLANG and C (all others) due to technical constraints, so a variable of such a type shall always be accessed by the same compiler.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md776"></a>
&lt;tt&gt;worker_sync_t&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>A synchronization point between workers.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md777"></a>
&lt;tt&gt;void worker_init(worker_t worker[, unsigned int numWorker, unsigned int extraQueue, void (*resetFunc)(void), void (*clearFunc)(void) ])&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Initialize the pool of workers <code>worker</code> with <code>numWorker</code> workers. if <code>numWorker</code> is 0, then it will detect how many core is available on the system and creates as much workers as there are cores.</code></p>
<p><code>Before starting any work, the function <code>resetFunc</code> is called by the worker to reset its state (or call nothing if the function pointer is NULL).</code></p>
<p><code><code>extraQueue</code> is the number of tasks that can be accepted by the work order queue in case if there is no worker available.</code></p>
<p><code>Before terminating, each worker will call <code>clearFunc</code> if the function is not NULL.</code></p>
<p><code>Default values are respectively 0 and NULL.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md778"></a>
&lt;tt&gt;void worker_clear(worker_t worker)&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Request termination to the pool of workers, and wait for them to terminate. It is undefined if there is any work order in progress.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md779"></a>
&lt;tt&gt;void worker_start(worker_block_t syncBlock, worker_t worker)&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Start a new synchronization block for a pool of work orders linked to the pool of worker <code>worker</code>.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md780"></a>
&lt;tt&gt;void worker_spawn(worker_block_t syncBlock, void (*func)(void *data), void *data)&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Register the work order <code>func(data)</code> to the synchronization point <code>syncBlock</code>. If no worker is available (and no <code>extraQueue</code>), the work order <code>func(data)</code> will be handled by the caller. Otherwise, the work order <code>func(data)</code> will be handled by an asynchronous worker and the function immediately returns. The object(s) referenced by <code>data</code> shall remain available (not destructed) until the control flow reaches the next synchronization point (<code>worker_sync</code>), as these object(s) may be delayed read by other threads until this point.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md781"></a>
&lt;tt&gt;bool worker_sync_p(worker_block_t syncBlock)&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Test if all work orders registered to this synchronization point are terminated (true) or not (false).</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md782"></a>
&lt;tt&gt;void worker_sync(worker_block_t syncBlock)&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Wait for all work orders registered to this synchronization point <code>syncBlock</code> to be terminated.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md783"></a>
&lt;tt&gt;size_t worker_count(worker_t worker)&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Return the number of workers of the pool.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md784"></a>
&lt;tt&gt;void worker_flush(worker_t worker)&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Flush any work order in the queue by the current thread until none remains.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md785"></a>
&lt;tt&gt;WORKER_SPAWN(syncBlock, input, core, output)&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Request the work order <code>core</code> to the synchronization point <code>syncBlock</code>. If no worker is available (and no extra queue), the work order <code>core</code> will be handled by the caller. Otherwise, the work order <code>core</code> will be handled by an asynchronous worker.</code></p>
<p><code><code>core</code> is any C code that doesn't break the control flow (you cannot use <code>return</code> / <code>goto</code> / <code>break</code> to go outside the flow). <code>input</code> is the list of local input variables of the <code>core</code> block within <code>( )</code>. <code>output</code> is the list of local output variables of the <code>core</code> block within <code>( )</code>. These lists shall be exhaustive to capture all needed variables.</code></p>
<p><code>This macro needs either GCC (for nested function) or CLANG (for blocks) or a C++11 compiler (for lambda and functional) to work.</code></p>
<p><code>The next synchronization point (worker_sync) shall be present in the control flow of the current C block.</code></p>
<p><code></p><blockquote class="doxtable">
<p>&zwj;[!NOTE] Even if nested functions are used for GCC, it doesn't generate a trampoline and the stack doesn't need to be executable as all variables are captured by the library. </p>
</blockquote>
<blockquote class="doxtable">
<p>&zwj;[!TIP] For CLANG, you need to add <code>-fblocks</code> to <code>CFLAGS</code> and <code>-lBlocksRuntime</code> to LIB (See CLANG manual). </p>
</blockquote>
<blockquote class="doxtable">
<p>&zwj;[!NOTE] It will generate warnings about shadowed variables. There is no way to avoid this. </p>
</blockquote>
<blockquote class="doxtable">
<p>&zwj;[!IMPORTANT] arrays and not trivially movable object are not supported as input / output variables due to current technical limitations. </p>
</blockquote>
<p></code></p>
<h3><a class="anchor" id="autotoc_md786"></a>
&lt;tt&gt;M_WORKER_SPAWN_DEF2(name, (name1, type1, oplist1), ...)&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Define a specialization of <code>worker_spawn</code>, called <code>m_worker_spawn ## name</code>, that takes as input a function with the given name and arguments, avoiding casting the data to <code>void*</code>. The specialized method shall have the following prototype:</code></p>
<p><code></p><div class="fragment"><div class="line"><span class="keywordtype">void</span> function(type1 name1, type2 name2, ...);</div>
</div><!-- fragment --><p></code></p>
<p><code><code>m_worker_spawn ## name</code> has the following prototypes.</code></p>
<p><code></p><div class="fragment"><div class="line"><span class="keywordtype">void</span> m_worker_spawn ## name(m_worker_sync_t block, </div>
<div class="line">                            <span class="keywordtype">void</span> (*callback)(type1 name1, type2 name2, ...), type1 name1, type2 name2, ...);</div>
</div><!-- fragment --><p></code></p>
<p><code>The arguments are properly copied and cleared using their oplists if the work-order is enqueued for a worker.</code></p>
<p><code></p><hr  />
<p></code></p>
<p><code></code></p>
<h2><a class="anchor" id="autotoc_md787"></a>
M-ATOMIC</h2>
<p><code></code></p>
<p><code>This header goal is to provide the C header <code>stdatomic.h</code> to any C compiler (C11 or C99 compliant) or C++ compiler. If available, it uses the C11 header <code>stdatomic.h</code>, otherwise if the compiler is a C++ compiler, it uses the header <code>atomic.h</code> and imports all definition into the global name space (this is needed because the C++ standard doesn't support officially the <code>stdatomic.h</code> header, resulting in broken compilation when building C code with a C++ compiler).</code></p>
<p><code>Otherwise, it provides a non-thin emulation of atomic using mutex. This emulation has a known theoretical limitation: the mutex are never cleared. There is nothing to do to fix this. In practice, it is not a problem.</code></p>
<p><code></p><hr  />
<p></code></p>
<p><code></code></p>
<h2><a class="anchor" id="autotoc_md788"></a>
M-ALGO</h2>
<p><code></code></p>
<p><code>This header is for generating generic algorithm to containers.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md789"></a>
&lt;tt&gt;ALGO_DEF(name, container_oplist)&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Define the available algorithms for the container which oplist is <code>container_oplist</code>. The defined algorithms depend on the availability of the methods of the containers (For example, if there is no <code>CMP</code> operator, there is no <code>MIN</code> method defined).</code></p>
<p><code>Example:</code></p>
<p><code></p><div class="fragment"><div class="line">ARRAY_DEF(array_int, <span class="keywordtype">int</span>)</div>
<div class="line">ALGO_DEF(array_int, ARRAY_OPLIST(array_int))</div>
<div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">void</span>) {</div>
<div class="line">        array_int_t l;</div>
<div class="line">        array_int_init(l);</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 100; i++)</div>
<div class="line">                array_int_push_back (l, i);</div>
<div class="line">        array_int_push_back (l, 17);</div>
<div class="line">        assert( array_int_contains(l, 62) == <span class="keyword">true</span>);</div>
<div class="line">        assert( array_int_contains(l, -1) == <span class="keyword">false</span>);</div>
<div class="line">        assert( array_int_count(l, 17) == 2);</div>
<div class="line">        array_int_clear(l);</div>
<div class="line">}</div>
</div><!-- fragment --><p></code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md790"></a>
Created methods</h3>
<p><code></code></p>
<p><code>The following methods are automatically and properly created by the previous macros. In the following methods, name stands for the name given to the macro that is used to identify the type.</code></p>
<p><code>In the following descriptions, <code>it_t</code> is an iterator of the container <code>container_t</code> is the type of the container and <code>type_t</code> is the type of object contained in the container.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md791"></a>
&lt;tt&gt;void name_find(it_t it, const container_t c, const type_t data)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Search for the first occurrence of <code>data</code> within the container. Update the iterator with the found position or return the end iterator. The search is linear.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md792"></a>
&lt;tt&gt;void name_find_again(it_t it, const type_t data)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Search from the position <code>it</code> for the next occurrence of <code>data</code> within the container. Update the iterator with the found position or return end iterator. The search is linear.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md793"></a>
&lt;tt&gt;void name_find_if(it_t it, const container_t c, bool (*pred)(type_t const))&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Search for the first occurrence within the container than matches the predicate <code>pred</code> Update the iterator with the found position or return end iterator. The search is linear.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md794"></a>
&lt;tt&gt;void name_find_again_if(it_t it, bool (*pred)(type_t const))&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Search from the position <code>it</code> for the next occurrence matching the predicate <code>pred</code> within the container. Update the iterator with the found position or return end iterator. The search is linear.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md795"></a>
&lt;tt&gt;void name_find_last(it_t it, const container_t c, const type_t data)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Search for the last occurrence of <code>data</code> within the container. Update the iterator with the found position or return end iterator. The search is linear and can be backward or forwards depending on the possibility of the container.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md796"></a>
&lt;tt&gt;bool name_contains(const container_t c, const type_t data)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Return true if <code>data</code> is within the container, false otherwise. The search is linear.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md797"></a>
&lt;tt&gt;size_t name_count(const container_t c, const type_t data)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Return the number of occurrence of <code>data</code> within the container. The search is linear.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md798"></a>
&lt;tt&gt;size_t name_count_if(const container_t c, bool (*pred)(type_t const data))&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Return the number of occurrence matching the predicate <code>pred</code> within the container. The search is linear.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md799"></a>
&lt;tt&gt;void name_mismatch(it_t it1, it_t it2, const container_t c1, const container_t c2)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Returns the first mismatching pair of elements of the two containers <code>c1</code> and <code>c2</code>.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md800"></a>
&lt;tt&gt;void name_mismatch_again(it_t it1, it_t it2)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Returns the next mismatching pair of elements of the two containers from the position <code>it1</code> of container <code>c1</code> and from the position <code>it2</code> of container <code>c2</code>.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md801"></a>
&lt;tt&gt;void name_mismatch_if(it_t it1, it_t it2, const container_t c1, const container_t c2, bool (*cmp)(type_t const, type_t const))&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Returns the first mismatching pair of elements of the two containers using the provided comparison <code>cmp</code>.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md802"></a>
&lt;tt&gt;void name_mismatch_again_if(it_t it1, it_t it2, bool (*cmp)(type_t const, type_t const))&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Returns the next mismatching pair of elements of the two containers using the provided comparison <code>cmp</code> from the position <code>it1</code> and from the position <code>it2</code>.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md803"></a>
&lt;tt&gt;void name_fill(container_t c, type_t value)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Set all elements of the container <code>c</code> to <code>value</code>.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md804"></a>
&lt;tt&gt;void name_fill_n(container_t c, size_t n, type_t value)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Set the container to <code>n</code> elements equal to <code>value</code>. This method is defined only if the container exports a <code>PUSH</code> method.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md805"></a>
&lt;tt&gt;void name_fill_a(container_t c, type_t value, type_t inc)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Set all elements of the container <code>c</code> to <code>value + i * inc</code> with <code>i = 0.. size(c)</code> This method is defined only if the base type exports an <code>ADD</code> method. This method is defined only if the container exports a <code>PUSH</code> method.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md806"></a>
&lt;tt&gt;void name_fill_an(container_t c, size_t n, type_t value)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Set the container to <code>n</code> elements to <code>value + i * inc</code> with <code>i = 0..n</code> This method is defined only if the base type exports an <code>ADD</code> method. This method is defined only if the container exports a <code>PUSH</code> method.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md807"></a>
&lt;tt&gt;void name_for_each(container_t c, void (*func)(type_t))&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Apply the function <code>func</code> to each element of the container <code>c</code>. The function may transform the element provided it doesn't reallocate the object and if the container supports iterating over modifiable elements.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md808"></a>
&lt;tt&gt;void name_transform(container_t d, container_t c, void (*func)(type_t *out, const type_t in))&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Apply the function <code>func</code> to each element of the container <code>c</code> and push the result into the container <code>d</code> so that <code>d = func(c)</code></code></p>
<p><code><code>func</code> shall output in the initialized object <code>out</code> the transformed value of the constant object <code>in</code>. Afterwards <code>out</code> is pushed moved into <code>d</code>.</code></p>
<p><code>This method is defined only if the base type exports an <code>INIT</code> method. This method is defined only if the container exports a <code>PUSH_MOVE</code> method. <code>c</code> and <code>d</code> cannot be the same containers.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md809"></a>
&lt;tt&gt;void name_reduce(type_t *dest, const container_t c, void (*func)(type_t *, type_t const))&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Perform a reduction using the function <code>func</code> to the elements of the container <code>c</code>. The final result is stored in <code>*dest</code>. If there is no element, <code>*dest</code> is let unmodified.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md810"></a>
&lt;tt&gt;void name_map_reduce(type_t *dest, const container_t c, void (*redFunc)(type_t *, type_t const), void *(mapFunc)(type_t *, type_t const))&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Perform a reduction using the function <code>redFunc</code> to the transformed elements of the container <code>c</code> using <code>mapFunc</code>. The final result is stored in <code>*dest</code>. If there is no element, <code>*dest</code> is let unmodified.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md811"></a>
&lt;tt&gt;bool name_any_of_p(const container_t c, void *(func)(const type_t))&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Test if any element of the container <code>c</code> matches the predicate <code>func</code>.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md812"></a>
&lt;tt&gt;bool name_all_of_p(const container_t c, void *(func)(const type_t))&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Test if all elements of the container <code>c</code> match the predicate <code>func</code>.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md813"></a>
&lt;tt&gt;bool name_none_of_p(const container_t c, void *(func)(const type_t))&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Test if no element of the container <code>c</code> match the predicate <code>func</code>.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md814"></a>
&lt;tt&gt;type_t *name_min(const container_t c)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Return a reference to the minimum element of the container <code>c</code>. Return NULL if there is no element. This method is available if the <code>CMP</code> operator has been defined.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md815"></a>
&lt;tt&gt;type_t *name_max(const container_t c)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Return a reference to the maximum element of the container <code>c</code>. Return NULL if there is no element. This method is available if the <code>CMP</code> operator has been defined.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md816"></a>
&lt;tt&gt;void name_minmax(type_t **min, type_t **max, const container_t c)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Stores in <code>*min</code> a reference to the minimum element of the container <code>c</code>. Stores in <code>*max</code> a reference to the minimum element of the container <code>c</code>. Stores NULL if there is no element. This method is available if the <code>CMP</code> operator has been defined.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md817"></a>
&lt;tt&gt;void name_uniq(container_t c)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Assuming the container <code>c</code> has been sorted, remove any duplicate elements of the container. This method is available if the <code>CMP</code> and <code>IT_REMOVE</code> operators have been defined.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md818"></a>
&lt;tt&gt;void name_remove_val(container_t c, type_t val)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Remove all elements equal to <code>val</code> of the container. This method is available if the <code>CMP</code> and <code>IT_REMOVE</code> operators have been defined.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md819"></a>
&lt;tt&gt;void name_remove_if(container_t c, bool (*func)(type_t) )&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Remove all elements matching the given condition (function <code>func()</code> returns true) of the container. This method is available if the <code>CMP</code> and <code>IT_REMOVE</code> operators have been defined.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md820"></a>
&lt;tt&gt;void name_add(container_t dest, const container_t value)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>For each element of the container <code>dest</code>, add the corresponding element of the container <code>dest</code> up to the minimum size of the containers. This method is available if the <code>ADD</code> operator has been defined.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md821"></a>
&lt;tt&gt;void name_sub(container_t dest, const container_t value)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>For each element of the container <code>dest</code>, sub the corresponding element of the container <code>dest</code> up to the minimum size of the containers. This method is available if the <code>SUB</code> operator has been defined.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md822"></a>
&lt;tt&gt;void name_mul(container_t dest, const container_t value)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>For each element of the container <code>dest</code>, mul the corresponding element of the container <code>dest</code> up to the minimum size of the containers. This method is available if the <code>MUL</code> operator has been defined.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md823"></a>
&lt;tt&gt;void name_div(container_t dest, const container_t value)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>For each element of the container <code>dest</code>, div the corresponding element of the container <code>dest</code> up to the minimum size of the containers. This method is available if the <code>DIV</code> operator has been defined.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md824"></a>
&lt;tt&gt;bool void name_sort_p(const container_t c)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Test if the container <code>c</code> is sorted (true) or not (false). This method is available if the <code>CMP</code> operator has been defined.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md825"></a>
&lt;tt&gt;bool name_sort_dsc_p(const container_t c)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Test if the container <code>c</code> is reverse sorted (=true) or not (=false) This method is available if the <code>CMP</code> operator has been defined.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md826"></a>
&lt;tt&gt;void void name_sort(container_t c)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Sort the container <code>c</code>. This method is available if the <code>CMP</code> operator has been defined. The used algorithm depends on the available operators: if a specialized <code>SORT</code> operator is defined for the container, it is used. if <code>SPLICE_BACK</code> and <code>SPLICE_AT</code> operates are defined, a merge sort is defined, if <code>IT_PREVIOUS</code> is defined, an insertion sort is used, otherwise a selection sort is used.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md827"></a>
&lt;tt&gt;bool name_sort_dsc(const container_t c)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Reverse sort the container <code>c</code>. This method is available if the <code>CMP</code> operator has been defined. The used algorithm depends on the available operators: if a specialized <code>SORT</code> operator is defined, it is used. if <code>SPLICE_BACK</code> and <code>SPLICE_AT</code> operates are defined, a merge sort is defined, if <code>IT_PREVIOUS</code> is defined, an insertion sort is used, otherwise a selection sort is used.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md828"></a>
&lt;tt&gt;void name_sort_union(container_t c1, const container_t c2)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Assuming both containers <code>c1</code> and <code>c2</code> are sorted, perform an union of the containers in <code>c1</code>. This method is available if the <code>IT_INSERT</code> operator is defined.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md829"></a>
&lt;tt&gt;void name_sort_dsc_union(container_t c1, const container_t c2)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Assuming both containers <code>c1</code> and <code>c2</code> are reverse sorted, perform an union of the containers in <code>c2</code>. This method is available if the IT_INSERT operator is defined.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md830"></a>
&lt;tt&gt;void name_sort_intersect(container_t c1, const container_t c2)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Assuming both containers <code>c1</code> and <code>c2</code> are sorted, perform an intersection of the containers in <code>c1</code>. This method is available if the IT_REMOVE operator is defined.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md831"></a>
&lt;tt&gt;void name_sort_dsc_intersect(container_t c, const container_t c)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Assuming both containers <code>c1</code> and <code>c2</code> are reverse sorted, perform an intersection of the containers in <code>c1</code>. This method is available if the IT_REMOVE operator is defined.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md832"></a>
&lt;tt&gt;void name_split(container_t c, const string_t str, const char sp)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Split the string <code>str</code> around the character separator <code>sp</code> into a set of string in the container <code>c</code>. This method is defined if the base type of the container is a <code>string_t</code> type,</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md833"></a>
&lt;tt&gt;void name_join(string_t dst, container_t c, const string_t str)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Join the string <code>str</code> and all the strings of the container <code>c</code> into <code>dst</code>. This method is defined if the base type of the container is a <code>string_t</code> type,</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md834"></a>
&lt;tt&gt;ALGO_FOR_EACH(container, oplist, func[, arguments..])&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Apply the function <code>func</code> to each element of the container <code>container</code> of oplist <code>oplist</code>:</code></p>
<p><code></p><div class="fragment"><div class="line"><span class="keywordflow">for</span> each item <span class="keywordflow">in</span> container do</div>
<div class="line">    func([arguments,] item)</div>
</div><!-- fragment --><p></code></p>
<p><code>The function <code>func</code> is a method that takes as argument an object of the container and returns nothing. It may update the object provided it doesn't reallocate it.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md835"></a>
&lt;tt&gt;ALGO_TRANSFORM(contDst, contDstOplist, contSrc, contSrcOplist, func[, arguments..])&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Apply the function <code>func</code> to each element of the container <code>contSrc</code> of oplist <code>contSrcOplist</code> and store its output in the container <code>contDst</code> of oplist <code>contDstOplist</code> so that <code>contDst = func(contSrc)</code>. Exact algorithm is:</code></p>
<p><code></p><div class="fragment"><div class="line">clean(contDst)</div>
<div class="line"><span class="keywordflow">for</span> each item <span class="keywordflow">in</span> do</div>
<div class="line">    init(tmp)</div>
<div class="line">    func(tmp, item, [, arguments])</div>
<div class="line">    push_move(contDst, tmp)</div>
</div><!-- fragment --><p></code></p>
<p><code>The function <code>func</code> is a method that takes as first argument the object to put in the new container, and as second argument the object in the source container.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md836"></a>
&lt;tt&gt;ALGO_EXTRACT(containerDest, oplistDest, containerSrc, oplistSrc[, func[, arguments..]])&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Extract the items of the container <code>containerSrc</code> of oplist <code>oplistSrc</code> into the <code>containerDest</code> of oplist <code>oplistDest</code>:</code></p>
<p><code></p><div class="fragment"><div class="line">RESET (containerDest)</div>
<div class="line"><span class="keywordflow">for</span> each item <span class="keywordflow">in</span> containerSrc do</div>
<div class="line">    [ <span class="keywordflow">if</span> func([arguments,] item) ] </div>
<div class="line">        Push item <span class="keywordflow">in</span> containerDest</div>
</div><!-- fragment --><p></code></p>
<p><code>The optional function <code>func</code> is a predicate that takes as argument an object of the container and returns a boolean that is true if the object has to be added to the other container.</code></p>
<p><code>Both containers shall either provide <code>PUSH</code> method, or <code>SET_KEY</code> method.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md837"></a>
&lt;tt&gt;ALGO_REDUCE(dest, container, oplist, reduceFunc[, mapFunc[, arguments..])&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Reduce the items of the container <code>container</code> of oplist <code>oplist</code> into a single element by applying the reduce function:</code></p>
<p><code></p><div class="fragment"><div class="line">dest = reduceFunc(mapFunc(item[0]), </div>
<div class="line">                  reduceFunc(..., reduceFunc(mapFunc(item[N-2]), </div>
<div class="line">                                             mapFunc(item[N-1]))))</div>
</div><!-- fragment --><p></code></p>
<p><code><code>mapFunc</code> is a method which prototype is:</code></p>
<p><code></p><div class="fragment"><div class="line"><span class="keywordtype">void</span> mapFunc(dest, item)</div>
</div><!-- fragment --><p></code></p>
<p><code>with both <code>dest</code> &amp; <code>item</code> that are of the same type as the one of the container. It transforms the <code>item</code> into another form that is suitable for the <code>reduceFunc</code>. If <code>mapFunc</code> is not specified, identity will be used instead.</code></p>
<p><code><code>reduceFunc</code> is a method which prototype is:</code></p>
<p><code></p><div class="fragment"><div class="line"><span class="keywordtype">void</span> reduceFunc(dest, item)</div>
</div><!-- fragment --><p></code></p>
<p><code>It integrates the new <code>item</code> into the partial <code>sum</code> and <code>dest</code>.</code></p>
<p><code>The reduce function can be the special keywords <code>add</code>, <code>sum</code>, <code>and</code>, <code>or</code> <code>product</code>, <code>mul</code> in which case the special function performing a <code>sum</code> / <code>sum</code> / <code>and</code> / <code>or</code> / <code>mul</code> operation will be used.</code></p>
<p><code><code>dest</code> can be either the variable (in which case <code>dest</code> is assumed to be of type equivalent to the elements of the container) or a tuple (<code>var</code>, <code>oplist</code>) with <code>var</code> being the variable name and <code>oplist</code> its oplist (with <code>TYPE</code>, <code>INIT</code>, <code>SET</code> methods). The tuple may be needed if the map function transform a type into another.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md838"></a>
&lt;tt&gt;ALGO_INSERT_AT(containerDst, containerDstOPLIST, position, containerSrc, containerSrcOPLIST)&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Insert into the container <code>contDst</code> at position <code>position</code> all the values of container <code>contSrc</code>.</code></p>
<p><code></p><hr  />
<p></code></p>
<p><code></code></p>
<h2><a class="anchor" id="autotoc_md839"></a>
M-FUNCOBJ</h2>
<p><code></code></p>
<p><code>This header is for generating Function Object. A <a href="https://en.wikipedia.org/wiki/Function_object">function object</a> is a construct an object to be invoked or called as if it were an ordinary function, usually with the same syntax (a function parameter that can also be a function) but with additional "within" parameters.</code></p>
<p><code>Example:</code></p>
<p><code></p><div class="fragment"><div class="line"><span class="comment">// Define generic interface of a function int --&gt; int</span></div>
<div class="line">FUNC_OBJ_ITF_DEF(interface, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define one instance of such interface</span></div>
<div class="line">FUNC_OBJ_INS_DEF(sumint, interface, x, {</div>
<div class="line">    <span class="keywordflow">return</span> self-&gt;sum + x;</div>
<div class="line">}, (sum, int)   )</div>
<div class="line"> </div>
<div class="line">int f(interface_t i)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> interface_call(i, 4);</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">int</span> h(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    sumint_t s;</div>
<div class="line">    sumint_init_with(s, 16);</div>
<div class="line">    interface_t <span class="keyword">interface </span>= sumint_as_interface(s);</div>
<div class="line">    <span class="keywordtype">int</span> n = f(interface);</div>
<div class="line">    printf(<span class="stringliteral">&quot;sum=%d\n&quot;</span>, n);</div>
<div class="line">    sumint_clear(s);</div>
<div class="line">}</div>
</div><!-- fragment --><p></code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md840"></a>
&lt;tt&gt;FUNC_OBJ_ITF_DEF(name, retcode_type[, type_of_param1, type_of_param 2, ...])&lt;/tt&gt;</h3>
<p><code> </code></p>
<h3><a class="anchor" id="autotoc_md841"></a>
&lt;tt&gt;FUNC_OBJ_ITF_DEF_AS(name, name_t, retcode_type[, type_of_param1, type_of_param 2, ...])&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Define a function object interface of name <code>name</code> emulating a function pointer returning <code>retcode_type</code> (which can be <code>void</code>), and with as inputs the list of types of <code>paramN</code>, thus generating a function prototype like this:</code></p>
<p><code></p><div class="fragment"><div class="line">retcode_type function(type_of_param1, type_of_param 2, ...)</div>
</div><!-- fragment --><p></code></p>
<p><code>An interface cannot be used without an instance (see below) that implements this interface. In particular, there is no init nor clear function for an interface (only an instance provides such initialization).</code></p>
<p><code><code>FUNC_OBJ_ITF_DEF_AS</code> is the same as <code>FUNC_OBJ_ITF_DEF</code> except the name of the type name_t is provided.</code></p>
<p><code>It will define the following type and functions:</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md842"></a>
&lt;tt&gt;name_t&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Type representing an interface to such function object. There is only one method for such type (see below). It is a pointer to an hidden structure and can be assigned.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md843"></a>
&lt;tt&gt;retcode_type name_call(name_t interface, type_of_param1, type_of_param 2, ...)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>The call function of the interface object. It will call the particular implemented callback of the instance of this interface. It shall only be used by an interface object derived from an instance.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md844"></a>
&lt;tt&gt;FUNC_OBJ_INS_DEF(name, interface_name, (param_name_1, ...), { callback_core }, (self_member1, self_type1[, self_oplist1]), ...)&lt;/tt&gt;</h3>
<p><code> </code></p>
<h3><a class="anchor" id="autotoc_md845"></a>
&lt;tt&gt;FUNC_OBJ_INS_DEF_AS(name, name_t, interface_name, (param_name_1, ...), { callback_core }, (self_member1, self_type1[, self_oplist1]), ...)&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Define a function object instance of name <code>name</code> implementing the interface <code>interface_name</code> (it is the same as used as name in <code>FUNC_OBJ_ITF_DEF</code>).</code></p>
<p><code>The function instance is defined as per:</code></p>
<p><code></p><ul>
<li>the function prototype of the inherited interface,</li>
<li>the parameters of the function are named as per the list <code>param_name_list</code>,</li>
<li>the core of the function shall be defined in the brackets within the callback_core. The members of the function object can be accessed through the pointer named <code>self</code> to access the member attributes of the object (without any cast), and the parameter names of the function shall be accessed as per their names in the <code>param_name_list</code>.</li>
<li>optional member attributes of the function object can be defined after the core (just like for tuple and variant): Each parameter is defined as a triplet: (<code>name</code>, <code>type</code> <code>[, oplist]</code>)</li>
</ul>
<p></code></p>
<p><code>It generates a function that looks like:</code></p>
<p><code></p><div class="fragment"><div class="line">interface_name_retcode_type function(interface_name_t *self, interface_name_type_of_param1 param_name_1, interface_name_type_of_param 2 param_name_2, ...) {</div>
<div class="line">       callback_core</div>
<div class="line">}</div>
</div><!-- fragment --><p></code></p>
<p><code><code>FUNC_OBJ_INS_DEF_AS</code> is the same as <code>FUNC_OBJ_INS_DEF</code> except the name of the type <code>name_t</code> is provided.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md846"></a>
&lt;tt&gt;name_t&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Name of a particular instance to the interface of the Function Object <code>interface_name</code>.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md847"></a>
&lt;tt&gt;void name_init(name_t self)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Initialize the instance of the function with default value. This method is defined only if all member attributes export an <code>INIT</code> method. If there is no member, the method is defined.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md848"></a>
&lt;tt&gt;void name_init_with(name_t self, self_type1 a1, self_type2 a2, ...)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Initialize the instance of the function with the given values of the member attributes.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md849"></a>
&lt;tt&gt;void name_clear(name_t self)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Clear the instance of the function.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md850"></a>
&lt;tt&gt;interface_name_t name_as_interface(name_t self)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Return the interface object derived from this instance. This object can then be transmitted to any function that accept the generic interface (mainly _call).</code></p>
<p><code></p><hr  />
<p></code></p>
<p><code></code></p>
<h2><a class="anchor" id="autotoc_md851"></a>
M-TRY</h2>
<p><code></code></p>
<p><code>This header is for <a href="https://en.wikipedia.org/wiki/Exception_handling">exception handling</a>. It provides basic functionality for throwing exception and catching then. The <code>setjmp</code> and <code>longjmp</code> standard library functions (or some variants) are used to implement the try / catch / throw macro keywords. It doesn't support the <code>finally</code> keyword. When building with a C++ compiler, theses macro keywords simply use the original C++ keyword in a way to match the specification below.</code></p>
<p><code>The whole program shall be compiled with the same exact compiler and the same target architecture.</code></p>
<p><code>Only one type of data is supported as exception. This is done to simplify the design and to avoid using exception as a general purpose error mechanism. It should only be used for rare case of errors which cannot be dealt locally in the program being executed (so called <em>abnormal error</em>).</code></p>
<p><code>In order to support <a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">Resource Acquisition Is Initialization</a> technique which frees resources using <a href="https://en.wikipedia.org/wiki/Destructor_(computer_programming)">destructor</a>, M*LIB ensures that the destructors of all variables created using the keyword <code>M_LET</code> are properly called on throwing exception. For this, different mechanisms are used to mark the objects and the <code>CLEAR</code> operator to be called on abnormal exceptions. This is done by injecting different information in the stack to be able to handle then. Therefore, contrary to C++, using exceptions in C will add a penalty performance to the program being executed in its nominal behavior. The exact cost depends on the mechanism used for RAII support. For GCC, it will use nested functions. For CLANG, it will use blocks (if compiled in blocks mode). Otherwise, it uses a standard compliant way, which is the slowest. The variable which are not initialized through the macro <code>M_LET</code> don't have their <code>CLEAR</code> method called on exceptions.</code></p>
<p><code>A typical program will look like:</code></p>
<p><code></p><div class="fragment"><div class="line">M_TRY(exception) {</div>
<div class="line">  M_LET(x, string_t) {</div>
<div class="line">    <span class="comment">// ... do operation on x</span></div>
<div class="line">    <span class="comment">// Throw a memory error of 1024 bytes.</span></div>
<div class="line">    M_THROW(M_ERROR_MEMORY, 1024);</div>
<div class="line">  }</div>
<div class="line">} M_CATCH(exception, M_ERROR_MEMORY) {</div>
<div class="line">  printf(<span class="stringliteral">&quot;There is no enough memory to allocate %zu bytes.\n&quot;</span>, (<span class="keywordtype">size_t</span>) exception-&gt;data[0]);</div>
<div class="line">}</div>
</div><!-- fragment --><p></code></p>
<p><code>In this example, the destructor of <code>x</code> will be called before catching the exception and resuming the program execution in the <code>M_CATCH</code> block.</code></p>
<p><code>You shall include this header before any other headers of M*LIB, so that it can configure the memory management of M*LIB to throw exception on memory errors. It does it by redefining the default macro <code>M_MEMORY_FULL</code> accordingly.</code></p>
<p><code>When using CLANG, you should add the following options to your compiler flags, otherwise it will compile in degraded mode:</code></p>
<p><code></p><div class="fragment"><div class="line">-fblocks -lBlocksRuntime</div>
</div><!-- fragment --><p></code></p>
<p><code>When writing your own constructor, you should consider <code>M_CHAIN_INIT</code> to support partially constructed object if there are more than two source of throwing in your object (any memory allocation is a source of throwing).</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md852"></a>
&lt;tt&gt;struct m_exception_s&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>This is the exception type. It is composed of the following fields:</code></p>
<p><code></p><ul>
<li><code>error_code</code>  The error code. It is used to identify the error that are raised the exception.</li>
<li><code>line</code>  The line number where the error was detected.</li>
<li><code>filename</code>  The filename (CSTR) where the error was detected.</li>
<li><code>num</code>  Number of entries in <code>context</code> table</li>
<li><code>context</code>  an array of <code>M_USE_MAX_CONTEXT</code> elements.</li>
</ul>
<p></code></p>
<p><code>You can access the fields of the type directly.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md853"></a>
&lt;tt&gt;M_TRY(name)&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Create a try block which name is <code>name</code> that will catch thrown exception (if any) and forward then to the associated catch block of the same name. The try block will start just after the keyword, with a brace character. If no catch block matches the error code raised, it will forward the error to the upper level try block. Until there is no longer any try block. In which case, it will terminate the program.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md854"></a>
&lt;tt&gt;M_CATCH(name, error_code)&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Create a catch block associated to the try block named <code>name</code>. The catch block will start just after the keyword, with a brace character. This catch block will be executed on throwing an exception with an error code matching error_code. If error_code is 0, it will catch all exceptions. Within the catch block, a pointer to the exception object of type <code><a class="el" href="structm__exception__s.html">m_exception_s</a></code> is available through the <code>name</code> variable.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md855"></a>
&lt;tt&gt;M_THROW(error_code[, ...])&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Throw the exception associated to the error_code. <code>error_code</code> shall be a positive integer constant. Additional arguments are used to fill in the error field of <code><a class="el" href="structm__exception__s.html">m_exception_s</a></code> that is used to identify the cause of the exception. The line and filename fields of the exception are filled automatically by the macro.</code></p>
<p><code></p><hr  />
<p></code></p>
<p><code></code></p>
<h2><a class="anchor" id="autotoc_md856"></a>
M-MEMPOOL</h2>
<p><code></code></p>
<p><code>This header is for generating specialized and optimized memory pools: it will generate specialized functions to allocate and free only one kind of an object. The mempool functions are not specially thread safe for a given mempool, but the mempool variable can have the attribute <code>M_THREAD_ATTR</code> so that each thread has its own instance of the mempool.</code></p>
<p><code>The memory pool has to be initialized and cleared like any other variable. Clearing the memory pool will free all the memory that has been allocated within this memory pool.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md857"></a>
&lt;tt&gt;MEMPOOL_DEF(name, type)&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Generate specialized functions &amp; types prefixed by <code>name</code> to <code>alloc</code> and <code>free</code> an object of type <code>type</code>.</code></p>
<p><code>Example:</code></p>
<p><code></p><div class="fragment"><div class="line">MEMPOOL_DEF(mempool_uint, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)</div>
<div class="line"> </div>
<div class="line">mempool_uint_t m;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">void</span>) {</div>
<div class="line">  mempool_uint_init(m);</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *p = mempool_uint_alloc(m);</div>
<div class="line">  *p = 17;</div>
<div class="line">  mempool_uint_free(m, p);</div>
<div class="line">  mempool_uint_clear(m);</div>
<div class="line">}</div>
</div><!-- fragment --><p></code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md858"></a>
Created methods</h3>
<p><code></code></p>
<p><code>The following methods are automatically and properly created by the previous macros. In the following methods, name stands for the name given to the macro that is used to identify the type.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md859"></a>
&lt;tt&gt;name_t&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>The type of a mempool.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md860"></a>
&lt;tt&gt;void name_init(name_t m)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Initialize the mempool <code>m</code>.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md861"></a>
&lt;tt&gt;void name_clear(name_t m)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Clear the mempool <code>m</code>. All allocated objects associated to the this mempool that weren't explicitly freed will be deleted too (without calling their clear method).</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md862"></a>
&lt;tt&gt;type *name_alloc(name_t m)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Create a new object of type <code>type</code> and return a new pointer to the uninitialized object.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md863"></a>
&lt;tt&gt;void name_free(name_t m, type *p)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Free the object <code>p</code> created by the call to <code>name_alloc</code>. The clear method of the type is not called.</code></p>
<p><code></p><hr  />
<p></code></p>
<p><code></code></p>
<h2><a class="anchor" id="autotoc_md864"></a>
M-SERIAL-JSON</h2>
<p><code></code></p>
<p><code>This header is for defining an instance of the serial interface supporting import (and export) of a container from (to) to a file in <a href="https://en.wikipedia.org/wiki/JSON">JSON</a> format. It uses the generic serialization ability of M*LIB for this purpose, providing a specialization of the serialization for JSON over <code>FILE*</code>.</code></p>
<p><code>Another way of seeing it is that you define your data structure using M*LIB containers (building it using basic types, strings, tuples, variants, array, dictionaries, ...) and then you can import / export your data structure for free in JSON format.</code></p>
<p><code>If the JSON file cannot be translated into the data structure, a failure error is reported (<code>M_SERIAL_FAIL</code>). For example, if some new fields are present in the JSON file but not in the data structure. On contrary, if some fields are missing (or in a different order) in the JSON file, the parsing will still succeed (object fields are unmodified except for new sub-objects, for which default value are used).</code></p>
<p><code>It is fully working with C11 compilers <b>only</b>.</code></p>
<p><code>The current locale of the program shall be compatible with the JSON format, specially the fraction separator character shall be <code>.</code> in the current locale to respect the JSON format.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md865"></a>
C functions on &lt;tt&gt;FILE&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md866"></a>
&lt;tt&gt;m_serial_json_write_t&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>A synonym of m_serial_write_t with a global oplist registered for use with JSON over <code>FILE*</code>.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md867"></a>
&lt;tt&gt;void m_serial_json_write_init(m_serial_write_t serial, FILE *f)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Initialize the <code>serial</code> object to be able to output in JSON format to the file <code>f</code>. The file <code>f</code> shall remain open in <code>wt</code> mode while the <code>serial</code> is not cleared.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md868"></a>
&lt;tt&gt;void m_serial_json_write_clear(m_serial_write_t serial)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Clear the serialization object <code>serial</code>.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md869"></a>
&lt;tt&gt;m_serial_json_read_t&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>A synonym of <code>m_serial_read_t</code> with a global oplist registered for use with JSON over <code>FILE*</code>.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md870"></a>
&lt;tt&gt;void m_serial_json_read_init(m_serial_read_t serial, FILE *f)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Initialize the <code>serial</code> object to be able to parse in JSON format from the file <code>f</code>. The file <code>f</code> shall remain open in <code>rt</code> mode while the <code>serial</code> is not cleared.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md871"></a>
&lt;tt&gt;void m_serial_json_read_clear(m_serial_read_t serial)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Clear the serialization object <code>serial</code>.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md872"></a>
C functions on string</h3>
<p><code></code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md873"></a>
&lt;tt&gt;m_serial_str_json_write_t&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>A synonym of <code>m_serial_write_t</code> with a global oplist registered for use with JSON over <code>string_t</code>.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md874"></a>
&lt;tt&gt;void m_serial_str_json_write_init(m_serial_write_t serial, string_t str)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Initialize the <code>serial</code> object to be able to output in JSON format to the string_t <code>str</code>. The string <code>str</code> shall remain initialized while the <code>serial</code> object is not cleared.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md875"></a>
&lt;tt&gt;void m_serial_str_json_write_clear(m_serial_write_t serial)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Clear the serialization object <code>serial</code>.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md876"></a>
&lt;tt&gt;m_serial_str_json_read_t&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>A synonym of <code>m_serial_read_t</code> with a global oplist registered for use with JSON over const string (<code>const char*</code>).</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md877"></a>
&lt;tt&gt;void m_serial_str_json_read_init(m_serial_read_t serial, const char str[])&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Initialize the <code>serial</code> object to be able to parse in JSON format from the const string <code>str</code>. The const string <code>str</code> shall remain initialized while the <code>serial</code> object is not cleared.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md878"></a>
&lt;tt&gt;const char * m_serial_str_json_read_clear(m_serial_read_t serial)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Clear the serialization object <code>serial</code> and return a pointer to the first unparsed character in the const string.</code></p>
<p><code>Example:</code></p>
<p><code></p><div class="fragment"><div class="line"><span class="comment">// Define a structure of two fields.</span></div>
<div class="line">TUPLE_DEF2(my,</div>
<div class="line">           (value, <span class="keywordtype">int</span>),</div>
<div class="line">           (name, string_t)</div>
<div class="line">           )</div>
<div class="line"><span class="preprocessor">#define M_OPL_my_t() TUPLE_OPLIST(my, M_BASIC_OPLIST, STRING_OPLIST)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Output in JSON file the structure my_t</span></div>
<div class="line"><span class="keywordtype">void</span> output(my_t el1)</div>
<div class="line">{</div>
<div class="line">  m_serial_write_t out;</div>
<div class="line">  m_serial_return_code_t ret;</div>
<div class="line"> </div>
<div class="line">  FILE *f = fopen (<span class="stringliteral">&quot;data.json&quot;</span>, <span class="stringliteral">&quot;wt&quot;</span>);</div>
<div class="line">  <span class="keywordflow">if</span> (!f) abort();</div>
<div class="line">  m_serial_json_write_init(out, f);</div>
<div class="line">  ret = my2_out_serial(out, el1);</div>
<div class="line">  assert (ret == M_SERIAL_OK_DONE);</div>
<div class="line">  m_serial_json_write_clear(out);</div>
<div class="line">  fclose(f);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get from JSON file the structure my_t</span></div>
<div class="line"><span class="keywordtype">void</span> input(my_t el1)</div>
<div class="line">{</div>
<div class="line">  m_serial_read_t  in;</div>
<div class="line">  m_serial_return_code_t ret;</div>
<div class="line"> </div>
<div class="line">  f = fopen (<span class="stringliteral">&quot;data.json&quot;</span>, <span class="stringliteral">&quot;rt&quot;</span>);</div>
<div class="line">  <span class="keywordflow">if</span> (!f) abort();</div>
<div class="line">  m_serial_json_read_init(in, f);</div>
<div class="line">  ret = my2_in_serial(el2, in);</div>
<div class="line">  assert (ret == M_SERIAL_OK_DONE);</div>
<div class="line">  m_serial_json_read_clear(in);</div>
<div class="line">  fclose(f);</div>
<div class="line">}</div>
</div><!-- fragment --><p></code></p>
<p><code></p><hr  />
<p></code></p>
<p><code></code></p>
<h2><a class="anchor" id="autotoc_md879"></a>
M-SERIAL-BIN</h2>
<p><code></code></p>
<p><code>This header is for defining an instance of the serial interface supporting import (and export) of a container from (to) to a file in an ad-hoc binary format. This format only supports the current system and cannot be used to communicate across multiple systems (endianness, size of types are typically not abstracted by this format).</code></p>
<p><code>It uses the generic serialization ability of M*LIB for this purpose, providing a specialization of the serialization for JSON over <code>FILE*</code>.</code></p>
<p><code>It is fully working with C11 compilers only.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md880"></a>
C functions</h3>
<p><code></code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md881"></a>
&lt;tt&gt;void m_serial_bin_write_init(m_serial_write_t serial, FILE *f)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Initialize the <code>serial</code> object to be able to output in BIN format to the file <code>f</code>. The file <code>f</code> has to remained open in 'wb' mode while the <code>serial</code> is not cleared otherwise the behavior of the object is undefined.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md882"></a>
&lt;tt&gt;void m_serial_bin_write_clear(m_serial_write_t serial)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Clear the serialization object <code>serial</code>.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md883"></a>
&lt;tt&gt;void m_serial_bin_read_init(m_serial_read_t serial, FILE *f)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Initialize the <code>serial</code> object to be able to parse in <code>BIN</code> format from the file <code>f</code>. The file <code>f</code> has to remained open in <code>rb</code> mode while the <code>serial</code> is not cleared otherwise the behavior of the object is undefined.</code></p>
<p><code></code></p>
<h4><a class="anchor" id="autotoc_md884"></a>
&lt;tt&gt;void m_serial_bin_read_clear(m_serial_read_t serial)&lt;/tt&gt;</h4>
<p><code></code></p>
<p><code>Clear the serialization object <code>serial</code>.</code></p>
<p><code></p><hr  />
<p></code></p>
<p><code></code></p>
<h2><a class="anchor" id="autotoc_md885"></a>
M-GENERIC</h2>
<p><code></code></p>
<p><code>This header is for registering and using a generic interface, regardless of the real type. More precisely it provides way of registering the oplist of a type. Then a variable of this type can be used in macro-like functions (<code>init</code>, <code>clear</code>, <code>push</code>, ...) and the associated method of this oplist will be used to handle the variable. If no type is associated to this variable, an error is reported by the compiler.</code></p>
<p><code>This header needs a C23 compliant compiler or a C11 compiler providing the typeof extension (like GCC, CLANG, MSVC).</code></p>
<p><code></p><blockquote class="doxtable">
<p>&zwj;[!NOTE] TCC is not supported yet due to some bugs in the compiler. </p>
</blockquote>
<p>This provides the same level of flexibility of the C++. However, there is some drawbacks of using this generic interface:</code></p>
<p><code></p><ul>
<li>Error messages can be more complex,</li>
<li>Compilation time increase a lot (on pair with C++)</li>
</ul>
<p></code></p>
<p><code>This header is still a WIP and is currently more a demo (Not ready for production).</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md886"></a>
Example</h3>
<p><code></code></p>
<p><code>A concrete example of the generic header is the following. It reuses the basic example of the introduction of the library.</code></p>
<p><code></p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;m-list.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;m-generic.h&quot;</span></div>
<div class="line"> </div>
<div class="line">LIST_DEF(list_uint, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Register oplist for M_LET &amp; M_EACH :</span></div>
<div class="line"><span class="preprocessor">#define M_OPL_list_uint_t() LIST_OPLIST(list_uint, M_BASIC_OPLIST)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Register for Generic (Organization, Component &amp; Oplist)</span></div>
<div class="line"><span class="preprocessor">#define M_GENERIC_ORG_1() (USER)</span></div>
<div class="line"><span class="preprocessor">#define M_GENERIC_ORG_USER_COMP_1() (CORE)</span></div>
<div class="line"><span class="preprocessor">#define M_GENERIC_ORG_USER_COMP_CORE_OPLIST_1() M_OPL_list_uint_t()</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    M_LET(list, list_uint_t) {</div>
<div class="line">        push(list, 42);</div>
<div class="line">        push(list, 17);</div>
<div class="line">        <span class="keywordflow">for each</span>(item, list) {</div>
<div class="line">            M_PRINT(<span class="stringliteral">&quot;ITEM=&quot;</span>, *item, <span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        M_PRINT(<span class="stringliteral">&quot;List = &quot;</span>, list, <span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p></code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md887"></a>
Registration</h3>
<p><code></code></p>
<p><code>To register an oplist you need to register three things:</code></p>
<p><code></p><ul>
<li>the <em>integration user</em> (user responsible for the integration of the whole program) registers all the <em>organizations</em> by mapping an integer from 1 to 50 to the short name of the organization.</li>
<li>the <em>organization user</em> (user responsible for the integration produced by an organization, typically a library or the program without its libraries) chooses the short name of the organization and registers all the <em>components</em> of this organization by mapping an integer from 1 to 50 to the short name of the component.</li>
<li>the <em>component user</em> (user responsible for a component of a library or a program) registers all the <em>oplists</em> of this component by mapping an integer from 1 to 50 to the oplist.</li>
</ul>
<p></code></p>
<p><code>This 3 levels registration is used to enable support for complex integration in real project. So, it maps the basic structure of a program so that each independent layer can register its own oplists independently of the others, and only the final integrator maps everything together.</code></p>
<p><code>To register an organization the <em>integration user</em> shall define a macro like this for all organizations:</code></p>
<p><code></p><div class="fragment"><div class="line"><span class="preprocessor">#define M_GENERIC_ORG_&lt;A_NUM&gt;() (&lt;ORGA_NAME&gt;)</span></div>
</div><!-- fragment --><p></code></p>
<p><code>with</code></p>
<p><code></p><ul>
<li><code>&lt;A_NUM&gt;</code> replaced by a unique integer in the range 1 to 50</li>
<li><code>&lt;ORGA_NAME&gt;</code> replaced by the short name of the organization.</li>
</ul>
<p></code></p>
<p><code>To register a component the <em>organization user</em> shall define a macro like this for all components:</code></p>
<p><code></p><div class="fragment"><div class="line"><span class="preprocessor">#define M_GENERIC_ORG_&lt;ORGA_NAME&gt;_COMP_&lt;A_NUM&gt;() (&lt;COMP_NAME&gt;)</span></div>
</div><!-- fragment --><p></code></p>
<p><code>with</code></p>
<p><code></p><ul>
<li><code>&lt;A_NUM&gt;</code> replaced by a unique integer in the range 1 to 50</li>
<li><code>&lt;ORGA_NAME&gt;</code> replaced by the short name of the organization.</li>
<li><code>&lt;COMP_NAME&gt;</code> replaced by the short name of the component.</li>
</ul>
<p></code></p>
<p><code>To register an oplist the <em>component user</em> shall define a macro like this for all oplists:</code></p>
<p><code></p><div class="fragment"><div class="line"><span class="preprocessor">#define M_GENERIC_ORG_&lt;ORGA_NAME&gt;_COMP_&lt;COMP_NAME&gt;_OPLIST_&lt;A_NUM&gt;() \</span></div>
<div class="line"><span class="preprocessor">        &lt;OP_LIST&gt;</span></div>
</div><!-- fragment --><p></code></p>
<p><code>with</code></p>
<p><code></p><ul>
<li><code>&lt;A_NUM&gt;</code> replaced by a unique integer in the range 1 to 50</li>
<li><code>&lt;ORGA_NAME&gt;</code> replaced by the short name of the organization.</li>
<li><code>&lt;COMP_NAME&gt;</code> replaced by the short name of the component.</li>
<li><code>&lt;OP_LIST&gt;</code> replaced by the oplist (no need for extra parenthesis).</li>
</ul>
<p></code></p>
<p><code>These macros should be defined in the header associated to their responsibility. To register something, you don't need to include the m-register header file.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md888"></a>
Usage</h3>
<p><code></code></p>
<p><code>The following macro functions are defined. They have the same behavior as their corresponding OPERATOR of the oplists:</code></p>
<p><code></p><div class="fragment"><div class="line">init(x);</div>
<div class="line">init_set(x, y);</div>
<div class="line">init_move(x, y);</div>
<div class="line">move(x, y);</div>
<div class="line">set(x, y);</div>
<div class="line">clear(x);</div>
<div class="line">swap(x, y);</div>
<div class="line">hash(x);</div>
<div class="line">equal(x, y);</div>
<div class="line">cmp(x, y);</div>
<div class="line">sort(x);</div>
<div class="line">splice_back(d, s, i);</div>
<div class="line">splice_at(d, <span class="keywordtype">id</span>, s, is);</div>
<div class="line">it_first(x, y);</div>
<div class="line">it_last(x, y);</div>
<div class="line">it_end(x, y);</div>
<div class="line">it_set(d, s);</div>
<div class="line">it_end_p(i);</div>
<div class="line">it_last_p(i);</div>
<div class="line">it_next(i);</div>
<div class="line">it_previous(i);</div>
<div class="line">it_ref(i);</div>
<div class="line">it_cref(i);</div>
<div class="line">it_equal(x, y);</div>
<div class="line">it_insert(c, i, o);</div>
<div class="line">it_remove(c, i);</div>
<div class="line">empty_p(x);</div>
<div class="line">add(x, y);</div>
<div class="line">sub(x, y);</div>
<div class="line">mul(x, y);</div>
<div class="line">div(x, y);</div>
<div class="line">reset(x);</div>
<div class="line">get(x, y);</div>
<div class="line">set_at(x, y, z);</div>
<div class="line">safe_get(x, y);</div>
<div class="line">erase(x, y);</div>
<div class="line">get_size(x);</div>
<div class="line">push(x, y);</div>
<div class="line">pop(x, y);</div>
<div class="line">push_move(x, y);</div>
<div class="line">pop_move(x, y);</div>
<div class="line">reverse(x);</div>
<div class="line">get_str(s, c, b);</div>
<div class="line">parse_str(c, s, e);</div>
<div class="line">out_str(x, y);</div>
<div class="line">in_str(x, y);</div>
<div class="line">out_serial(x, y);</div>
<div class="line">in_serial(x, y);</div>
</div><!-- fragment --><p></code></p>
<p><code>The following macro are defined and represents a type associated to the variable. They have the same behavior as their corresponding <code>OPERATOR</code> of the oplists and use the <code>typeof</code> keyword:</code></p>
<p><code></p><div class="fragment"><div class="line">it_type(x);</div>
<div class="line">sub_type(x);</div>
<div class="line">key_type(x);</div>
<div class="line">value_type(x);</div>
</div><!-- fragment --><p></code></p>
<p><code>The following macro is defined and enabled to iterate over a container (See example):</code></p>
<p><code></p><ul>
<li><code>each(item, container)</code></li>
</ul>
<p></code></p>
<p><code></p><blockquote class="doxtable">
<p>&zwj;[!Note] Only short names are defined in this header which may be incompatible with your own namespace (This header is still a WIP) </p>
</blockquote>
<hr  />
<p></code></p>
<p><code></code></p>
<h1><a class="anchor" id="autotoc_md889"></a>
Global User Customization</h1>
<p><code></code></p>
<p><code>The behavior of M*LIB can be customized globally by defining the following macros before including any headers of M*LIB. If a macro is not defined before including any M*LIB header, the default value will be used.</code></p>
<p><code>These macros shall not be defined after including any M*LIB header.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md890"></a>
&lt;tt&gt;M_USE_UNDEF_ATOMIC&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Undefine the macro <code>_Atomic</code> in <code><a class="el" href="m-atomic_8h_source.html">m-atomic.h</a></code> if <code>stdatomic.h</code> is included. It is needed on MSYS2 due to a bug in their headers which is not fixed yet.</code></p>
<p><code>Default value: <code>1</code> (undef) on MSYS2, <code>0</code> otherwise.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md891"></a>
&lt;tt&gt;M_USE_STDIO&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>This macro indicates if the system header <code>stdio.h</code> shall be included and the <code>FILE</code> functions be defined (<code>1</code>) or not (<code>0</code>). If it is not included, the macro <code>M_RAISE_FATAL</code> shall be defined by the user.</code></p>
<p><code>Default value: <code>1</code></code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md892"></a>
&lt;tt&gt;M_USE_STDARG&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>This macro indicates if the system header stdarg.h shall be included and the va_args functions be defined (<code>1</code>) or not (<code>0</code>).</code></p>
<p><code>Default value: <code>1</code> (true)</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md893"></a>
&lt;tt&gt;M_USE_SMALL_NAME&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>This macro indicates if the small names (without the <code>m_</code> prefix) have to be defined or not. Historically, only the small name API existed, so in order to keep API compatibility, the default is true.</code></p>
<p><code>Default value: <code>1</code></code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md894"></a>
&lt;tt&gt;M_USE_CSTR_ALLOC&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Define the allocation size of the temporary strings created by <code>M_CSTR</code> (including the final <code>\0</code> char).</code></p>
<p><code>Default value: <code>256</code></code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md895"></a>
&lt;tt&gt;M_USE_IDENTIFIER_ALLOC&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Define the allocation size of a C identifier in the source code (excluding the final <code>\0</code> char). It is used to represent a C identifier by a C string.</code></p>
<p><code>Default value: <code>128</code></code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md896"></a>
&lt;tt&gt;M_USE_THREAD_BACKEND&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Define the thread backend to use by <code><a class="el" href="m-thread_8h_source.html">m-thread.h</a></code>:</code></p>
<p><code></p><ol type="1">
<li>For C11 header <code>threads.h</code></li>
<li>For WINDOWS header <code>windows.h</code></li>
<li>For POSIX THREAD header <code>pthread.h</code></li>
<li>For FreeRTOS</li>
</ol>
<p></code></p>
<p><code>Default value: <code>auto-detect</code> in function of the running system.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md897"></a>
&lt;tt&gt;M_USE_WORKER&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>This macro indicates if the multi-thread code of <code><a class="el" href="m-worker_8h_source.html">m-worker.h</a></code> shall be used (<code>1</code>) or not (<code>0</code>)</code></p>
<p><code></p><blockquote class="doxtable">
<p>&zwj;[!IMPORTANT] In this case, a single-thread code is used </p>
</blockquote>
<p>Default value: <code>1</code></code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md898"></a>
&lt;tt&gt;M_USE_WORKER_CLANG_BLOCK&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>This macro indicates if the workers shall use the CLANG block extension (<code>1</code>) or not (<code>0</code>).</code></p>
<p><code>Default value: <code>1</code> (on clang), <code>0</code> (otherwise)</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md899"></a>
&lt;tt&gt;M_USE_WORKER_CPP_FUNCTION&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>This macro indicates if the workers shall use the C++ lambda function (<code>1</code>) or not (<code>0</code>).</code></p>
<p><code>Default value: <code>1</code> (compiled in C++), <code>0</code> (otherwise)</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md900"></a>
&lt;tt&gt;M_USE_BACKOFF_MAX_COUNT&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Define the maximum iteration of the <code>BACKOFF</code> exponential scheme for the synchronization waiting loop of multi-threading code.</code></p>
<p><code>Default value: <code>6</code></code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md901"></a>
&lt;tt&gt;M_USE_SERIAL_MAX_DATA_SIZE&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Define the size of the private data (reserved to the serial implementation) in a serial object (as a number of pointers or equivalent objects).</code></p>
<p><code>Default value: <code>4</code></code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md902"></a>
&lt;tt&gt;M_USE_MEMPOOL_MAX_PER_SEGMENT(type)&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Define the number of elements to allocate in a segment per object of type <code>type</code>.</code></p>
<p><code>Default value: number of elements that fits in a <code>16KB</code> page.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md903"></a>
&lt;tt&gt;M_USE_DEQUE_DEFAULT_SIZE&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Define the default size of a segment for a deque structure.</code></p>
<p><code>Default value: <code>8</code> elements.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md904"></a>
&lt;tt&gt;M_USE_HASH_SEED&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Define the seed to inject to the hash computation of an object.</code></p>
<p><code>Default value: <code>0</code> (predictable hash)</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md905"></a>
&lt;tt&gt;M_USE_FAST_STRING_CONV&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>Use fast integer conversion algorithms instead of using the LIBC.</code></p>
<p><code>Default value: <code>1</code> (because it also generates smaller code).</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md906"></a>
&lt;tt&gt;M_USE_DECL&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>If <code>M_USE_FINE_GRAINED_LINKAGE</code> is not defined, it will request M*LIB to change the linkage of its symbols globally: instead of inlining the functions, it will emit weak symbols for the functions that are not inlined.</code></p>
<p><code>And in exactly one translation unit, the macro <code>M_USE_DEF</code> should also be defined so that it emits the normal definition of the functions. In which case, it should contain all symbols used by all other translation units.</code></p>
<p><code>You should compile your program with: </p><div class="fragment"><div class="line">-ffunction-sections -fdata-sections</div>
</div><!-- fragment --><p> and link with </p><div class="fragment"><div class="line">-Wl,--gc-sections</div>
</div><!-- fragment --><p> in order to remove unused code and to merge identical code otherwise it is likely to generate even bigger code than using the inlining linkage.</code></p>
<p><code>This works for GCC / CLANG in C mode.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md907"></a>
&lt;tt&gt;M_USE_FINE_GRAINED_LINKAGE&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>It will request M*LIB to change the linkage of its symbols dynamically at compile time: in which case <code>M_USE_DECL</code> / <code>M_USE_DEF</code> can be defined / undefined several times in a translation unit and M*LIB will emit the change the linkage of the symbols being declared accordingly:</code></p>
<p><code></p><ul>
<li>definition like if <code>M_USE_DECL</code> and <code>M_USE_DEF</code> are defined</li>
<li>declaration like if <code>M_USE_DECL</code> is defined</li>
<li><code>inline</code> like otherwise</li>
</ul>
<p></code></p>
<p><code>This enables to inline some functions and not others.</code></p>
<p><code><code>M_USE_DECL</code> / <code>M_USE_DEF</code> shall be defined without effective value.</code></p>
<p><code>See <code>M_USE_DECL</code> for more details.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md908"></a>
&lt;tt&gt;M_USE_PRINT_OPLIST&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>If defined, it displays the oplist associated to the static assert.</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md909"></a>
&lt;tt&gt;M_MEMORY_ALLOC&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>See m-core.h</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md910"></a>
&lt;tt&gt;M_MEMORY_REALLOC&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>See m-core.h</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md911"></a>
&lt;tt&gt;M_MEMORY_FULL&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>See m-core.h</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md912"></a>
&lt;tt&gt;M_RAISE_FATAL&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>See m-core.h</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md913"></a>
&lt;tt&gt;M_ASSERT&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>See m-core.h</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md914"></a>
&lt;tt&gt;M_ASSERT_SLOW&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>See m-core.h</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md915"></a>
&lt;tt&gt;M_ASSERT_INIT&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>See m-core.h</code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md916"></a>
&lt;tt&gt;M_ASSERT_INDEX&lt;/tt&gt;</h3>
<p><code></code></p>
<p><code>See m-core.h</code></p>
<p><code></p><hr  />
<p></code></p>
<p><code></code></p>
<h1><a class="anchor" id="autotoc_md917"></a>
License</h1>
<p><code></code></p>
<p><code>All files of M*LIB are distributed under the following license.</code></p>
<p><code>Copyright (c) 2017-2024, Patrick Pelissier All rights reserved.</code></p>
<p><code>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</code></p>
<p><code></p><ul>
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
</ul>
<p></code></p>
<p><code>THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS `&lsquo;AS IS&rsquo;' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. </code></p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
